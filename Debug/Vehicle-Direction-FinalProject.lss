
Vehicle-Direction-FinalProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000146  00800100  00007c98  00007d2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007c98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006aa  00800246  00800246  00007e72  2**0
                  ALLOC
  3 .stab         0000a314  00000000  00000000  00007e74  2**2
                  CONTENTS, READONLY, DEBUGGING
<<<<<<< Updated upstream
  4 .stabstr      000065c7  00000000  00000000  00012174  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  0001873b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001b6  00000000  00000000  0001889b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001f0d  00000000  00000000  00018a51  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000010d2  00000000  00000000  0001a95e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001030  00000000  00000000  0001ba30  2**0
=======
  4 .stabstr      000065b1  00000000  00000000  00012188  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00018739  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001b6  00000000  00000000  00018899  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001f0d  00000000  00000000  00018a4f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000010d2  00000000  00000000  0001a95c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001030  00000000  00000000  0001ba2e  2**0
>>>>>>> Stashed changes
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  0001ca60  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002e6  00000000  00000000  0001cbe0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000008f6  00000000  00000000  0001cec6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001d7bc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      30:	0c 94 24 0a 	jmp	0x1448	; 0x1448 <__vector_12>
      34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      48:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      68:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      78:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	12 e0       	ldi	r17, 0x02	; 2
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e8 e9       	ldi	r30, 0x98	; 152
      a0:	fc e7       	ldi	r31, 0x7C	; 124
      a2:	02 c0       	rjmp	.+4      	; 0xa8 <.do_copy_data_start>

000000a4 <.do_copy_data_loop>:
      a4:	05 90       	lpm	r0, Z+
      a6:	0d 92       	st	X+, r0

000000a8 <.do_copy_data_start>:
      a8:	a6 34       	cpi	r26, 0x46	; 70
      aa:	b1 07       	cpc	r27, r17
      ac:	d9 f7       	brne	.-10     	; 0xa4 <.do_copy_data_loop>

000000ae <__do_clear_bss>:
      ae:	18 e0       	ldi	r17, 0x08	; 8
      b0:	a6 e4       	ldi	r26, 0x46	; 70
      b2:	b2 e0       	ldi	r27, 0x02	; 2
      b4:	01 c0       	rjmp	.+2      	; 0xb8 <.do_clear_bss_start>

000000b6 <.do_clear_bss_loop>:
      b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
      b8:	a0 3f       	cpi	r26, 0xF0	; 240
      ba:	b1 07       	cpc	r27, r17
      bc:	e1 f7       	brne	.-8      	; 0xb6 <.do_clear_bss_loop>
      be:	0e 94 be 3c 	call	0x797c	; 0x797c <main>
      c2:	0c 94 4a 3e 	jmp	0x7c94	; 0x7c94 <_exit>

000000c6 <__bad_interrupt>:
      c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ca <__fixunssfsi>:
      ca:	ef 92       	push	r14
      cc:	ff 92       	push	r15
      ce:	0f 93       	push	r16
      d0:	1f 93       	push	r17
      d2:	7b 01       	movw	r14, r22
      d4:	8c 01       	movw	r16, r24
      d6:	20 e0       	ldi	r18, 0x00	; 0
      d8:	30 e0       	ldi	r19, 0x00	; 0
      da:	40 e0       	ldi	r20, 0x00	; 0
      dc:	5f e4       	ldi	r21, 0x4F	; 79
      de:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gesf2>
      e2:	88 23       	and	r24, r24
      e4:	8c f0       	brlt	.+34     	; 0x108 <__fixunssfsi+0x3e>
      e6:	c8 01       	movw	r24, r16
      e8:	b7 01       	movw	r22, r14
      ea:	20 e0       	ldi	r18, 0x00	; 0
      ec:	30 e0       	ldi	r19, 0x00	; 0
      ee:	40 e0       	ldi	r20, 0x00	; 0
      f0:	5f e4       	ldi	r21, 0x4F	; 79
      f2:	0e 94 dd 01 	call	0x3ba	; 0x3ba <__subsf3>
      f6:	0e 94 11 04 	call	0x822	; 0x822 <__fixsfsi>
      fa:	9b 01       	movw	r18, r22
      fc:	ac 01       	movw	r20, r24
      fe:	20 50       	subi	r18, 0x00	; 0
     100:	30 40       	sbci	r19, 0x00	; 0
     102:	40 40       	sbci	r20, 0x00	; 0
     104:	50 48       	sbci	r21, 0x80	; 128
     106:	06 c0       	rjmp	.+12     	; 0x114 <__fixunssfsi+0x4a>
     108:	c8 01       	movw	r24, r16
     10a:	b7 01       	movw	r22, r14
     10c:	0e 94 11 04 	call	0x822	; 0x822 <__fixsfsi>
     110:	9b 01       	movw	r18, r22
     112:	ac 01       	movw	r20, r24
     114:	b9 01       	movw	r22, r18
     116:	ca 01       	movw	r24, r20
     118:	1f 91       	pop	r17
     11a:	0f 91       	pop	r16
     11c:	ff 90       	pop	r15
     11e:	ef 90       	pop	r14
     120:	08 95       	ret

00000122 <_fpadd_parts>:
     122:	a0 e0       	ldi	r26, 0x00	; 0
     124:	b0 e0       	ldi	r27, 0x00	; 0
     126:	e7 e9       	ldi	r30, 0x97	; 151
     128:	f0 e0       	ldi	r31, 0x00	; 0
     12a:	0c 94 03 3e 	jmp	0x7c06	; 0x7c06 <__prologue_saves__>
     12e:	dc 01       	movw	r26, r24
     130:	2b 01       	movw	r4, r22
     132:	fa 01       	movw	r30, r20
     134:	9c 91       	ld	r25, X
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	08 f4       	brcc	.+2      	; 0x13c <_fpadd_parts+0x1a>
     13a:	39 c1       	rjmp	.+626    	; 0x3ae <_fpadd_parts+0x28c>
     13c:	eb 01       	movw	r28, r22
     13e:	88 81       	ld	r24, Y
     140:	82 30       	cpi	r24, 0x02	; 2
     142:	08 f4       	brcc	.+2      	; 0x146 <_fpadd_parts+0x24>
     144:	33 c1       	rjmp	.+614    	; 0x3ac <_fpadd_parts+0x28a>
     146:	94 30       	cpi	r25, 0x04	; 4
     148:	69 f4       	brne	.+26     	; 0x164 <_fpadd_parts+0x42>
     14a:	84 30       	cpi	r24, 0x04	; 4
     14c:	09 f0       	breq	.+2      	; 0x150 <_fpadd_parts+0x2e>
     14e:	2f c1       	rjmp	.+606    	; 0x3ae <_fpadd_parts+0x28c>
     150:	11 96       	adiw	r26, 0x01	; 1
     152:	9c 91       	ld	r25, X
     154:	11 97       	sbiw	r26, 0x01	; 1
     156:	89 81       	ldd	r24, Y+1	; 0x01
     158:	98 17       	cp	r25, r24
     15a:	09 f4       	brne	.+2      	; 0x15e <_fpadd_parts+0x3c>
     15c:	28 c1       	rjmp	.+592    	; 0x3ae <_fpadd_parts+0x28c>
     15e:	a8 e2       	ldi	r26, 0x28	; 40
     160:	b1 e0       	ldi	r27, 0x01	; 1
     162:	25 c1       	rjmp	.+586    	; 0x3ae <_fpadd_parts+0x28c>
     164:	84 30       	cpi	r24, 0x04	; 4
     166:	09 f4       	brne	.+2      	; 0x16a <_fpadd_parts+0x48>
     168:	21 c1       	rjmp	.+578    	; 0x3ac <_fpadd_parts+0x28a>
     16a:	82 30       	cpi	r24, 0x02	; 2
     16c:	a9 f4       	brne	.+42     	; 0x198 <_fpadd_parts+0x76>
     16e:	92 30       	cpi	r25, 0x02	; 2
     170:	09 f0       	breq	.+2      	; 0x174 <_fpadd_parts+0x52>
     172:	1d c1       	rjmp	.+570    	; 0x3ae <_fpadd_parts+0x28c>
     174:	9a 01       	movw	r18, r20
     176:	ad 01       	movw	r20, r26
     178:	88 e0       	ldi	r24, 0x08	; 8
     17a:	ea 01       	movw	r28, r20
     17c:	09 90       	ld	r0, Y+
     17e:	ae 01       	movw	r20, r28
     180:	e9 01       	movw	r28, r18
     182:	09 92       	st	Y+, r0
     184:	9e 01       	movw	r18, r28
     186:	81 50       	subi	r24, 0x01	; 1
     188:	c1 f7       	brne	.-16     	; 0x17a <_fpadd_parts+0x58>
     18a:	e2 01       	movw	r28, r4
     18c:	89 81       	ldd	r24, Y+1	; 0x01
     18e:	11 96       	adiw	r26, 0x01	; 1
     190:	9c 91       	ld	r25, X
     192:	89 23       	and	r24, r25
     194:	81 83       	std	Z+1, r24	; 0x01
     196:	08 c1       	rjmp	.+528    	; 0x3a8 <_fpadd_parts+0x286>
     198:	92 30       	cpi	r25, 0x02	; 2
     19a:	09 f4       	brne	.+2      	; 0x19e <_fpadd_parts+0x7c>
     19c:	07 c1       	rjmp	.+526    	; 0x3ac <_fpadd_parts+0x28a>
     19e:	12 96       	adiw	r26, 0x02	; 2
     1a0:	2d 90       	ld	r2, X+
     1a2:	3c 90       	ld	r3, X
     1a4:	13 97       	sbiw	r26, 0x03	; 3
     1a6:	eb 01       	movw	r28, r22
     1a8:	8a 81       	ldd	r24, Y+2	; 0x02
     1aa:	9b 81       	ldd	r25, Y+3	; 0x03
     1ac:	14 96       	adiw	r26, 0x04	; 4
     1ae:	ad 90       	ld	r10, X+
     1b0:	bd 90       	ld	r11, X+
     1b2:	cd 90       	ld	r12, X+
     1b4:	dc 90       	ld	r13, X
     1b6:	17 97       	sbiw	r26, 0x07	; 7
     1b8:	ec 80       	ldd	r14, Y+4	; 0x04
     1ba:	fd 80       	ldd	r15, Y+5	; 0x05
     1bc:	0e 81       	ldd	r16, Y+6	; 0x06
     1be:	1f 81       	ldd	r17, Y+7	; 0x07
     1c0:	91 01       	movw	r18, r2
     1c2:	28 1b       	sub	r18, r24
     1c4:	39 0b       	sbc	r19, r25
     1c6:	b9 01       	movw	r22, r18
     1c8:	37 ff       	sbrs	r19, 7
     1ca:	04 c0       	rjmp	.+8      	; 0x1d4 <_fpadd_parts+0xb2>
     1cc:	66 27       	eor	r22, r22
     1ce:	77 27       	eor	r23, r23
     1d0:	62 1b       	sub	r22, r18
     1d2:	73 0b       	sbc	r23, r19
     1d4:	60 32       	cpi	r22, 0x20	; 32
     1d6:	71 05       	cpc	r23, r1
     1d8:	0c f0       	brlt	.+2      	; 0x1dc <_fpadd_parts+0xba>
     1da:	61 c0       	rjmp	.+194    	; 0x29e <_fpadd_parts+0x17c>
     1dc:	12 16       	cp	r1, r18
     1de:	13 06       	cpc	r1, r19
     1e0:	6c f5       	brge	.+90     	; 0x23c <_fpadd_parts+0x11a>
     1e2:	37 01       	movw	r6, r14
     1e4:	48 01       	movw	r8, r16
     1e6:	06 2e       	mov	r0, r22
     1e8:	04 c0       	rjmp	.+8      	; 0x1f2 <_fpadd_parts+0xd0>
     1ea:	96 94       	lsr	r9
     1ec:	87 94       	ror	r8
     1ee:	77 94       	ror	r7
     1f0:	67 94       	ror	r6
     1f2:	0a 94       	dec	r0
     1f4:	d2 f7       	brpl	.-12     	; 0x1ea <_fpadd_parts+0xc8>
     1f6:	21 e0       	ldi	r18, 0x01	; 1
     1f8:	30 e0       	ldi	r19, 0x00	; 0
     1fa:	40 e0       	ldi	r20, 0x00	; 0
     1fc:	50 e0       	ldi	r21, 0x00	; 0
     1fe:	04 c0       	rjmp	.+8      	; 0x208 <_fpadd_parts+0xe6>
     200:	22 0f       	add	r18, r18
     202:	33 1f       	adc	r19, r19
     204:	44 1f       	adc	r20, r20
     206:	55 1f       	adc	r21, r21
     208:	6a 95       	dec	r22
     20a:	d2 f7       	brpl	.-12     	; 0x200 <_fpadd_parts+0xde>
     20c:	21 50       	subi	r18, 0x01	; 1
     20e:	30 40       	sbci	r19, 0x00	; 0
     210:	40 40       	sbci	r20, 0x00	; 0
     212:	50 40       	sbci	r21, 0x00	; 0
     214:	2e 21       	and	r18, r14
     216:	3f 21       	and	r19, r15
     218:	40 23       	and	r20, r16
     21a:	51 23       	and	r21, r17
     21c:	21 15       	cp	r18, r1
     21e:	31 05       	cpc	r19, r1
     220:	41 05       	cpc	r20, r1
     222:	51 05       	cpc	r21, r1
     224:	21 f0       	breq	.+8      	; 0x22e <_fpadd_parts+0x10c>
     226:	21 e0       	ldi	r18, 0x01	; 1
     228:	30 e0       	ldi	r19, 0x00	; 0
     22a:	40 e0       	ldi	r20, 0x00	; 0
     22c:	50 e0       	ldi	r21, 0x00	; 0
     22e:	79 01       	movw	r14, r18
     230:	8a 01       	movw	r16, r20
     232:	e6 28       	or	r14, r6
     234:	f7 28       	or	r15, r7
     236:	08 29       	or	r16, r8
     238:	19 29       	or	r17, r9
     23a:	3c c0       	rjmp	.+120    	; 0x2b4 <_fpadd_parts+0x192>
     23c:	23 2b       	or	r18, r19
     23e:	d1 f1       	breq	.+116    	; 0x2b4 <_fpadd_parts+0x192>
     240:	26 0e       	add	r2, r22
     242:	37 1e       	adc	r3, r23
     244:	35 01       	movw	r6, r10
     246:	46 01       	movw	r8, r12
     248:	06 2e       	mov	r0, r22
     24a:	04 c0       	rjmp	.+8      	; 0x254 <_fpadd_parts+0x132>
     24c:	96 94       	lsr	r9
     24e:	87 94       	ror	r8
     250:	77 94       	ror	r7
     252:	67 94       	ror	r6
     254:	0a 94       	dec	r0
     256:	d2 f7       	brpl	.-12     	; 0x24c <_fpadd_parts+0x12a>
     258:	21 e0       	ldi	r18, 0x01	; 1
     25a:	30 e0       	ldi	r19, 0x00	; 0
     25c:	40 e0       	ldi	r20, 0x00	; 0
     25e:	50 e0       	ldi	r21, 0x00	; 0
     260:	04 c0       	rjmp	.+8      	; 0x26a <_fpadd_parts+0x148>
     262:	22 0f       	add	r18, r18
     264:	33 1f       	adc	r19, r19
     266:	44 1f       	adc	r20, r20
     268:	55 1f       	adc	r21, r21
     26a:	6a 95       	dec	r22
     26c:	d2 f7       	brpl	.-12     	; 0x262 <_fpadd_parts+0x140>
     26e:	21 50       	subi	r18, 0x01	; 1
     270:	30 40       	sbci	r19, 0x00	; 0
     272:	40 40       	sbci	r20, 0x00	; 0
     274:	50 40       	sbci	r21, 0x00	; 0
     276:	2a 21       	and	r18, r10
     278:	3b 21       	and	r19, r11
     27a:	4c 21       	and	r20, r12
     27c:	5d 21       	and	r21, r13
     27e:	21 15       	cp	r18, r1
     280:	31 05       	cpc	r19, r1
     282:	41 05       	cpc	r20, r1
     284:	51 05       	cpc	r21, r1
     286:	21 f0       	breq	.+8      	; 0x290 <_fpadd_parts+0x16e>
     288:	21 e0       	ldi	r18, 0x01	; 1
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	40 e0       	ldi	r20, 0x00	; 0
     28e:	50 e0       	ldi	r21, 0x00	; 0
     290:	59 01       	movw	r10, r18
     292:	6a 01       	movw	r12, r20
     294:	a6 28       	or	r10, r6
     296:	b7 28       	or	r11, r7
     298:	c8 28       	or	r12, r8
     29a:	d9 28       	or	r13, r9
     29c:	0b c0       	rjmp	.+22     	; 0x2b4 <_fpadd_parts+0x192>
     29e:	82 15       	cp	r24, r2
     2a0:	93 05       	cpc	r25, r3
     2a2:	2c f0       	brlt	.+10     	; 0x2ae <_fpadd_parts+0x18c>
     2a4:	1c 01       	movw	r2, r24
     2a6:	aa 24       	eor	r10, r10
     2a8:	bb 24       	eor	r11, r11
     2aa:	65 01       	movw	r12, r10
     2ac:	03 c0       	rjmp	.+6      	; 0x2b4 <_fpadd_parts+0x192>
     2ae:	ee 24       	eor	r14, r14
     2b0:	ff 24       	eor	r15, r15
     2b2:	87 01       	movw	r16, r14
     2b4:	11 96       	adiw	r26, 0x01	; 1
     2b6:	9c 91       	ld	r25, X
     2b8:	d2 01       	movw	r26, r4
     2ba:	11 96       	adiw	r26, 0x01	; 1
     2bc:	8c 91       	ld	r24, X
     2be:	98 17       	cp	r25, r24
     2c0:	09 f4       	brne	.+2      	; 0x2c4 <_fpadd_parts+0x1a2>
     2c2:	45 c0       	rjmp	.+138    	; 0x34e <_fpadd_parts+0x22c>
     2c4:	99 23       	and	r25, r25
     2c6:	39 f0       	breq	.+14     	; 0x2d6 <_fpadd_parts+0x1b4>
     2c8:	a8 01       	movw	r20, r16
     2ca:	97 01       	movw	r18, r14
     2cc:	2a 19       	sub	r18, r10
     2ce:	3b 09       	sbc	r19, r11
     2d0:	4c 09       	sbc	r20, r12
     2d2:	5d 09       	sbc	r21, r13
     2d4:	06 c0       	rjmp	.+12     	; 0x2e2 <_fpadd_parts+0x1c0>
     2d6:	a6 01       	movw	r20, r12
     2d8:	95 01       	movw	r18, r10
     2da:	2e 19       	sub	r18, r14
     2dc:	3f 09       	sbc	r19, r15
     2de:	40 0b       	sbc	r20, r16
     2e0:	51 0b       	sbc	r21, r17
     2e2:	57 fd       	sbrc	r21, 7
     2e4:	08 c0       	rjmp	.+16     	; 0x2f6 <_fpadd_parts+0x1d4>
     2e6:	11 82       	std	Z+1, r1	; 0x01
     2e8:	33 82       	std	Z+3, r3	; 0x03
     2ea:	22 82       	std	Z+2, r2	; 0x02
     2ec:	24 83       	std	Z+4, r18	; 0x04
     2ee:	35 83       	std	Z+5, r19	; 0x05
     2f0:	46 83       	std	Z+6, r20	; 0x06
     2f2:	57 83       	std	Z+7, r21	; 0x07
     2f4:	1d c0       	rjmp	.+58     	; 0x330 <_fpadd_parts+0x20e>
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	81 83       	std	Z+1, r24	; 0x01
     2fa:	33 82       	std	Z+3, r3	; 0x03
     2fc:	22 82       	std	Z+2, r2	; 0x02
     2fe:	88 27       	eor	r24, r24
     300:	99 27       	eor	r25, r25
     302:	dc 01       	movw	r26, r24
     304:	82 1b       	sub	r24, r18
     306:	93 0b       	sbc	r25, r19
     308:	a4 0b       	sbc	r26, r20
     30a:	b5 0b       	sbc	r27, r21
     30c:	84 83       	std	Z+4, r24	; 0x04
     30e:	95 83       	std	Z+5, r25	; 0x05
     310:	a6 83       	std	Z+6, r26	; 0x06
     312:	b7 83       	std	Z+7, r27	; 0x07
     314:	0d c0       	rjmp	.+26     	; 0x330 <_fpadd_parts+0x20e>
     316:	22 0f       	add	r18, r18
     318:	33 1f       	adc	r19, r19
     31a:	44 1f       	adc	r20, r20
     31c:	55 1f       	adc	r21, r21
     31e:	24 83       	std	Z+4, r18	; 0x04
     320:	35 83       	std	Z+5, r19	; 0x05
     322:	46 83       	std	Z+6, r20	; 0x06
     324:	57 83       	std	Z+7, r21	; 0x07
     326:	82 81       	ldd	r24, Z+2	; 0x02
     328:	93 81       	ldd	r25, Z+3	; 0x03
     32a:	01 97       	sbiw	r24, 0x01	; 1
     32c:	93 83       	std	Z+3, r25	; 0x03
     32e:	82 83       	std	Z+2, r24	; 0x02
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	da 01       	movw	r26, r20
     33a:	c9 01       	movw	r24, r18
     33c:	01 97       	sbiw	r24, 0x01	; 1
     33e:	a1 09       	sbc	r26, r1
     340:	b1 09       	sbc	r27, r1
     342:	8f 5f       	subi	r24, 0xFF	; 255
     344:	9f 4f       	sbci	r25, 0xFF	; 255
     346:	af 4f       	sbci	r26, 0xFF	; 255
     348:	bf 43       	sbci	r27, 0x3F	; 63
     34a:	28 f3       	brcs	.-54     	; 0x316 <_fpadd_parts+0x1f4>
     34c:	0b c0       	rjmp	.+22     	; 0x364 <_fpadd_parts+0x242>
     34e:	91 83       	std	Z+1, r25	; 0x01
     350:	33 82       	std	Z+3, r3	; 0x03
     352:	22 82       	std	Z+2, r2	; 0x02
     354:	ea 0c       	add	r14, r10
     356:	fb 1c       	adc	r15, r11
     358:	0c 1d       	adc	r16, r12
     35a:	1d 1d       	adc	r17, r13
     35c:	e4 82       	std	Z+4, r14	; 0x04
     35e:	f5 82       	std	Z+5, r15	; 0x05
     360:	06 83       	std	Z+6, r16	; 0x06
     362:	17 83       	std	Z+7, r17	; 0x07
     364:	83 e0       	ldi	r24, 0x03	; 3
     366:	80 83       	st	Z, r24
     368:	24 81       	ldd	r18, Z+4	; 0x04
     36a:	35 81       	ldd	r19, Z+5	; 0x05
     36c:	46 81       	ldd	r20, Z+6	; 0x06
     36e:	57 81       	ldd	r21, Z+7	; 0x07
     370:	57 ff       	sbrs	r21, 7
     372:	1a c0       	rjmp	.+52     	; 0x3a8 <_fpadd_parts+0x286>
     374:	c9 01       	movw	r24, r18
     376:	aa 27       	eor	r26, r26
     378:	97 fd       	sbrc	r25, 7
     37a:	a0 95       	com	r26
     37c:	ba 2f       	mov	r27, r26
     37e:	81 70       	andi	r24, 0x01	; 1
     380:	90 70       	andi	r25, 0x00	; 0
     382:	a0 70       	andi	r26, 0x00	; 0
     384:	b0 70       	andi	r27, 0x00	; 0
     386:	56 95       	lsr	r21
     388:	47 95       	ror	r20
     38a:	37 95       	ror	r19
     38c:	27 95       	ror	r18
     38e:	82 2b       	or	r24, r18
     390:	93 2b       	or	r25, r19
     392:	a4 2b       	or	r26, r20
     394:	b5 2b       	or	r27, r21
     396:	84 83       	std	Z+4, r24	; 0x04
     398:	95 83       	std	Z+5, r25	; 0x05
     39a:	a6 83       	std	Z+6, r26	; 0x06
     39c:	b7 83       	std	Z+7, r27	; 0x07
     39e:	82 81       	ldd	r24, Z+2	; 0x02
     3a0:	93 81       	ldd	r25, Z+3	; 0x03
     3a2:	01 96       	adiw	r24, 0x01	; 1
     3a4:	93 83       	std	Z+3, r25	; 0x03
     3a6:	82 83       	std	Z+2, r24	; 0x02
     3a8:	df 01       	movw	r26, r30
     3aa:	01 c0       	rjmp	.+2      	; 0x3ae <_fpadd_parts+0x28c>
     3ac:	d2 01       	movw	r26, r4
     3ae:	cd 01       	movw	r24, r26
     3b0:	cd b7       	in	r28, 0x3d	; 61
     3b2:	de b7       	in	r29, 0x3e	; 62
     3b4:	e2 e1       	ldi	r30, 0x12	; 18
     3b6:	0c 94 1f 3e 	jmp	0x7c3e	; 0x7c3e <__epilogue_restores__>

000003ba <__subsf3>:
     3ba:	a0 e2       	ldi	r26, 0x20	; 32
     3bc:	b0 e0       	ldi	r27, 0x00	; 0
     3be:	e3 ee       	ldi	r30, 0xE3	; 227
     3c0:	f1 e0       	ldi	r31, 0x01	; 1
     3c2:	0c 94 0f 3e 	jmp	0x7c1e	; 0x7c1e <__prologue_saves__+0x18>
     3c6:	69 83       	std	Y+1, r22	; 0x01
     3c8:	7a 83       	std	Y+2, r23	; 0x02
     3ca:	8b 83       	std	Y+3, r24	; 0x03
     3cc:	9c 83       	std	Y+4, r25	; 0x04
     3ce:	2d 83       	std	Y+5, r18	; 0x05
     3d0:	3e 83       	std	Y+6, r19	; 0x06
     3d2:	4f 83       	std	Y+7, r20	; 0x07
     3d4:	58 87       	std	Y+8, r21	; 0x08
     3d6:	e9 e0       	ldi	r30, 0x09	; 9
     3d8:	ee 2e       	mov	r14, r30
     3da:	f1 2c       	mov	r15, r1
     3dc:	ec 0e       	add	r14, r28
     3de:	fd 1e       	adc	r15, r29
     3e0:	ce 01       	movw	r24, r28
     3e2:	01 96       	adiw	r24, 0x01	; 1
     3e4:	b7 01       	movw	r22, r14
     3e6:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     3ea:	8e 01       	movw	r16, r28
     3ec:	0f 5e       	subi	r16, 0xEF	; 239
     3ee:	1f 4f       	sbci	r17, 0xFF	; 255
     3f0:	ce 01       	movw	r24, r28
     3f2:	05 96       	adiw	r24, 0x05	; 5
     3f4:	b8 01       	movw	r22, r16
     3f6:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     3fa:	8a 89       	ldd	r24, Y+18	; 0x12
     3fc:	91 e0       	ldi	r25, 0x01	; 1
     3fe:	89 27       	eor	r24, r25
     400:	8a 8b       	std	Y+18, r24	; 0x12
     402:	c7 01       	movw	r24, r14
     404:	b8 01       	movw	r22, r16
     406:	ae 01       	movw	r20, r28
     408:	47 5e       	subi	r20, 0xE7	; 231
     40a:	5f 4f       	sbci	r21, 0xFF	; 255
     40c:	0e 94 91 00 	call	0x122	; 0x122 <_fpadd_parts>
     410:	0e 94 2d 05 	call	0xa5a	; 0xa5a <__pack_f>
     414:	a0 96       	adiw	r28, 0x20	; 32
     416:	e6 e0       	ldi	r30, 0x06	; 6
     418:	0c 94 2b 3e 	jmp	0x7c56	; 0x7c56 <__epilogue_restores__+0x18>

0000041c <__addsf3>:
     41c:	a0 e2       	ldi	r26, 0x20	; 32
     41e:	b0 e0       	ldi	r27, 0x00	; 0
     420:	e4 e1       	ldi	r30, 0x14	; 20
     422:	f2 e0       	ldi	r31, 0x02	; 2
     424:	0c 94 0f 3e 	jmp	0x7c1e	; 0x7c1e <__prologue_saves__+0x18>
     428:	69 83       	std	Y+1, r22	; 0x01
     42a:	7a 83       	std	Y+2, r23	; 0x02
     42c:	8b 83       	std	Y+3, r24	; 0x03
     42e:	9c 83       	std	Y+4, r25	; 0x04
     430:	2d 83       	std	Y+5, r18	; 0x05
     432:	3e 83       	std	Y+6, r19	; 0x06
     434:	4f 83       	std	Y+7, r20	; 0x07
     436:	58 87       	std	Y+8, r21	; 0x08
     438:	f9 e0       	ldi	r31, 0x09	; 9
     43a:	ef 2e       	mov	r14, r31
     43c:	f1 2c       	mov	r15, r1
     43e:	ec 0e       	add	r14, r28
     440:	fd 1e       	adc	r15, r29
     442:	ce 01       	movw	r24, r28
     444:	01 96       	adiw	r24, 0x01	; 1
     446:	b7 01       	movw	r22, r14
     448:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     44c:	8e 01       	movw	r16, r28
     44e:	0f 5e       	subi	r16, 0xEF	; 239
     450:	1f 4f       	sbci	r17, 0xFF	; 255
     452:	ce 01       	movw	r24, r28
     454:	05 96       	adiw	r24, 0x05	; 5
     456:	b8 01       	movw	r22, r16
     458:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     45c:	c7 01       	movw	r24, r14
     45e:	b8 01       	movw	r22, r16
     460:	ae 01       	movw	r20, r28
     462:	47 5e       	subi	r20, 0xE7	; 231
     464:	5f 4f       	sbci	r21, 0xFF	; 255
     466:	0e 94 91 00 	call	0x122	; 0x122 <_fpadd_parts>
     46a:	0e 94 2d 05 	call	0xa5a	; 0xa5a <__pack_f>
     46e:	a0 96       	adiw	r28, 0x20	; 32
     470:	e6 e0       	ldi	r30, 0x06	; 6
     472:	0c 94 2b 3e 	jmp	0x7c56	; 0x7c56 <__epilogue_restores__+0x18>

00000476 <__mulsf3>:
     476:	a0 e2       	ldi	r26, 0x20	; 32
     478:	b0 e0       	ldi	r27, 0x00	; 0
     47a:	e1 e4       	ldi	r30, 0x41	; 65
     47c:	f2 e0       	ldi	r31, 0x02	; 2
     47e:	0c 94 03 3e 	jmp	0x7c06	; 0x7c06 <__prologue_saves__>
     482:	69 83       	std	Y+1, r22	; 0x01
     484:	7a 83       	std	Y+2, r23	; 0x02
     486:	8b 83       	std	Y+3, r24	; 0x03
     488:	9c 83       	std	Y+4, r25	; 0x04
     48a:	2d 83       	std	Y+5, r18	; 0x05
     48c:	3e 83       	std	Y+6, r19	; 0x06
     48e:	4f 83       	std	Y+7, r20	; 0x07
     490:	58 87       	std	Y+8, r21	; 0x08
     492:	ce 01       	movw	r24, r28
     494:	01 96       	adiw	r24, 0x01	; 1
     496:	be 01       	movw	r22, r28
     498:	67 5f       	subi	r22, 0xF7	; 247
     49a:	7f 4f       	sbci	r23, 0xFF	; 255
     49c:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     4a0:	ce 01       	movw	r24, r28
     4a2:	05 96       	adiw	r24, 0x05	; 5
     4a4:	be 01       	movw	r22, r28
     4a6:	6f 5e       	subi	r22, 0xEF	; 239
     4a8:	7f 4f       	sbci	r23, 0xFF	; 255
     4aa:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     4ae:	99 85       	ldd	r25, Y+9	; 0x09
     4b0:	92 30       	cpi	r25, 0x02	; 2
     4b2:	88 f0       	brcs	.+34     	; 0x4d6 <__mulsf3+0x60>
     4b4:	89 89       	ldd	r24, Y+17	; 0x11
     4b6:	82 30       	cpi	r24, 0x02	; 2
     4b8:	c8 f0       	brcs	.+50     	; 0x4ec <__mulsf3+0x76>
     4ba:	94 30       	cpi	r25, 0x04	; 4
     4bc:	19 f4       	brne	.+6      	; 0x4c4 <__mulsf3+0x4e>
     4be:	82 30       	cpi	r24, 0x02	; 2
     4c0:	51 f4       	brne	.+20     	; 0x4d6 <__mulsf3+0x60>
     4c2:	04 c0       	rjmp	.+8      	; 0x4cc <__mulsf3+0x56>
     4c4:	84 30       	cpi	r24, 0x04	; 4
     4c6:	29 f4       	brne	.+10     	; 0x4d2 <__mulsf3+0x5c>
     4c8:	92 30       	cpi	r25, 0x02	; 2
     4ca:	81 f4       	brne	.+32     	; 0x4ec <__mulsf3+0x76>
     4cc:	88 e2       	ldi	r24, 0x28	; 40
     4ce:	91 e0       	ldi	r25, 0x01	; 1
     4d0:	c6 c0       	rjmp	.+396    	; 0x65e <__mulsf3+0x1e8>
     4d2:	92 30       	cpi	r25, 0x02	; 2
     4d4:	49 f4       	brne	.+18     	; 0x4e8 <__mulsf3+0x72>
     4d6:	20 e0       	ldi	r18, 0x00	; 0
     4d8:	9a 85       	ldd	r25, Y+10	; 0x0a
     4da:	8a 89       	ldd	r24, Y+18	; 0x12
     4dc:	98 13       	cpse	r25, r24
     4de:	21 e0       	ldi	r18, 0x01	; 1
     4e0:	2a 87       	std	Y+10, r18	; 0x0a
     4e2:	ce 01       	movw	r24, r28
     4e4:	09 96       	adiw	r24, 0x09	; 9
     4e6:	bb c0       	rjmp	.+374    	; 0x65e <__mulsf3+0x1e8>
     4e8:	82 30       	cpi	r24, 0x02	; 2
     4ea:	49 f4       	brne	.+18     	; 0x4fe <__mulsf3+0x88>
     4ec:	20 e0       	ldi	r18, 0x00	; 0
     4ee:	9a 85       	ldd	r25, Y+10	; 0x0a
     4f0:	8a 89       	ldd	r24, Y+18	; 0x12
     4f2:	98 13       	cpse	r25, r24
     4f4:	21 e0       	ldi	r18, 0x01	; 1
     4f6:	2a 8b       	std	Y+18, r18	; 0x12
     4f8:	ce 01       	movw	r24, r28
     4fa:	41 96       	adiw	r24, 0x11	; 17
     4fc:	b0 c0       	rjmp	.+352    	; 0x65e <__mulsf3+0x1e8>
     4fe:	2d 84       	ldd	r2, Y+13	; 0x0d
     500:	3e 84       	ldd	r3, Y+14	; 0x0e
     502:	4f 84       	ldd	r4, Y+15	; 0x0f
     504:	58 88       	ldd	r5, Y+16	; 0x10
     506:	6d 88       	ldd	r6, Y+21	; 0x15
     508:	7e 88       	ldd	r7, Y+22	; 0x16
     50a:	8f 88       	ldd	r8, Y+23	; 0x17
     50c:	98 8c       	ldd	r9, Y+24	; 0x18
     50e:	ee 24       	eor	r14, r14
     510:	ff 24       	eor	r15, r15
     512:	87 01       	movw	r16, r14
     514:	aa 24       	eor	r10, r10
     516:	bb 24       	eor	r11, r11
     518:	65 01       	movw	r12, r10
     51a:	40 e0       	ldi	r20, 0x00	; 0
     51c:	50 e0       	ldi	r21, 0x00	; 0
     51e:	60 e0       	ldi	r22, 0x00	; 0
     520:	70 e0       	ldi	r23, 0x00	; 0
     522:	e0 e0       	ldi	r30, 0x00	; 0
     524:	f0 e0       	ldi	r31, 0x00	; 0
     526:	c1 01       	movw	r24, r2
     528:	81 70       	andi	r24, 0x01	; 1
     52a:	90 70       	andi	r25, 0x00	; 0
     52c:	89 2b       	or	r24, r25
     52e:	e9 f0       	breq	.+58     	; 0x56a <__mulsf3+0xf4>
     530:	e6 0c       	add	r14, r6
     532:	f7 1c       	adc	r15, r7
     534:	08 1d       	adc	r16, r8
     536:	19 1d       	adc	r17, r9
     538:	9a 01       	movw	r18, r20
     53a:	ab 01       	movw	r20, r22
     53c:	2a 0d       	add	r18, r10
     53e:	3b 1d       	adc	r19, r11
     540:	4c 1d       	adc	r20, r12
     542:	5d 1d       	adc	r21, r13
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	a0 e0       	ldi	r26, 0x00	; 0
     54a:	b0 e0       	ldi	r27, 0x00	; 0
     54c:	e6 14       	cp	r14, r6
     54e:	f7 04       	cpc	r15, r7
     550:	08 05       	cpc	r16, r8
     552:	19 05       	cpc	r17, r9
     554:	20 f4       	brcc	.+8      	; 0x55e <__mulsf3+0xe8>
     556:	81 e0       	ldi	r24, 0x01	; 1
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	a0 e0       	ldi	r26, 0x00	; 0
     55c:	b0 e0       	ldi	r27, 0x00	; 0
     55e:	ba 01       	movw	r22, r20
     560:	a9 01       	movw	r20, r18
     562:	48 0f       	add	r20, r24
     564:	59 1f       	adc	r21, r25
     566:	6a 1f       	adc	r22, r26
     568:	7b 1f       	adc	r23, r27
     56a:	aa 0c       	add	r10, r10
     56c:	bb 1c       	adc	r11, r11
     56e:	cc 1c       	adc	r12, r12
     570:	dd 1c       	adc	r13, r13
     572:	97 fe       	sbrs	r9, 7
     574:	08 c0       	rjmp	.+16     	; 0x586 <__mulsf3+0x110>
     576:	81 e0       	ldi	r24, 0x01	; 1
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	a0 e0       	ldi	r26, 0x00	; 0
     57c:	b0 e0       	ldi	r27, 0x00	; 0
     57e:	a8 2a       	or	r10, r24
     580:	b9 2a       	or	r11, r25
     582:	ca 2a       	or	r12, r26
     584:	db 2a       	or	r13, r27
     586:	31 96       	adiw	r30, 0x01	; 1
     588:	e0 32       	cpi	r30, 0x20	; 32
     58a:	f1 05       	cpc	r31, r1
     58c:	49 f0       	breq	.+18     	; 0x5a0 <__mulsf3+0x12a>
     58e:	66 0c       	add	r6, r6
     590:	77 1c       	adc	r7, r7
     592:	88 1c       	adc	r8, r8
     594:	99 1c       	adc	r9, r9
     596:	56 94       	lsr	r5
     598:	47 94       	ror	r4
     59a:	37 94       	ror	r3
     59c:	27 94       	ror	r2
     59e:	c3 cf       	rjmp	.-122    	; 0x526 <__mulsf3+0xb0>
     5a0:	fa 85       	ldd	r31, Y+10	; 0x0a
     5a2:	ea 89       	ldd	r30, Y+18	; 0x12
     5a4:	2b 89       	ldd	r18, Y+19	; 0x13
     5a6:	3c 89       	ldd	r19, Y+20	; 0x14
     5a8:	8b 85       	ldd	r24, Y+11	; 0x0b
     5aa:	9c 85       	ldd	r25, Y+12	; 0x0c
     5ac:	28 0f       	add	r18, r24
     5ae:	39 1f       	adc	r19, r25
     5b0:	2e 5f       	subi	r18, 0xFE	; 254
     5b2:	3f 4f       	sbci	r19, 0xFF	; 255
     5b4:	17 c0       	rjmp	.+46     	; 0x5e4 <__mulsf3+0x16e>
     5b6:	ca 01       	movw	r24, r20
     5b8:	81 70       	andi	r24, 0x01	; 1
     5ba:	90 70       	andi	r25, 0x00	; 0
     5bc:	89 2b       	or	r24, r25
     5be:	61 f0       	breq	.+24     	; 0x5d8 <__mulsf3+0x162>
     5c0:	16 95       	lsr	r17
     5c2:	07 95       	ror	r16
     5c4:	f7 94       	ror	r15
     5c6:	e7 94       	ror	r14
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	90 e0       	ldi	r25, 0x00	; 0
     5cc:	a0 e0       	ldi	r26, 0x00	; 0
     5ce:	b0 e8       	ldi	r27, 0x80	; 128
     5d0:	e8 2a       	or	r14, r24
     5d2:	f9 2a       	or	r15, r25
     5d4:	0a 2b       	or	r16, r26
     5d6:	1b 2b       	or	r17, r27
     5d8:	76 95       	lsr	r23
     5da:	67 95       	ror	r22
     5dc:	57 95       	ror	r21
     5de:	47 95       	ror	r20
     5e0:	2f 5f       	subi	r18, 0xFF	; 255
     5e2:	3f 4f       	sbci	r19, 0xFF	; 255
     5e4:	77 fd       	sbrc	r23, 7
     5e6:	e7 cf       	rjmp	.-50     	; 0x5b6 <__mulsf3+0x140>
     5e8:	0c c0       	rjmp	.+24     	; 0x602 <__mulsf3+0x18c>
     5ea:	44 0f       	add	r20, r20
     5ec:	55 1f       	adc	r21, r21
     5ee:	66 1f       	adc	r22, r22
     5f0:	77 1f       	adc	r23, r23
     5f2:	17 fd       	sbrc	r17, 7
     5f4:	41 60       	ori	r20, 0x01	; 1
     5f6:	ee 0c       	add	r14, r14
     5f8:	ff 1c       	adc	r15, r15
     5fa:	00 1f       	adc	r16, r16
     5fc:	11 1f       	adc	r17, r17
     5fe:	21 50       	subi	r18, 0x01	; 1
     600:	30 40       	sbci	r19, 0x00	; 0
     602:	40 30       	cpi	r20, 0x00	; 0
     604:	90 e0       	ldi	r25, 0x00	; 0
     606:	59 07       	cpc	r21, r25
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	69 07       	cpc	r22, r25
     60c:	90 e4       	ldi	r25, 0x40	; 64
     60e:	79 07       	cpc	r23, r25
     610:	60 f3       	brcs	.-40     	; 0x5ea <__mulsf3+0x174>
     612:	2b 8f       	std	Y+27, r18	; 0x1b
     614:	3c 8f       	std	Y+28, r19	; 0x1c
     616:	db 01       	movw	r26, r22
     618:	ca 01       	movw	r24, r20
     61a:	8f 77       	andi	r24, 0x7F	; 127
     61c:	90 70       	andi	r25, 0x00	; 0
     61e:	a0 70       	andi	r26, 0x00	; 0
     620:	b0 70       	andi	r27, 0x00	; 0
     622:	80 34       	cpi	r24, 0x40	; 64
     624:	91 05       	cpc	r25, r1
     626:	a1 05       	cpc	r26, r1
     628:	b1 05       	cpc	r27, r1
     62a:	61 f4       	brne	.+24     	; 0x644 <__mulsf3+0x1ce>
     62c:	47 fd       	sbrc	r20, 7
     62e:	0a c0       	rjmp	.+20     	; 0x644 <__mulsf3+0x1ce>
     630:	e1 14       	cp	r14, r1
     632:	f1 04       	cpc	r15, r1
     634:	01 05       	cpc	r16, r1
     636:	11 05       	cpc	r17, r1
     638:	29 f0       	breq	.+10     	; 0x644 <__mulsf3+0x1ce>
     63a:	40 5c       	subi	r20, 0xC0	; 192
     63c:	5f 4f       	sbci	r21, 0xFF	; 255
     63e:	6f 4f       	sbci	r22, 0xFF	; 255
     640:	7f 4f       	sbci	r23, 0xFF	; 255
     642:	40 78       	andi	r20, 0x80	; 128
     644:	1a 8e       	std	Y+26, r1	; 0x1a
     646:	fe 17       	cp	r31, r30
     648:	11 f0       	breq	.+4      	; 0x64e <__mulsf3+0x1d8>
     64a:	81 e0       	ldi	r24, 0x01	; 1
     64c:	8a 8f       	std	Y+26, r24	; 0x1a
     64e:	4d 8f       	std	Y+29, r20	; 0x1d
     650:	5e 8f       	std	Y+30, r21	; 0x1e
     652:	6f 8f       	std	Y+31, r22	; 0x1f
     654:	78 a3       	std	Y+32, r23	; 0x20
     656:	83 e0       	ldi	r24, 0x03	; 3
     658:	89 8f       	std	Y+25, r24	; 0x19
     65a:	ce 01       	movw	r24, r28
     65c:	49 96       	adiw	r24, 0x19	; 25
     65e:	0e 94 2d 05 	call	0xa5a	; 0xa5a <__pack_f>
     662:	a0 96       	adiw	r28, 0x20	; 32
     664:	e2 e1       	ldi	r30, 0x12	; 18
     666:	0c 94 1f 3e 	jmp	0x7c3e	; 0x7c3e <__epilogue_restores__>

0000066a <__divsf3>:
     66a:	a8 e1       	ldi	r26, 0x18	; 24
     66c:	b0 e0       	ldi	r27, 0x00	; 0
     66e:	eb e3       	ldi	r30, 0x3B	; 59
     670:	f3 e0       	ldi	r31, 0x03	; 3
     672:	0c 94 0b 3e 	jmp	0x7c16	; 0x7c16 <__prologue_saves__+0x10>
     676:	69 83       	std	Y+1, r22	; 0x01
     678:	7a 83       	std	Y+2, r23	; 0x02
     67a:	8b 83       	std	Y+3, r24	; 0x03
     67c:	9c 83       	std	Y+4, r25	; 0x04
     67e:	2d 83       	std	Y+5, r18	; 0x05
     680:	3e 83       	std	Y+6, r19	; 0x06
     682:	4f 83       	std	Y+7, r20	; 0x07
     684:	58 87       	std	Y+8, r21	; 0x08
     686:	b9 e0       	ldi	r27, 0x09	; 9
     688:	eb 2e       	mov	r14, r27
     68a:	f1 2c       	mov	r15, r1
     68c:	ec 0e       	add	r14, r28
     68e:	fd 1e       	adc	r15, r29
     690:	ce 01       	movw	r24, r28
     692:	01 96       	adiw	r24, 0x01	; 1
     694:	b7 01       	movw	r22, r14
     696:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     69a:	8e 01       	movw	r16, r28
     69c:	0f 5e       	subi	r16, 0xEF	; 239
     69e:	1f 4f       	sbci	r17, 0xFF	; 255
     6a0:	ce 01       	movw	r24, r28
     6a2:	05 96       	adiw	r24, 0x05	; 5
     6a4:	b8 01       	movw	r22, r16
     6a6:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     6aa:	29 85       	ldd	r18, Y+9	; 0x09
     6ac:	22 30       	cpi	r18, 0x02	; 2
     6ae:	08 f4       	brcc	.+2      	; 0x6b2 <__divsf3+0x48>
     6b0:	7e c0       	rjmp	.+252    	; 0x7ae <__divsf3+0x144>
     6b2:	39 89       	ldd	r19, Y+17	; 0x11
     6b4:	32 30       	cpi	r19, 0x02	; 2
     6b6:	10 f4       	brcc	.+4      	; 0x6bc <__divsf3+0x52>
     6b8:	b8 01       	movw	r22, r16
     6ba:	7c c0       	rjmp	.+248    	; 0x7b4 <__divsf3+0x14a>
     6bc:	8a 85       	ldd	r24, Y+10	; 0x0a
     6be:	9a 89       	ldd	r25, Y+18	; 0x12
     6c0:	89 27       	eor	r24, r25
     6c2:	8a 87       	std	Y+10, r24	; 0x0a
     6c4:	24 30       	cpi	r18, 0x04	; 4
     6c6:	11 f0       	breq	.+4      	; 0x6cc <__divsf3+0x62>
     6c8:	22 30       	cpi	r18, 0x02	; 2
     6ca:	31 f4       	brne	.+12     	; 0x6d8 <__divsf3+0x6e>
     6cc:	23 17       	cp	r18, r19
     6ce:	09 f0       	breq	.+2      	; 0x6d2 <__divsf3+0x68>
     6d0:	6e c0       	rjmp	.+220    	; 0x7ae <__divsf3+0x144>
     6d2:	68 e2       	ldi	r22, 0x28	; 40
     6d4:	71 e0       	ldi	r23, 0x01	; 1
     6d6:	6e c0       	rjmp	.+220    	; 0x7b4 <__divsf3+0x14a>
     6d8:	34 30       	cpi	r19, 0x04	; 4
     6da:	39 f4       	brne	.+14     	; 0x6ea <__divsf3+0x80>
     6dc:	1d 86       	std	Y+13, r1	; 0x0d
     6de:	1e 86       	std	Y+14, r1	; 0x0e
     6e0:	1f 86       	std	Y+15, r1	; 0x0f
     6e2:	18 8a       	std	Y+16, r1	; 0x10
     6e4:	1c 86       	std	Y+12, r1	; 0x0c
     6e6:	1b 86       	std	Y+11, r1	; 0x0b
     6e8:	04 c0       	rjmp	.+8      	; 0x6f2 <__divsf3+0x88>
     6ea:	32 30       	cpi	r19, 0x02	; 2
     6ec:	21 f4       	brne	.+8      	; 0x6f6 <__divsf3+0x8c>
     6ee:	84 e0       	ldi	r24, 0x04	; 4
     6f0:	89 87       	std	Y+9, r24	; 0x09
     6f2:	b7 01       	movw	r22, r14
     6f4:	5f c0       	rjmp	.+190    	; 0x7b4 <__divsf3+0x14a>
     6f6:	2b 85       	ldd	r18, Y+11	; 0x0b
     6f8:	3c 85       	ldd	r19, Y+12	; 0x0c
     6fa:	8b 89       	ldd	r24, Y+19	; 0x13
     6fc:	9c 89       	ldd	r25, Y+20	; 0x14
     6fe:	28 1b       	sub	r18, r24
     700:	39 0b       	sbc	r19, r25
     702:	3c 87       	std	Y+12, r19	; 0x0c
     704:	2b 87       	std	Y+11, r18	; 0x0b
     706:	ed 84       	ldd	r14, Y+13	; 0x0d
     708:	fe 84       	ldd	r15, Y+14	; 0x0e
     70a:	0f 85       	ldd	r16, Y+15	; 0x0f
     70c:	18 89       	ldd	r17, Y+16	; 0x10
     70e:	ad 88       	ldd	r10, Y+21	; 0x15
     710:	be 88       	ldd	r11, Y+22	; 0x16
     712:	cf 88       	ldd	r12, Y+23	; 0x17
     714:	d8 8c       	ldd	r13, Y+24	; 0x18
     716:	ea 14       	cp	r14, r10
     718:	fb 04       	cpc	r15, r11
     71a:	0c 05       	cpc	r16, r12
     71c:	1d 05       	cpc	r17, r13
     71e:	40 f4       	brcc	.+16     	; 0x730 <__divsf3+0xc6>
     720:	ee 0c       	add	r14, r14
     722:	ff 1c       	adc	r15, r15
     724:	00 1f       	adc	r16, r16
     726:	11 1f       	adc	r17, r17
     728:	21 50       	subi	r18, 0x01	; 1
     72a:	30 40       	sbci	r19, 0x00	; 0
     72c:	3c 87       	std	Y+12, r19	; 0x0c
     72e:	2b 87       	std	Y+11, r18	; 0x0b
     730:	20 e0       	ldi	r18, 0x00	; 0
     732:	30 e0       	ldi	r19, 0x00	; 0
     734:	40 e0       	ldi	r20, 0x00	; 0
     736:	50 e0       	ldi	r21, 0x00	; 0
     738:	80 e0       	ldi	r24, 0x00	; 0
     73a:	90 e0       	ldi	r25, 0x00	; 0
     73c:	a0 e0       	ldi	r26, 0x00	; 0
     73e:	b0 e4       	ldi	r27, 0x40	; 64
     740:	60 e0       	ldi	r22, 0x00	; 0
     742:	70 e0       	ldi	r23, 0x00	; 0
     744:	ea 14       	cp	r14, r10
     746:	fb 04       	cpc	r15, r11
     748:	0c 05       	cpc	r16, r12
     74a:	1d 05       	cpc	r17, r13
     74c:	40 f0       	brcs	.+16     	; 0x75e <__divsf3+0xf4>
     74e:	28 2b       	or	r18, r24
     750:	39 2b       	or	r19, r25
     752:	4a 2b       	or	r20, r26
     754:	5b 2b       	or	r21, r27
     756:	ea 18       	sub	r14, r10
     758:	fb 08       	sbc	r15, r11
     75a:	0c 09       	sbc	r16, r12
     75c:	1d 09       	sbc	r17, r13
     75e:	b6 95       	lsr	r27
     760:	a7 95       	ror	r26
     762:	97 95       	ror	r25
     764:	87 95       	ror	r24
     766:	ee 0c       	add	r14, r14
     768:	ff 1c       	adc	r15, r15
     76a:	00 1f       	adc	r16, r16
     76c:	11 1f       	adc	r17, r17
     76e:	6f 5f       	subi	r22, 0xFF	; 255
     770:	7f 4f       	sbci	r23, 0xFF	; 255
     772:	6f 31       	cpi	r22, 0x1F	; 31
     774:	71 05       	cpc	r23, r1
     776:	31 f7       	brne	.-52     	; 0x744 <__divsf3+0xda>
     778:	da 01       	movw	r26, r20
     77a:	c9 01       	movw	r24, r18
     77c:	8f 77       	andi	r24, 0x7F	; 127
     77e:	90 70       	andi	r25, 0x00	; 0
     780:	a0 70       	andi	r26, 0x00	; 0
     782:	b0 70       	andi	r27, 0x00	; 0
     784:	80 34       	cpi	r24, 0x40	; 64
     786:	91 05       	cpc	r25, r1
     788:	a1 05       	cpc	r26, r1
     78a:	b1 05       	cpc	r27, r1
     78c:	61 f4       	brne	.+24     	; 0x7a6 <__divsf3+0x13c>
     78e:	27 fd       	sbrc	r18, 7
     790:	0a c0       	rjmp	.+20     	; 0x7a6 <__divsf3+0x13c>
     792:	e1 14       	cp	r14, r1
     794:	f1 04       	cpc	r15, r1
     796:	01 05       	cpc	r16, r1
     798:	11 05       	cpc	r17, r1
     79a:	29 f0       	breq	.+10     	; 0x7a6 <__divsf3+0x13c>
     79c:	20 5c       	subi	r18, 0xC0	; 192
     79e:	3f 4f       	sbci	r19, 0xFF	; 255
     7a0:	4f 4f       	sbci	r20, 0xFF	; 255
     7a2:	5f 4f       	sbci	r21, 0xFF	; 255
     7a4:	20 78       	andi	r18, 0x80	; 128
     7a6:	2d 87       	std	Y+13, r18	; 0x0d
     7a8:	3e 87       	std	Y+14, r19	; 0x0e
     7aa:	4f 87       	std	Y+15, r20	; 0x0f
     7ac:	58 8b       	std	Y+16, r21	; 0x10
     7ae:	be 01       	movw	r22, r28
     7b0:	67 5f       	subi	r22, 0xF7	; 247
     7b2:	7f 4f       	sbci	r23, 0xFF	; 255
     7b4:	cb 01       	movw	r24, r22
     7b6:	0e 94 2d 05 	call	0xa5a	; 0xa5a <__pack_f>
     7ba:	68 96       	adiw	r28, 0x18	; 24
     7bc:	ea e0       	ldi	r30, 0x0A	; 10
     7be:	0c 94 27 3e 	jmp	0x7c4e	; 0x7c4e <__epilogue_restores__+0x10>

000007c2 <__gesf2>:
     7c2:	a8 e1       	ldi	r26, 0x18	; 24
     7c4:	b0 e0       	ldi	r27, 0x00	; 0
     7c6:	e7 ee       	ldi	r30, 0xE7	; 231
     7c8:	f3 e0       	ldi	r31, 0x03	; 3
     7ca:	0c 94 0f 3e 	jmp	0x7c1e	; 0x7c1e <__prologue_saves__+0x18>
     7ce:	69 83       	std	Y+1, r22	; 0x01
     7d0:	7a 83       	std	Y+2, r23	; 0x02
     7d2:	8b 83       	std	Y+3, r24	; 0x03
     7d4:	9c 83       	std	Y+4, r25	; 0x04
     7d6:	2d 83       	std	Y+5, r18	; 0x05
     7d8:	3e 83       	std	Y+6, r19	; 0x06
     7da:	4f 83       	std	Y+7, r20	; 0x07
     7dc:	58 87       	std	Y+8, r21	; 0x08
     7de:	89 e0       	ldi	r24, 0x09	; 9
     7e0:	e8 2e       	mov	r14, r24
     7e2:	f1 2c       	mov	r15, r1
     7e4:	ec 0e       	add	r14, r28
     7e6:	fd 1e       	adc	r15, r29
     7e8:	ce 01       	movw	r24, r28
     7ea:	01 96       	adiw	r24, 0x01	; 1
     7ec:	b7 01       	movw	r22, r14
     7ee:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     7f2:	8e 01       	movw	r16, r28
     7f4:	0f 5e       	subi	r16, 0xEF	; 239
     7f6:	1f 4f       	sbci	r17, 0xFF	; 255
     7f8:	ce 01       	movw	r24, r28
     7fa:	05 96       	adiw	r24, 0x05	; 5
     7fc:	b8 01       	movw	r22, r16
     7fe:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     802:	89 85       	ldd	r24, Y+9	; 0x09
     804:	82 30       	cpi	r24, 0x02	; 2
     806:	40 f0       	brcs	.+16     	; 0x818 <__gesf2+0x56>
     808:	89 89       	ldd	r24, Y+17	; 0x11
     80a:	82 30       	cpi	r24, 0x02	; 2
     80c:	28 f0       	brcs	.+10     	; 0x818 <__gesf2+0x56>
     80e:	c7 01       	movw	r24, r14
     810:	b8 01       	movw	r22, r16
     812:	0e 94 7a 06 	call	0xcf4	; 0xcf4 <__fpcmp_parts_f>
     816:	01 c0       	rjmp	.+2      	; 0x81a <__gesf2+0x58>
     818:	8f ef       	ldi	r24, 0xFF	; 255
     81a:	68 96       	adiw	r28, 0x18	; 24
     81c:	e6 e0       	ldi	r30, 0x06	; 6
     81e:	0c 94 2b 3e 	jmp	0x7c56	; 0x7c56 <__epilogue_restores__+0x18>

00000822 <__fixsfsi>:
     822:	ac e0       	ldi	r26, 0x0C	; 12
     824:	b0 e0       	ldi	r27, 0x00	; 0
     826:	e7 e1       	ldi	r30, 0x17	; 23
     828:	f4 e0       	ldi	r31, 0x04	; 4
     82a:	0c 94 13 3e 	jmp	0x7c26	; 0x7c26 <__prologue_saves__+0x20>
     82e:	69 83       	std	Y+1, r22	; 0x01
     830:	7a 83       	std	Y+2, r23	; 0x02
     832:	8b 83       	std	Y+3, r24	; 0x03
     834:	9c 83       	std	Y+4, r25	; 0x04
     836:	ce 01       	movw	r24, r28
     838:	01 96       	adiw	r24, 0x01	; 1
     83a:	be 01       	movw	r22, r28
     83c:	6b 5f       	subi	r22, 0xFB	; 251
     83e:	7f 4f       	sbci	r23, 0xFF	; 255
     840:	0e 94 02 06 	call	0xc04	; 0xc04 <__unpack_f>
     844:	8d 81       	ldd	r24, Y+5	; 0x05
     846:	82 30       	cpi	r24, 0x02	; 2
     848:	61 f1       	breq	.+88     	; 0x8a2 <__fixsfsi+0x80>
     84a:	82 30       	cpi	r24, 0x02	; 2
     84c:	50 f1       	brcs	.+84     	; 0x8a2 <__fixsfsi+0x80>
     84e:	84 30       	cpi	r24, 0x04	; 4
     850:	21 f4       	brne	.+8      	; 0x85a <__fixsfsi+0x38>
     852:	8e 81       	ldd	r24, Y+6	; 0x06
     854:	88 23       	and	r24, r24
     856:	51 f1       	breq	.+84     	; 0x8ac <__fixsfsi+0x8a>
     858:	2e c0       	rjmp	.+92     	; 0x8b6 <__fixsfsi+0x94>
     85a:	2f 81       	ldd	r18, Y+7	; 0x07
     85c:	38 85       	ldd	r19, Y+8	; 0x08
     85e:	37 fd       	sbrc	r19, 7
     860:	20 c0       	rjmp	.+64     	; 0x8a2 <__fixsfsi+0x80>
     862:	6e 81       	ldd	r22, Y+6	; 0x06
     864:	2f 31       	cpi	r18, 0x1F	; 31
     866:	31 05       	cpc	r19, r1
     868:	1c f0       	brlt	.+6      	; 0x870 <__fixsfsi+0x4e>
     86a:	66 23       	and	r22, r22
     86c:	f9 f0       	breq	.+62     	; 0x8ac <__fixsfsi+0x8a>
     86e:	23 c0       	rjmp	.+70     	; 0x8b6 <__fixsfsi+0x94>
     870:	8e e1       	ldi	r24, 0x1E	; 30
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	82 1b       	sub	r24, r18
     876:	93 0b       	sbc	r25, r19
     878:	29 85       	ldd	r18, Y+9	; 0x09
     87a:	3a 85       	ldd	r19, Y+10	; 0x0a
     87c:	4b 85       	ldd	r20, Y+11	; 0x0b
     87e:	5c 85       	ldd	r21, Y+12	; 0x0c
     880:	04 c0       	rjmp	.+8      	; 0x88a <__fixsfsi+0x68>
     882:	56 95       	lsr	r21
     884:	47 95       	ror	r20
     886:	37 95       	ror	r19
     888:	27 95       	ror	r18
     88a:	8a 95       	dec	r24
     88c:	d2 f7       	brpl	.-12     	; 0x882 <__fixsfsi+0x60>
     88e:	66 23       	and	r22, r22
     890:	b1 f0       	breq	.+44     	; 0x8be <__fixsfsi+0x9c>
     892:	50 95       	com	r21
     894:	40 95       	com	r20
     896:	30 95       	com	r19
     898:	21 95       	neg	r18
     89a:	3f 4f       	sbci	r19, 0xFF	; 255
     89c:	4f 4f       	sbci	r20, 0xFF	; 255
     89e:	5f 4f       	sbci	r21, 0xFF	; 255
     8a0:	0e c0       	rjmp	.+28     	; 0x8be <__fixsfsi+0x9c>
     8a2:	20 e0       	ldi	r18, 0x00	; 0
     8a4:	30 e0       	ldi	r19, 0x00	; 0
     8a6:	40 e0       	ldi	r20, 0x00	; 0
     8a8:	50 e0       	ldi	r21, 0x00	; 0
     8aa:	09 c0       	rjmp	.+18     	; 0x8be <__fixsfsi+0x9c>
     8ac:	2f ef       	ldi	r18, 0xFF	; 255
     8ae:	3f ef       	ldi	r19, 0xFF	; 255
     8b0:	4f ef       	ldi	r20, 0xFF	; 255
     8b2:	5f e7       	ldi	r21, 0x7F	; 127
     8b4:	04 c0       	rjmp	.+8      	; 0x8be <__fixsfsi+0x9c>
     8b6:	20 e0       	ldi	r18, 0x00	; 0
     8b8:	30 e0       	ldi	r19, 0x00	; 0
     8ba:	40 e0       	ldi	r20, 0x00	; 0
     8bc:	50 e8       	ldi	r21, 0x80	; 128
     8be:	b9 01       	movw	r22, r18
     8c0:	ca 01       	movw	r24, r20
     8c2:	2c 96       	adiw	r28, 0x0c	; 12
     8c4:	e2 e0       	ldi	r30, 0x02	; 2
     8c6:	0c 94 2f 3e 	jmp	0x7c5e	; 0x7c5e <__epilogue_restores__+0x20>

000008ca <__floatunsisf>:
     8ca:	a8 e0       	ldi	r26, 0x08	; 8
     8cc:	b0 e0       	ldi	r27, 0x00	; 0
     8ce:	eb e6       	ldi	r30, 0x6B	; 107
     8d0:	f4 e0       	ldi	r31, 0x04	; 4
     8d2:	0c 94 0b 3e 	jmp	0x7c16	; 0x7c16 <__prologue_saves__+0x10>
     8d6:	7b 01       	movw	r14, r22
     8d8:	8c 01       	movw	r16, r24
     8da:	61 15       	cp	r22, r1
     8dc:	71 05       	cpc	r23, r1
     8de:	81 05       	cpc	r24, r1
     8e0:	91 05       	cpc	r25, r1
     8e2:	19 f4       	brne	.+6      	; 0x8ea <__floatunsisf+0x20>
     8e4:	82 e0       	ldi	r24, 0x02	; 2
     8e6:	89 83       	std	Y+1, r24	; 0x01
     8e8:	60 c0       	rjmp	.+192    	; 0x9aa <__floatunsisf+0xe0>
     8ea:	83 e0       	ldi	r24, 0x03	; 3
     8ec:	89 83       	std	Y+1, r24	; 0x01
     8ee:	8e e1       	ldi	r24, 0x1E	; 30
     8f0:	c8 2e       	mov	r12, r24
     8f2:	d1 2c       	mov	r13, r1
     8f4:	dc 82       	std	Y+4, r13	; 0x04
     8f6:	cb 82       	std	Y+3, r12	; 0x03
     8f8:	ed 82       	std	Y+5, r14	; 0x05
     8fa:	fe 82       	std	Y+6, r15	; 0x06
     8fc:	0f 83       	std	Y+7, r16	; 0x07
     8fe:	18 87       	std	Y+8, r17	; 0x08
     900:	c8 01       	movw	r24, r16
     902:	b7 01       	movw	r22, r14
     904:	0e 94 de 04 	call	0x9bc	; 0x9bc <__clzsi2>
     908:	fc 01       	movw	r30, r24
     90a:	31 97       	sbiw	r30, 0x01	; 1
     90c:	f7 ff       	sbrs	r31, 7
     90e:	3b c0       	rjmp	.+118    	; 0x986 <__floatunsisf+0xbc>
     910:	22 27       	eor	r18, r18
     912:	33 27       	eor	r19, r19
     914:	2e 1b       	sub	r18, r30
     916:	3f 0b       	sbc	r19, r31
     918:	57 01       	movw	r10, r14
     91a:	68 01       	movw	r12, r16
     91c:	02 2e       	mov	r0, r18
     91e:	04 c0       	rjmp	.+8      	; 0x928 <__floatunsisf+0x5e>
     920:	d6 94       	lsr	r13
     922:	c7 94       	ror	r12
     924:	b7 94       	ror	r11
     926:	a7 94       	ror	r10
     928:	0a 94       	dec	r0
     92a:	d2 f7       	brpl	.-12     	; 0x920 <__floatunsisf+0x56>
     92c:	40 e0       	ldi	r20, 0x00	; 0
     92e:	50 e0       	ldi	r21, 0x00	; 0
     930:	60 e0       	ldi	r22, 0x00	; 0
     932:	70 e0       	ldi	r23, 0x00	; 0
     934:	81 e0       	ldi	r24, 0x01	; 1
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__floatunsisf+0x7c>
     93e:	88 0f       	add	r24, r24
     940:	99 1f       	adc	r25, r25
     942:	aa 1f       	adc	r26, r26
     944:	bb 1f       	adc	r27, r27
     946:	2a 95       	dec	r18
     948:	d2 f7       	brpl	.-12     	; 0x93e <__floatunsisf+0x74>
     94a:	01 97       	sbiw	r24, 0x01	; 1
     94c:	a1 09       	sbc	r26, r1
     94e:	b1 09       	sbc	r27, r1
     950:	8e 21       	and	r24, r14
     952:	9f 21       	and	r25, r15
     954:	a0 23       	and	r26, r16
     956:	b1 23       	and	r27, r17
     958:	00 97       	sbiw	r24, 0x00	; 0
     95a:	a1 05       	cpc	r26, r1
     95c:	b1 05       	cpc	r27, r1
     95e:	21 f0       	breq	.+8      	; 0x968 <__floatunsisf+0x9e>
     960:	41 e0       	ldi	r20, 0x01	; 1
     962:	50 e0       	ldi	r21, 0x00	; 0
     964:	60 e0       	ldi	r22, 0x00	; 0
     966:	70 e0       	ldi	r23, 0x00	; 0
     968:	4a 29       	or	r20, r10
     96a:	5b 29       	or	r21, r11
     96c:	6c 29       	or	r22, r12
     96e:	7d 29       	or	r23, r13
     970:	4d 83       	std	Y+5, r20	; 0x05
     972:	5e 83       	std	Y+6, r21	; 0x06
     974:	6f 83       	std	Y+7, r22	; 0x07
     976:	78 87       	std	Y+8, r23	; 0x08
     978:	8e e1       	ldi	r24, 0x1E	; 30
     97a:	90 e0       	ldi	r25, 0x00	; 0
     97c:	8e 1b       	sub	r24, r30
     97e:	9f 0b       	sbc	r25, r31
     980:	9c 83       	std	Y+4, r25	; 0x04
     982:	8b 83       	std	Y+3, r24	; 0x03
     984:	12 c0       	rjmp	.+36     	; 0x9aa <__floatunsisf+0xe0>
     986:	30 97       	sbiw	r30, 0x00	; 0
     988:	81 f0       	breq	.+32     	; 0x9aa <__floatunsisf+0xe0>
     98a:	0e 2e       	mov	r0, r30
     98c:	04 c0       	rjmp	.+8      	; 0x996 <__floatunsisf+0xcc>
     98e:	ee 0c       	add	r14, r14
     990:	ff 1c       	adc	r15, r15
     992:	00 1f       	adc	r16, r16
     994:	11 1f       	adc	r17, r17
     996:	0a 94       	dec	r0
     998:	d2 f7       	brpl	.-12     	; 0x98e <__floatunsisf+0xc4>
     99a:	ed 82       	std	Y+5, r14	; 0x05
     99c:	fe 82       	std	Y+6, r15	; 0x06
     99e:	0f 83       	std	Y+7, r16	; 0x07
     9a0:	18 87       	std	Y+8, r17	; 0x08
     9a2:	ce 1a       	sub	r12, r30
     9a4:	df 0a       	sbc	r13, r31
     9a6:	dc 82       	std	Y+4, r13	; 0x04
     9a8:	cb 82       	std	Y+3, r12	; 0x03
     9aa:	1a 82       	std	Y+2, r1	; 0x02
     9ac:	ce 01       	movw	r24, r28
     9ae:	01 96       	adiw	r24, 0x01	; 1
     9b0:	0e 94 2d 05 	call	0xa5a	; 0xa5a <__pack_f>
     9b4:	28 96       	adiw	r28, 0x08	; 8
     9b6:	ea e0       	ldi	r30, 0x0A	; 10
     9b8:	0c 94 27 3e 	jmp	0x7c4e	; 0x7c4e <__epilogue_restores__+0x10>

000009bc <__clzsi2>:
     9bc:	ef 92       	push	r14
     9be:	ff 92       	push	r15
     9c0:	0f 93       	push	r16
     9c2:	1f 93       	push	r17
     9c4:	7b 01       	movw	r14, r22
     9c6:	8c 01       	movw	r16, r24
     9c8:	80 e0       	ldi	r24, 0x00	; 0
     9ca:	e8 16       	cp	r14, r24
     9cc:	80 e0       	ldi	r24, 0x00	; 0
     9ce:	f8 06       	cpc	r15, r24
     9d0:	81 e0       	ldi	r24, 0x01	; 1
     9d2:	08 07       	cpc	r16, r24
     9d4:	80 e0       	ldi	r24, 0x00	; 0
     9d6:	18 07       	cpc	r17, r24
     9d8:	88 f4       	brcc	.+34     	; 0x9fc <__clzsi2+0x40>
     9da:	8f ef       	ldi	r24, 0xFF	; 255
     9dc:	e8 16       	cp	r14, r24
     9de:	f1 04       	cpc	r15, r1
     9e0:	01 05       	cpc	r16, r1
     9e2:	11 05       	cpc	r17, r1
     9e4:	31 f0       	breq	.+12     	; 0x9f2 <__clzsi2+0x36>
     9e6:	28 f0       	brcs	.+10     	; 0x9f2 <__clzsi2+0x36>
     9e8:	88 e0       	ldi	r24, 0x08	; 8
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	a0 e0       	ldi	r26, 0x00	; 0
     9ee:	b0 e0       	ldi	r27, 0x00	; 0
     9f0:	17 c0       	rjmp	.+46     	; 0xa20 <__clzsi2+0x64>
     9f2:	80 e0       	ldi	r24, 0x00	; 0
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	a0 e0       	ldi	r26, 0x00	; 0
     9f8:	b0 e0       	ldi	r27, 0x00	; 0
     9fa:	12 c0       	rjmp	.+36     	; 0xa20 <__clzsi2+0x64>
     9fc:	80 e0       	ldi	r24, 0x00	; 0
     9fe:	e8 16       	cp	r14, r24
     a00:	80 e0       	ldi	r24, 0x00	; 0
     a02:	f8 06       	cpc	r15, r24
     a04:	80 e0       	ldi	r24, 0x00	; 0
     a06:	08 07       	cpc	r16, r24
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	18 07       	cpc	r17, r24
     a0c:	28 f0       	brcs	.+10     	; 0xa18 <__clzsi2+0x5c>
     a0e:	88 e1       	ldi	r24, 0x18	; 24
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	a0 e0       	ldi	r26, 0x00	; 0
     a14:	b0 e0       	ldi	r27, 0x00	; 0
     a16:	04 c0       	rjmp	.+8      	; 0xa20 <__clzsi2+0x64>
     a18:	80 e1       	ldi	r24, 0x10	; 16
     a1a:	90 e0       	ldi	r25, 0x00	; 0
     a1c:	a0 e0       	ldi	r26, 0x00	; 0
     a1e:	b0 e0       	ldi	r27, 0x00	; 0
     a20:	20 e2       	ldi	r18, 0x20	; 32
     a22:	30 e0       	ldi	r19, 0x00	; 0
     a24:	40 e0       	ldi	r20, 0x00	; 0
     a26:	50 e0       	ldi	r21, 0x00	; 0
     a28:	28 1b       	sub	r18, r24
     a2a:	39 0b       	sbc	r19, r25
     a2c:	4a 0b       	sbc	r20, r26
     a2e:	5b 0b       	sbc	r21, r27
     a30:	04 c0       	rjmp	.+8      	; 0xa3a <__clzsi2+0x7e>
     a32:	16 95       	lsr	r17
     a34:	07 95       	ror	r16
     a36:	f7 94       	ror	r15
     a38:	e7 94       	ror	r14
     a3a:	8a 95       	dec	r24
     a3c:	d2 f7       	brpl	.-12     	; 0xa32 <__clzsi2+0x76>
     a3e:	f7 01       	movw	r30, r14
     a40:	e0 5d       	subi	r30, 0xD0	; 208
     a42:	fe 4f       	sbci	r31, 0xFE	; 254
     a44:	80 81       	ld	r24, Z
     a46:	28 1b       	sub	r18, r24
     a48:	31 09       	sbc	r19, r1
     a4a:	41 09       	sbc	r20, r1
     a4c:	51 09       	sbc	r21, r1
     a4e:	c9 01       	movw	r24, r18
     a50:	1f 91       	pop	r17
     a52:	0f 91       	pop	r16
     a54:	ff 90       	pop	r15
     a56:	ef 90       	pop	r14
     a58:	08 95       	ret

00000a5a <__pack_f>:
     a5a:	df 92       	push	r13
     a5c:	ef 92       	push	r14
     a5e:	ff 92       	push	r15
     a60:	0f 93       	push	r16
     a62:	1f 93       	push	r17
     a64:	fc 01       	movw	r30, r24
     a66:	e4 80       	ldd	r14, Z+4	; 0x04
     a68:	f5 80       	ldd	r15, Z+5	; 0x05
     a6a:	06 81       	ldd	r16, Z+6	; 0x06
     a6c:	17 81       	ldd	r17, Z+7	; 0x07
     a6e:	d1 80       	ldd	r13, Z+1	; 0x01
     a70:	80 81       	ld	r24, Z
     a72:	82 30       	cpi	r24, 0x02	; 2
     a74:	48 f4       	brcc	.+18     	; 0xa88 <__pack_f+0x2e>
     a76:	80 e0       	ldi	r24, 0x00	; 0
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	a0 e1       	ldi	r26, 0x10	; 16
     a7c:	b0 e0       	ldi	r27, 0x00	; 0
     a7e:	e8 2a       	or	r14, r24
     a80:	f9 2a       	or	r15, r25
     a82:	0a 2b       	or	r16, r26
     a84:	1b 2b       	or	r17, r27
     a86:	a5 c0       	rjmp	.+330    	; 0xbd2 <__pack_f+0x178>
     a88:	84 30       	cpi	r24, 0x04	; 4
     a8a:	09 f4       	brne	.+2      	; 0xa8e <__pack_f+0x34>
     a8c:	9f c0       	rjmp	.+318    	; 0xbcc <__pack_f+0x172>
     a8e:	82 30       	cpi	r24, 0x02	; 2
     a90:	21 f4       	brne	.+8      	; 0xa9a <__pack_f+0x40>
     a92:	ee 24       	eor	r14, r14
     a94:	ff 24       	eor	r15, r15
     a96:	87 01       	movw	r16, r14
     a98:	05 c0       	rjmp	.+10     	; 0xaa4 <__pack_f+0x4a>
     a9a:	e1 14       	cp	r14, r1
     a9c:	f1 04       	cpc	r15, r1
     a9e:	01 05       	cpc	r16, r1
     aa0:	11 05       	cpc	r17, r1
     aa2:	19 f4       	brne	.+6      	; 0xaaa <__pack_f+0x50>
     aa4:	e0 e0       	ldi	r30, 0x00	; 0
     aa6:	f0 e0       	ldi	r31, 0x00	; 0
     aa8:	96 c0       	rjmp	.+300    	; 0xbd6 <__pack_f+0x17c>
     aaa:	62 81       	ldd	r22, Z+2	; 0x02
     aac:	73 81       	ldd	r23, Z+3	; 0x03
     aae:	9f ef       	ldi	r25, 0xFF	; 255
     ab0:	62 38       	cpi	r22, 0x82	; 130
     ab2:	79 07       	cpc	r23, r25
     ab4:	0c f0       	brlt	.+2      	; 0xab8 <__pack_f+0x5e>
     ab6:	5b c0       	rjmp	.+182    	; 0xb6e <__pack_f+0x114>
     ab8:	22 e8       	ldi	r18, 0x82	; 130
     aba:	3f ef       	ldi	r19, 0xFF	; 255
     abc:	26 1b       	sub	r18, r22
     abe:	37 0b       	sbc	r19, r23
     ac0:	2a 31       	cpi	r18, 0x1A	; 26
     ac2:	31 05       	cpc	r19, r1
     ac4:	2c f0       	brlt	.+10     	; 0xad0 <__pack_f+0x76>
     ac6:	20 e0       	ldi	r18, 0x00	; 0
     ac8:	30 e0       	ldi	r19, 0x00	; 0
     aca:	40 e0       	ldi	r20, 0x00	; 0
     acc:	50 e0       	ldi	r21, 0x00	; 0
     ace:	2a c0       	rjmp	.+84     	; 0xb24 <__pack_f+0xca>
     ad0:	b8 01       	movw	r22, r16
     ad2:	a7 01       	movw	r20, r14
     ad4:	02 2e       	mov	r0, r18
     ad6:	04 c0       	rjmp	.+8      	; 0xae0 <__pack_f+0x86>
     ad8:	76 95       	lsr	r23
     ada:	67 95       	ror	r22
     adc:	57 95       	ror	r21
     ade:	47 95       	ror	r20
     ae0:	0a 94       	dec	r0
     ae2:	d2 f7       	brpl	.-12     	; 0xad8 <__pack_f+0x7e>
     ae4:	81 e0       	ldi	r24, 0x01	; 1
     ae6:	90 e0       	ldi	r25, 0x00	; 0
     ae8:	a0 e0       	ldi	r26, 0x00	; 0
     aea:	b0 e0       	ldi	r27, 0x00	; 0
     aec:	04 c0       	rjmp	.+8      	; 0xaf6 <__pack_f+0x9c>
     aee:	88 0f       	add	r24, r24
     af0:	99 1f       	adc	r25, r25
     af2:	aa 1f       	adc	r26, r26
     af4:	bb 1f       	adc	r27, r27
     af6:	2a 95       	dec	r18
     af8:	d2 f7       	brpl	.-12     	; 0xaee <__pack_f+0x94>
     afa:	01 97       	sbiw	r24, 0x01	; 1
     afc:	a1 09       	sbc	r26, r1
     afe:	b1 09       	sbc	r27, r1
     b00:	8e 21       	and	r24, r14
     b02:	9f 21       	and	r25, r15
     b04:	a0 23       	and	r26, r16
     b06:	b1 23       	and	r27, r17
     b08:	00 97       	sbiw	r24, 0x00	; 0
     b0a:	a1 05       	cpc	r26, r1
     b0c:	b1 05       	cpc	r27, r1
     b0e:	21 f0       	breq	.+8      	; 0xb18 <__pack_f+0xbe>
     b10:	81 e0       	ldi	r24, 0x01	; 1
     b12:	90 e0       	ldi	r25, 0x00	; 0
     b14:	a0 e0       	ldi	r26, 0x00	; 0
     b16:	b0 e0       	ldi	r27, 0x00	; 0
     b18:	9a 01       	movw	r18, r20
     b1a:	ab 01       	movw	r20, r22
     b1c:	28 2b       	or	r18, r24
     b1e:	39 2b       	or	r19, r25
     b20:	4a 2b       	or	r20, r26
     b22:	5b 2b       	or	r21, r27
     b24:	da 01       	movw	r26, r20
     b26:	c9 01       	movw	r24, r18
     b28:	8f 77       	andi	r24, 0x7F	; 127
     b2a:	90 70       	andi	r25, 0x00	; 0
     b2c:	a0 70       	andi	r26, 0x00	; 0
     b2e:	b0 70       	andi	r27, 0x00	; 0
     b30:	80 34       	cpi	r24, 0x40	; 64
     b32:	91 05       	cpc	r25, r1
     b34:	a1 05       	cpc	r26, r1
     b36:	b1 05       	cpc	r27, r1
     b38:	39 f4       	brne	.+14     	; 0xb48 <__pack_f+0xee>
     b3a:	27 ff       	sbrs	r18, 7
     b3c:	09 c0       	rjmp	.+18     	; 0xb50 <__pack_f+0xf6>
     b3e:	20 5c       	subi	r18, 0xC0	; 192
     b40:	3f 4f       	sbci	r19, 0xFF	; 255
     b42:	4f 4f       	sbci	r20, 0xFF	; 255
     b44:	5f 4f       	sbci	r21, 0xFF	; 255
     b46:	04 c0       	rjmp	.+8      	; 0xb50 <__pack_f+0xf6>
     b48:	21 5c       	subi	r18, 0xC1	; 193
     b4a:	3f 4f       	sbci	r19, 0xFF	; 255
     b4c:	4f 4f       	sbci	r20, 0xFF	; 255
     b4e:	5f 4f       	sbci	r21, 0xFF	; 255
     b50:	e0 e0       	ldi	r30, 0x00	; 0
     b52:	f0 e0       	ldi	r31, 0x00	; 0
     b54:	20 30       	cpi	r18, 0x00	; 0
     b56:	a0 e0       	ldi	r26, 0x00	; 0
     b58:	3a 07       	cpc	r19, r26
     b5a:	a0 e0       	ldi	r26, 0x00	; 0
     b5c:	4a 07       	cpc	r20, r26
     b5e:	a0 e4       	ldi	r26, 0x40	; 64
     b60:	5a 07       	cpc	r21, r26
     b62:	10 f0       	brcs	.+4      	; 0xb68 <__pack_f+0x10e>
     b64:	e1 e0       	ldi	r30, 0x01	; 1
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	79 01       	movw	r14, r18
     b6a:	8a 01       	movw	r16, r20
     b6c:	27 c0       	rjmp	.+78     	; 0xbbc <__pack_f+0x162>
     b6e:	60 38       	cpi	r22, 0x80	; 128
     b70:	71 05       	cpc	r23, r1
     b72:	64 f5       	brge	.+88     	; 0xbcc <__pack_f+0x172>
     b74:	fb 01       	movw	r30, r22
     b76:	e1 58       	subi	r30, 0x81	; 129
     b78:	ff 4f       	sbci	r31, 0xFF	; 255
     b7a:	d8 01       	movw	r26, r16
     b7c:	c7 01       	movw	r24, r14
     b7e:	8f 77       	andi	r24, 0x7F	; 127
     b80:	90 70       	andi	r25, 0x00	; 0
     b82:	a0 70       	andi	r26, 0x00	; 0
     b84:	b0 70       	andi	r27, 0x00	; 0
     b86:	80 34       	cpi	r24, 0x40	; 64
     b88:	91 05       	cpc	r25, r1
     b8a:	a1 05       	cpc	r26, r1
     b8c:	b1 05       	cpc	r27, r1
     b8e:	39 f4       	brne	.+14     	; 0xb9e <__pack_f+0x144>
     b90:	e7 fe       	sbrs	r14, 7
     b92:	0d c0       	rjmp	.+26     	; 0xbae <__pack_f+0x154>
     b94:	80 e4       	ldi	r24, 0x40	; 64
     b96:	90 e0       	ldi	r25, 0x00	; 0
     b98:	a0 e0       	ldi	r26, 0x00	; 0
     b9a:	b0 e0       	ldi	r27, 0x00	; 0
     b9c:	04 c0       	rjmp	.+8      	; 0xba6 <__pack_f+0x14c>
     b9e:	8f e3       	ldi	r24, 0x3F	; 63
     ba0:	90 e0       	ldi	r25, 0x00	; 0
     ba2:	a0 e0       	ldi	r26, 0x00	; 0
     ba4:	b0 e0       	ldi	r27, 0x00	; 0
     ba6:	e8 0e       	add	r14, r24
     ba8:	f9 1e       	adc	r15, r25
     baa:	0a 1f       	adc	r16, r26
     bac:	1b 1f       	adc	r17, r27
     bae:	17 ff       	sbrs	r17, 7
     bb0:	05 c0       	rjmp	.+10     	; 0xbbc <__pack_f+0x162>
     bb2:	16 95       	lsr	r17
     bb4:	07 95       	ror	r16
     bb6:	f7 94       	ror	r15
     bb8:	e7 94       	ror	r14
     bba:	31 96       	adiw	r30, 0x01	; 1
     bbc:	87 e0       	ldi	r24, 0x07	; 7
     bbe:	16 95       	lsr	r17
     bc0:	07 95       	ror	r16
     bc2:	f7 94       	ror	r15
     bc4:	e7 94       	ror	r14
     bc6:	8a 95       	dec	r24
     bc8:	d1 f7       	brne	.-12     	; 0xbbe <__pack_f+0x164>
     bca:	05 c0       	rjmp	.+10     	; 0xbd6 <__pack_f+0x17c>
     bcc:	ee 24       	eor	r14, r14
     bce:	ff 24       	eor	r15, r15
     bd0:	87 01       	movw	r16, r14
     bd2:	ef ef       	ldi	r30, 0xFF	; 255
     bd4:	f0 e0       	ldi	r31, 0x00	; 0
     bd6:	6e 2f       	mov	r22, r30
     bd8:	67 95       	ror	r22
     bda:	66 27       	eor	r22, r22
     bdc:	67 95       	ror	r22
     bde:	90 2f       	mov	r25, r16
     be0:	9f 77       	andi	r25, 0x7F	; 127
     be2:	d7 94       	ror	r13
     be4:	dd 24       	eor	r13, r13
     be6:	d7 94       	ror	r13
     be8:	8e 2f       	mov	r24, r30
     bea:	86 95       	lsr	r24
     bec:	49 2f       	mov	r20, r25
     bee:	46 2b       	or	r20, r22
     bf0:	58 2f       	mov	r21, r24
     bf2:	5d 29       	or	r21, r13
     bf4:	b7 01       	movw	r22, r14
     bf6:	ca 01       	movw	r24, r20
     bf8:	1f 91       	pop	r17
     bfa:	0f 91       	pop	r16
     bfc:	ff 90       	pop	r15
     bfe:	ef 90       	pop	r14
     c00:	df 90       	pop	r13
     c02:	08 95       	ret

00000c04 <__unpack_f>:
     c04:	fc 01       	movw	r30, r24
     c06:	db 01       	movw	r26, r22
     c08:	40 81       	ld	r20, Z
     c0a:	51 81       	ldd	r21, Z+1	; 0x01
     c0c:	22 81       	ldd	r18, Z+2	; 0x02
     c0e:	62 2f       	mov	r22, r18
     c10:	6f 77       	andi	r22, 0x7F	; 127
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	22 1f       	adc	r18, r18
     c16:	22 27       	eor	r18, r18
     c18:	22 1f       	adc	r18, r18
     c1a:	93 81       	ldd	r25, Z+3	; 0x03
     c1c:	89 2f       	mov	r24, r25
     c1e:	88 0f       	add	r24, r24
     c20:	82 2b       	or	r24, r18
     c22:	28 2f       	mov	r18, r24
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	99 1f       	adc	r25, r25
     c28:	99 27       	eor	r25, r25
     c2a:	99 1f       	adc	r25, r25
     c2c:	11 96       	adiw	r26, 0x01	; 1
     c2e:	9c 93       	st	X, r25
     c30:	11 97       	sbiw	r26, 0x01	; 1
     c32:	21 15       	cp	r18, r1
     c34:	31 05       	cpc	r19, r1
     c36:	a9 f5       	brne	.+106    	; 0xca2 <__unpack_f+0x9e>
     c38:	41 15       	cp	r20, r1
     c3a:	51 05       	cpc	r21, r1
     c3c:	61 05       	cpc	r22, r1
     c3e:	71 05       	cpc	r23, r1
     c40:	11 f4       	brne	.+4      	; 0xc46 <__unpack_f+0x42>
     c42:	82 e0       	ldi	r24, 0x02	; 2
     c44:	37 c0       	rjmp	.+110    	; 0xcb4 <__unpack_f+0xb0>
     c46:	82 e8       	ldi	r24, 0x82	; 130
     c48:	9f ef       	ldi	r25, 0xFF	; 255
     c4a:	13 96       	adiw	r26, 0x03	; 3
     c4c:	9c 93       	st	X, r25
     c4e:	8e 93       	st	-X, r24
     c50:	12 97       	sbiw	r26, 0x02	; 2
     c52:	9a 01       	movw	r18, r20
     c54:	ab 01       	movw	r20, r22
     c56:	67 e0       	ldi	r22, 0x07	; 7
     c58:	22 0f       	add	r18, r18
     c5a:	33 1f       	adc	r19, r19
     c5c:	44 1f       	adc	r20, r20
     c5e:	55 1f       	adc	r21, r21
     c60:	6a 95       	dec	r22
     c62:	d1 f7       	brne	.-12     	; 0xc58 <__unpack_f+0x54>
     c64:	83 e0       	ldi	r24, 0x03	; 3
     c66:	8c 93       	st	X, r24
     c68:	0d c0       	rjmp	.+26     	; 0xc84 <__unpack_f+0x80>
     c6a:	22 0f       	add	r18, r18
     c6c:	33 1f       	adc	r19, r19
     c6e:	44 1f       	adc	r20, r20
     c70:	55 1f       	adc	r21, r21
     c72:	12 96       	adiw	r26, 0x02	; 2
     c74:	8d 91       	ld	r24, X+
     c76:	9c 91       	ld	r25, X
     c78:	13 97       	sbiw	r26, 0x03	; 3
     c7a:	01 97       	sbiw	r24, 0x01	; 1
     c7c:	13 96       	adiw	r26, 0x03	; 3
     c7e:	9c 93       	st	X, r25
     c80:	8e 93       	st	-X, r24
     c82:	12 97       	sbiw	r26, 0x02	; 2
     c84:	20 30       	cpi	r18, 0x00	; 0
     c86:	80 e0       	ldi	r24, 0x00	; 0
     c88:	38 07       	cpc	r19, r24
     c8a:	80 e0       	ldi	r24, 0x00	; 0
     c8c:	48 07       	cpc	r20, r24
     c8e:	80 e4       	ldi	r24, 0x40	; 64
     c90:	58 07       	cpc	r21, r24
     c92:	58 f3       	brcs	.-42     	; 0xc6a <__unpack_f+0x66>
     c94:	14 96       	adiw	r26, 0x04	; 4
     c96:	2d 93       	st	X+, r18
     c98:	3d 93       	st	X+, r19
     c9a:	4d 93       	st	X+, r20
     c9c:	5c 93       	st	X, r21
     c9e:	17 97       	sbiw	r26, 0x07	; 7
     ca0:	08 95       	ret
     ca2:	2f 3f       	cpi	r18, 0xFF	; 255
     ca4:	31 05       	cpc	r19, r1
     ca6:	79 f4       	brne	.+30     	; 0xcc6 <__unpack_f+0xc2>
     ca8:	41 15       	cp	r20, r1
     caa:	51 05       	cpc	r21, r1
     cac:	61 05       	cpc	r22, r1
     cae:	71 05       	cpc	r23, r1
     cb0:	19 f4       	brne	.+6      	; 0xcb8 <__unpack_f+0xb4>
     cb2:	84 e0       	ldi	r24, 0x04	; 4
     cb4:	8c 93       	st	X, r24
     cb6:	08 95       	ret
     cb8:	64 ff       	sbrs	r22, 4
     cba:	03 c0       	rjmp	.+6      	; 0xcc2 <__unpack_f+0xbe>
     cbc:	81 e0       	ldi	r24, 0x01	; 1
     cbe:	8c 93       	st	X, r24
     cc0:	12 c0       	rjmp	.+36     	; 0xce6 <__unpack_f+0xe2>
     cc2:	1c 92       	st	X, r1
     cc4:	10 c0       	rjmp	.+32     	; 0xce6 <__unpack_f+0xe2>
     cc6:	2f 57       	subi	r18, 0x7F	; 127
     cc8:	30 40       	sbci	r19, 0x00	; 0
     cca:	13 96       	adiw	r26, 0x03	; 3
     ccc:	3c 93       	st	X, r19
     cce:	2e 93       	st	-X, r18
     cd0:	12 97       	sbiw	r26, 0x02	; 2
     cd2:	83 e0       	ldi	r24, 0x03	; 3
     cd4:	8c 93       	st	X, r24
     cd6:	87 e0       	ldi	r24, 0x07	; 7
     cd8:	44 0f       	add	r20, r20
     cda:	55 1f       	adc	r21, r21
     cdc:	66 1f       	adc	r22, r22
     cde:	77 1f       	adc	r23, r23
     ce0:	8a 95       	dec	r24
     ce2:	d1 f7       	brne	.-12     	; 0xcd8 <__unpack_f+0xd4>
     ce4:	70 64       	ori	r23, 0x40	; 64
     ce6:	14 96       	adiw	r26, 0x04	; 4
     ce8:	4d 93       	st	X+, r20
     cea:	5d 93       	st	X+, r21
     cec:	6d 93       	st	X+, r22
     cee:	7c 93       	st	X, r23
     cf0:	17 97       	sbiw	r26, 0x07	; 7
     cf2:	08 95       	ret

00000cf4 <__fpcmp_parts_f>:
     cf4:	1f 93       	push	r17
     cf6:	dc 01       	movw	r26, r24
     cf8:	fb 01       	movw	r30, r22
     cfa:	9c 91       	ld	r25, X
     cfc:	92 30       	cpi	r25, 0x02	; 2
     cfe:	08 f4       	brcc	.+2      	; 0xd02 <__fpcmp_parts_f+0xe>
     d00:	47 c0       	rjmp	.+142    	; 0xd90 <__fpcmp_parts_f+0x9c>
     d02:	80 81       	ld	r24, Z
     d04:	82 30       	cpi	r24, 0x02	; 2
     d06:	08 f4       	brcc	.+2      	; 0xd0a <__fpcmp_parts_f+0x16>
     d08:	43 c0       	rjmp	.+134    	; 0xd90 <__fpcmp_parts_f+0x9c>
     d0a:	94 30       	cpi	r25, 0x04	; 4
     d0c:	51 f4       	brne	.+20     	; 0xd22 <__fpcmp_parts_f+0x2e>
     d0e:	11 96       	adiw	r26, 0x01	; 1
     d10:	1c 91       	ld	r17, X
     d12:	84 30       	cpi	r24, 0x04	; 4
     d14:	99 f5       	brne	.+102    	; 0xd7c <__fpcmp_parts_f+0x88>
     d16:	81 81       	ldd	r24, Z+1	; 0x01
     d18:	68 2f       	mov	r22, r24
     d1a:	70 e0       	ldi	r23, 0x00	; 0
     d1c:	61 1b       	sub	r22, r17
     d1e:	71 09       	sbc	r23, r1
     d20:	3f c0       	rjmp	.+126    	; 0xda0 <__fpcmp_parts_f+0xac>
     d22:	84 30       	cpi	r24, 0x04	; 4
     d24:	21 f0       	breq	.+8      	; 0xd2e <__fpcmp_parts_f+0x3a>
     d26:	92 30       	cpi	r25, 0x02	; 2
     d28:	31 f4       	brne	.+12     	; 0xd36 <__fpcmp_parts_f+0x42>
     d2a:	82 30       	cpi	r24, 0x02	; 2
     d2c:	b9 f1       	breq	.+110    	; 0xd9c <__fpcmp_parts_f+0xa8>
     d2e:	81 81       	ldd	r24, Z+1	; 0x01
     d30:	88 23       	and	r24, r24
     d32:	89 f1       	breq	.+98     	; 0xd96 <__fpcmp_parts_f+0xa2>
     d34:	2d c0       	rjmp	.+90     	; 0xd90 <__fpcmp_parts_f+0x9c>
     d36:	11 96       	adiw	r26, 0x01	; 1
     d38:	1c 91       	ld	r17, X
     d3a:	11 97       	sbiw	r26, 0x01	; 1
     d3c:	82 30       	cpi	r24, 0x02	; 2
     d3e:	f1 f0       	breq	.+60     	; 0xd7c <__fpcmp_parts_f+0x88>
     d40:	81 81       	ldd	r24, Z+1	; 0x01
     d42:	18 17       	cp	r17, r24
     d44:	d9 f4       	brne	.+54     	; 0xd7c <__fpcmp_parts_f+0x88>
     d46:	12 96       	adiw	r26, 0x02	; 2
     d48:	2d 91       	ld	r18, X+
     d4a:	3c 91       	ld	r19, X
     d4c:	13 97       	sbiw	r26, 0x03	; 3
     d4e:	82 81       	ldd	r24, Z+2	; 0x02
     d50:	93 81       	ldd	r25, Z+3	; 0x03
     d52:	82 17       	cp	r24, r18
     d54:	93 07       	cpc	r25, r19
     d56:	94 f0       	brlt	.+36     	; 0xd7c <__fpcmp_parts_f+0x88>
     d58:	28 17       	cp	r18, r24
     d5a:	39 07       	cpc	r19, r25
     d5c:	bc f0       	brlt	.+46     	; 0xd8c <__fpcmp_parts_f+0x98>
     d5e:	14 96       	adiw	r26, 0x04	; 4
     d60:	8d 91       	ld	r24, X+
     d62:	9d 91       	ld	r25, X+
     d64:	0d 90       	ld	r0, X+
     d66:	bc 91       	ld	r27, X
     d68:	a0 2d       	mov	r26, r0
     d6a:	24 81       	ldd	r18, Z+4	; 0x04
     d6c:	35 81       	ldd	r19, Z+5	; 0x05
     d6e:	46 81       	ldd	r20, Z+6	; 0x06
     d70:	57 81       	ldd	r21, Z+7	; 0x07
     d72:	28 17       	cp	r18, r24
     d74:	39 07       	cpc	r19, r25
     d76:	4a 07       	cpc	r20, r26
     d78:	5b 07       	cpc	r21, r27
     d7a:	18 f4       	brcc	.+6      	; 0xd82 <__fpcmp_parts_f+0x8e>
     d7c:	11 23       	and	r17, r17
     d7e:	41 f0       	breq	.+16     	; 0xd90 <__fpcmp_parts_f+0x9c>
     d80:	0a c0       	rjmp	.+20     	; 0xd96 <__fpcmp_parts_f+0xa2>
     d82:	82 17       	cp	r24, r18
     d84:	93 07       	cpc	r25, r19
     d86:	a4 07       	cpc	r26, r20
     d88:	b5 07       	cpc	r27, r21
     d8a:	40 f4       	brcc	.+16     	; 0xd9c <__fpcmp_parts_f+0xa8>
     d8c:	11 23       	and	r17, r17
     d8e:	19 f0       	breq	.+6      	; 0xd96 <__fpcmp_parts_f+0xa2>
     d90:	61 e0       	ldi	r22, 0x01	; 1
     d92:	70 e0       	ldi	r23, 0x00	; 0
     d94:	05 c0       	rjmp	.+10     	; 0xda0 <__fpcmp_parts_f+0xac>
     d96:	6f ef       	ldi	r22, 0xFF	; 255
     d98:	7f ef       	ldi	r23, 0xFF	; 255
     d9a:	02 c0       	rjmp	.+4      	; 0xda0 <__fpcmp_parts_f+0xac>
     d9c:	60 e0       	ldi	r22, 0x00	; 0
     d9e:	70 e0       	ldi	r23, 0x00	; 0
     da0:	cb 01       	movw	r24, r22
     da2:	1f 91       	pop	r17
     da4:	08 95       	ret

00000da6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     da6:	df 93       	push	r29
     da8:	cf 93       	push	r28
     daa:	00 d0       	rcall	.+0      	; 0xdac <pvPortMalloc+0x6>
     dac:	00 d0       	rcall	.+0      	; 0xdae <pvPortMalloc+0x8>
     dae:	cd b7       	in	r28, 0x3d	; 61
     db0:	de b7       	in	r29, 0x3e	; 62
     db2:	9c 83       	std	Y+4, r25	; 0x04
     db4:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
     db6:	1a 82       	std	Y+2, r1	; 0x02
     db8:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
     dba:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
     dbe:	80 91 48 02 	lds	r24, 0x0248
     dc2:	90 91 49 02 	lds	r25, 0x0249
     dc6:	00 97       	sbiw	r24, 0x00	; 0
     dc8:	31 f4       	brne	.+12     	; 0xdd6 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     dca:	8a e4       	ldi	r24, 0x4A	; 74
     dcc:	92 e0       	ldi	r25, 0x02	; 2
     dce:	90 93 49 02 	sts	0x0249, r25
     dd2:	80 93 48 02 	sts	0x0248, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
     dd6:	8b 81       	ldd	r24, Y+3	; 0x03
     dd8:	9c 81       	ldd	r25, Y+4	; 0x04
     dda:	00 97       	sbiw	r24, 0x00	; 0
     ddc:	99 f1       	breq	.+102    	; 0xe44 <pvPortMalloc+0x9e>
     dde:	80 91 46 02 	lds	r24, 0x0246
     de2:	90 91 47 02 	lds	r25, 0x0247
     de6:	2b 81       	ldd	r18, Y+3	; 0x03
     de8:	3c 81       	ldd	r19, Y+4	; 0x04
     dea:	82 0f       	add	r24, r18
     dec:	93 1f       	adc	r25, r19
     dee:	25 e0       	ldi	r18, 0x05	; 5
     df0:	8b 3d       	cpi	r24, 0xDB	; 219
     df2:	92 07       	cpc	r25, r18
     df4:	38 f5       	brcc	.+78     	; 0xe44 <pvPortMalloc+0x9e>
     df6:	20 91 46 02 	lds	r18, 0x0246
     dfa:	30 91 47 02 	lds	r19, 0x0247
     dfe:	8b 81       	ldd	r24, Y+3	; 0x03
     e00:	9c 81       	ldd	r25, Y+4	; 0x04
     e02:	28 0f       	add	r18, r24
     e04:	39 1f       	adc	r19, r25
     e06:	80 91 46 02 	lds	r24, 0x0246
     e0a:	90 91 47 02 	lds	r25, 0x0247
     e0e:	82 17       	cp	r24, r18
     e10:	93 07       	cpc	r25, r19
     e12:	c0 f4       	brcc	.+48     	; 0xe44 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     e14:	20 91 48 02 	lds	r18, 0x0248
     e18:	30 91 49 02 	lds	r19, 0x0249
     e1c:	80 91 46 02 	lds	r24, 0x0246
     e20:	90 91 47 02 	lds	r25, 0x0247
     e24:	82 0f       	add	r24, r18
     e26:	93 1f       	adc	r25, r19
     e28:	9a 83       	std	Y+2, r25	; 0x02
     e2a:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     e2c:	20 91 46 02 	lds	r18, 0x0246
     e30:	30 91 47 02 	lds	r19, 0x0247
     e34:	8b 81       	ldd	r24, Y+3	; 0x03
     e36:	9c 81       	ldd	r25, Y+4	; 0x04
     e38:	82 0f       	add	r24, r18
     e3a:	93 1f       	adc	r25, r19
     e3c:	90 93 47 02 	sts	0x0247, r25
     e40:	80 93 46 02 	sts	0x0246, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     e44:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     e48:	89 81       	ldd	r24, Y+1	; 0x01
     e4a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     e4c:	0f 90       	pop	r0
     e4e:	0f 90       	pop	r0
     e50:	0f 90       	pop	r0
     e52:	0f 90       	pop	r0
     e54:	cf 91       	pop	r28
     e56:	df 91       	pop	r29
     e58:	08 95       	ret

00000e5a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     e5a:	df 93       	push	r29
     e5c:	cf 93       	push	r28
     e5e:	00 d0       	rcall	.+0      	; 0xe60 <vPortFree+0x6>
     e60:	cd b7       	in	r28, 0x3d	; 61
     e62:	de b7       	in	r29, 0x3e	; 62
     e64:	9a 83       	std	Y+2, r25	; 0x02
     e66:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     e68:	0f 90       	pop	r0
     e6a:	0f 90       	pop	r0
     e6c:	cf 91       	pop	r28
     e6e:	df 91       	pop	r29
     e70:	08 95       	ret

00000e72 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     e72:	df 93       	push	r29
     e74:	cf 93       	push	r28
     e76:	cd b7       	in	r28, 0x3d	; 61
     e78:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     e7a:	10 92 47 02 	sts	0x0247, r1
     e7e:	10 92 46 02 	sts	0x0246, r1
}
     e82:	cf 91       	pop	r28
     e84:	df 91       	pop	r29
     e86:	08 95       	ret

00000e88 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     e88:	df 93       	push	r29
     e8a:	cf 93       	push	r28
     e8c:	cd b7       	in	r28, 0x3d	; 61
     e8e:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     e90:	20 91 46 02 	lds	r18, 0x0246
     e94:	30 91 47 02 	lds	r19, 0x0247
     e98:	8b ed       	ldi	r24, 0xDB	; 219
     e9a:	95 e0       	ldi	r25, 0x05	; 5
     e9c:	82 1b       	sub	r24, r18
     e9e:	93 0b       	sbc	r25, r19
}
     ea0:	cf 91       	pop	r28
     ea2:	df 91       	pop	r29
     ea4:	08 95       	ret

00000ea6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     ea6:	df 93       	push	r29
     ea8:	cf 93       	push	r28
     eaa:	cd b7       	in	r28, 0x3d	; 61
     eac:	de b7       	in	r29, 0x3e	; 62
     eae:	28 97       	sbiw	r28, 0x08	; 8
     eb0:	0f b6       	in	r0, 0x3f	; 63
     eb2:	f8 94       	cli
     eb4:	de bf       	out	0x3e, r29	; 62
     eb6:	0f be       	out	0x3f, r0	; 63
     eb8:	cd bf       	out	0x3d, r28	; 61
     eba:	9c 83       	std	Y+4, r25	; 0x04
     ebc:	8b 83       	std	Y+3, r24	; 0x03
     ebe:	7e 83       	std	Y+6, r23	; 0x06
     ec0:	6d 83       	std	Y+5, r22	; 0x05
     ec2:	58 87       	std	Y+8, r21	; 0x08
     ec4:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     ec6:	eb 81       	ldd	r30, Y+3	; 0x03
     ec8:	fc 81       	ldd	r31, Y+4	; 0x04
     eca:	81 e1       	ldi	r24, 0x11	; 17
     ecc:	80 83       	st	Z, r24
	pxTopOfStack--;
     ece:	8b 81       	ldd	r24, Y+3	; 0x03
     ed0:	9c 81       	ldd	r25, Y+4	; 0x04
     ed2:	01 97       	sbiw	r24, 0x01	; 1
     ed4:	9c 83       	std	Y+4, r25	; 0x04
     ed6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     ed8:	eb 81       	ldd	r30, Y+3	; 0x03
     eda:	fc 81       	ldd	r31, Y+4	; 0x04
     edc:	82 e2       	ldi	r24, 0x22	; 34
     ede:	80 83       	st	Z, r24
	pxTopOfStack--;
     ee0:	8b 81       	ldd	r24, Y+3	; 0x03
     ee2:	9c 81       	ldd	r25, Y+4	; 0x04
     ee4:	01 97       	sbiw	r24, 0x01	; 1
     ee6:	9c 83       	std	Y+4, r25	; 0x04
     ee8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     eea:	eb 81       	ldd	r30, Y+3	; 0x03
     eec:	fc 81       	ldd	r31, Y+4	; 0x04
     eee:	83 e3       	ldi	r24, 0x33	; 51
     ef0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ef2:	8b 81       	ldd	r24, Y+3	; 0x03
     ef4:	9c 81       	ldd	r25, Y+4	; 0x04
     ef6:	01 97       	sbiw	r24, 0x01	; 1
     ef8:	9c 83       	std	Y+4, r25	; 0x04
     efa:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     efc:	8d 81       	ldd	r24, Y+5	; 0x05
     efe:	9e 81       	ldd	r25, Y+6	; 0x06
     f00:	9a 83       	std	Y+2, r25	; 0x02
     f02:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     f04:	89 81       	ldd	r24, Y+1	; 0x01
     f06:	eb 81       	ldd	r30, Y+3	; 0x03
     f08:	fc 81       	ldd	r31, Y+4	; 0x04
     f0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     f0c:	8b 81       	ldd	r24, Y+3	; 0x03
     f0e:	9c 81       	ldd	r25, Y+4	; 0x04
     f10:	01 97       	sbiw	r24, 0x01	; 1
     f12:	9c 83       	std	Y+4, r25	; 0x04
     f14:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     f16:	89 81       	ldd	r24, Y+1	; 0x01
     f18:	9a 81       	ldd	r25, Y+2	; 0x02
     f1a:	89 2f       	mov	r24, r25
     f1c:	99 27       	eor	r25, r25
     f1e:	9a 83       	std	Y+2, r25	; 0x02
     f20:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     f22:	89 81       	ldd	r24, Y+1	; 0x01
     f24:	eb 81       	ldd	r30, Y+3	; 0x03
     f26:	fc 81       	ldd	r31, Y+4	; 0x04
     f28:	80 83       	st	Z, r24
	pxTopOfStack--;
     f2a:	8b 81       	ldd	r24, Y+3	; 0x03
     f2c:	9c 81       	ldd	r25, Y+4	; 0x04
     f2e:	01 97       	sbiw	r24, 0x01	; 1
     f30:	9c 83       	std	Y+4, r25	; 0x04
     f32:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     f34:	eb 81       	ldd	r30, Y+3	; 0x03
     f36:	fc 81       	ldd	r31, Y+4	; 0x04
     f38:	10 82       	st	Z, r1
	pxTopOfStack--;
     f3a:	8b 81       	ldd	r24, Y+3	; 0x03
     f3c:	9c 81       	ldd	r25, Y+4	; 0x04
     f3e:	01 97       	sbiw	r24, 0x01	; 1
     f40:	9c 83       	std	Y+4, r25	; 0x04
     f42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     f44:	eb 81       	ldd	r30, Y+3	; 0x03
     f46:	fc 81       	ldd	r31, Y+4	; 0x04
     f48:	80 e8       	ldi	r24, 0x80	; 128
     f4a:	80 83       	st	Z, r24
	pxTopOfStack--;
     f4c:	8b 81       	ldd	r24, Y+3	; 0x03
     f4e:	9c 81       	ldd	r25, Y+4	; 0x04
     f50:	01 97       	sbiw	r24, 0x01	; 1
     f52:	9c 83       	std	Y+4, r25	; 0x04
     f54:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     f56:	eb 81       	ldd	r30, Y+3	; 0x03
     f58:	fc 81       	ldd	r31, Y+4	; 0x04
     f5a:	10 82       	st	Z, r1
	pxTopOfStack--;
     f5c:	8b 81       	ldd	r24, Y+3	; 0x03
     f5e:	9c 81       	ldd	r25, Y+4	; 0x04
     f60:	01 97       	sbiw	r24, 0x01	; 1
     f62:	9c 83       	std	Y+4, r25	; 0x04
     f64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     f66:	eb 81       	ldd	r30, Y+3	; 0x03
     f68:	fc 81       	ldd	r31, Y+4	; 0x04
     f6a:	82 e0       	ldi	r24, 0x02	; 2
     f6c:	80 83       	st	Z, r24
	pxTopOfStack--;
     f6e:	8b 81       	ldd	r24, Y+3	; 0x03
     f70:	9c 81       	ldd	r25, Y+4	; 0x04
     f72:	01 97       	sbiw	r24, 0x01	; 1
     f74:	9c 83       	std	Y+4, r25	; 0x04
     f76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     f78:	eb 81       	ldd	r30, Y+3	; 0x03
     f7a:	fc 81       	ldd	r31, Y+4	; 0x04
     f7c:	83 e0       	ldi	r24, 0x03	; 3
     f7e:	80 83       	st	Z, r24
	pxTopOfStack--;
     f80:	8b 81       	ldd	r24, Y+3	; 0x03
     f82:	9c 81       	ldd	r25, Y+4	; 0x04
     f84:	01 97       	sbiw	r24, 0x01	; 1
     f86:	9c 83       	std	Y+4, r25	; 0x04
     f88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     f8a:	eb 81       	ldd	r30, Y+3	; 0x03
     f8c:	fc 81       	ldd	r31, Y+4	; 0x04
     f8e:	84 e0       	ldi	r24, 0x04	; 4
     f90:	80 83       	st	Z, r24
	pxTopOfStack--;
     f92:	8b 81       	ldd	r24, Y+3	; 0x03
     f94:	9c 81       	ldd	r25, Y+4	; 0x04
     f96:	01 97       	sbiw	r24, 0x01	; 1
     f98:	9c 83       	std	Y+4, r25	; 0x04
     f9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     f9c:	eb 81       	ldd	r30, Y+3	; 0x03
     f9e:	fc 81       	ldd	r31, Y+4	; 0x04
     fa0:	85 e0       	ldi	r24, 0x05	; 5
     fa2:	80 83       	st	Z, r24
	pxTopOfStack--;
     fa4:	8b 81       	ldd	r24, Y+3	; 0x03
     fa6:	9c 81       	ldd	r25, Y+4	; 0x04
     fa8:	01 97       	sbiw	r24, 0x01	; 1
     faa:	9c 83       	std	Y+4, r25	; 0x04
     fac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     fae:	eb 81       	ldd	r30, Y+3	; 0x03
     fb0:	fc 81       	ldd	r31, Y+4	; 0x04
     fb2:	86 e0       	ldi	r24, 0x06	; 6
     fb4:	80 83       	st	Z, r24
	pxTopOfStack--;
     fb6:	8b 81       	ldd	r24, Y+3	; 0x03
     fb8:	9c 81       	ldd	r25, Y+4	; 0x04
     fba:	01 97       	sbiw	r24, 0x01	; 1
     fbc:	9c 83       	std	Y+4, r25	; 0x04
     fbe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     fc0:	eb 81       	ldd	r30, Y+3	; 0x03
     fc2:	fc 81       	ldd	r31, Y+4	; 0x04
     fc4:	87 e0       	ldi	r24, 0x07	; 7
     fc6:	80 83       	st	Z, r24
	pxTopOfStack--;
     fc8:	8b 81       	ldd	r24, Y+3	; 0x03
     fca:	9c 81       	ldd	r25, Y+4	; 0x04
     fcc:	01 97       	sbiw	r24, 0x01	; 1
     fce:	9c 83       	std	Y+4, r25	; 0x04
     fd0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     fd2:	eb 81       	ldd	r30, Y+3	; 0x03
     fd4:	fc 81       	ldd	r31, Y+4	; 0x04
     fd6:	88 e0       	ldi	r24, 0x08	; 8
     fd8:	80 83       	st	Z, r24
	pxTopOfStack--;
     fda:	8b 81       	ldd	r24, Y+3	; 0x03
     fdc:	9c 81       	ldd	r25, Y+4	; 0x04
     fde:	01 97       	sbiw	r24, 0x01	; 1
     fe0:	9c 83       	std	Y+4, r25	; 0x04
     fe2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     fe4:	eb 81       	ldd	r30, Y+3	; 0x03
     fe6:	fc 81       	ldd	r31, Y+4	; 0x04
     fe8:	89 e0       	ldi	r24, 0x09	; 9
     fea:	80 83       	st	Z, r24
	pxTopOfStack--;
     fec:	8b 81       	ldd	r24, Y+3	; 0x03
     fee:	9c 81       	ldd	r25, Y+4	; 0x04
     ff0:	01 97       	sbiw	r24, 0x01	; 1
     ff2:	9c 83       	std	Y+4, r25	; 0x04
     ff4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     ff6:	eb 81       	ldd	r30, Y+3	; 0x03
     ff8:	fc 81       	ldd	r31, Y+4	; 0x04
     ffa:	80 e1       	ldi	r24, 0x10	; 16
     ffc:	80 83       	st	Z, r24
	pxTopOfStack--;
     ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    1000:	9c 81       	ldd	r25, Y+4	; 0x04
    1002:	01 97       	sbiw	r24, 0x01	; 1
    1004:	9c 83       	std	Y+4, r25	; 0x04
    1006:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1008:	eb 81       	ldd	r30, Y+3	; 0x03
    100a:	fc 81       	ldd	r31, Y+4	; 0x04
    100c:	81 e1       	ldi	r24, 0x11	; 17
    100e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1010:	8b 81       	ldd	r24, Y+3	; 0x03
    1012:	9c 81       	ldd	r25, Y+4	; 0x04
    1014:	01 97       	sbiw	r24, 0x01	; 1
    1016:	9c 83       	std	Y+4, r25	; 0x04
    1018:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    101a:	eb 81       	ldd	r30, Y+3	; 0x03
    101c:	fc 81       	ldd	r31, Y+4	; 0x04
    101e:	82 e1       	ldi	r24, 0x12	; 18
    1020:	80 83       	st	Z, r24
	pxTopOfStack--;
    1022:	8b 81       	ldd	r24, Y+3	; 0x03
    1024:	9c 81       	ldd	r25, Y+4	; 0x04
    1026:	01 97       	sbiw	r24, 0x01	; 1
    1028:	9c 83       	std	Y+4, r25	; 0x04
    102a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    102c:	eb 81       	ldd	r30, Y+3	; 0x03
    102e:	fc 81       	ldd	r31, Y+4	; 0x04
    1030:	83 e1       	ldi	r24, 0x13	; 19
    1032:	80 83       	st	Z, r24
	pxTopOfStack--;
    1034:	8b 81       	ldd	r24, Y+3	; 0x03
    1036:	9c 81       	ldd	r25, Y+4	; 0x04
    1038:	01 97       	sbiw	r24, 0x01	; 1
    103a:	9c 83       	std	Y+4, r25	; 0x04
    103c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    103e:	eb 81       	ldd	r30, Y+3	; 0x03
    1040:	fc 81       	ldd	r31, Y+4	; 0x04
    1042:	84 e1       	ldi	r24, 0x14	; 20
    1044:	80 83       	st	Z, r24
	pxTopOfStack--;
    1046:	8b 81       	ldd	r24, Y+3	; 0x03
    1048:	9c 81       	ldd	r25, Y+4	; 0x04
    104a:	01 97       	sbiw	r24, 0x01	; 1
    104c:	9c 83       	std	Y+4, r25	; 0x04
    104e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1050:	eb 81       	ldd	r30, Y+3	; 0x03
    1052:	fc 81       	ldd	r31, Y+4	; 0x04
    1054:	85 e1       	ldi	r24, 0x15	; 21
    1056:	80 83       	st	Z, r24
	pxTopOfStack--;
    1058:	8b 81       	ldd	r24, Y+3	; 0x03
    105a:	9c 81       	ldd	r25, Y+4	; 0x04
    105c:	01 97       	sbiw	r24, 0x01	; 1
    105e:	9c 83       	std	Y+4, r25	; 0x04
    1060:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1062:	eb 81       	ldd	r30, Y+3	; 0x03
    1064:	fc 81       	ldd	r31, Y+4	; 0x04
    1066:	86 e1       	ldi	r24, 0x16	; 22
    1068:	80 83       	st	Z, r24
	pxTopOfStack--;
    106a:	8b 81       	ldd	r24, Y+3	; 0x03
    106c:	9c 81       	ldd	r25, Y+4	; 0x04
    106e:	01 97       	sbiw	r24, 0x01	; 1
    1070:	9c 83       	std	Y+4, r25	; 0x04
    1072:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1074:	eb 81       	ldd	r30, Y+3	; 0x03
    1076:	fc 81       	ldd	r31, Y+4	; 0x04
    1078:	87 e1       	ldi	r24, 0x17	; 23
    107a:	80 83       	st	Z, r24
	pxTopOfStack--;
    107c:	8b 81       	ldd	r24, Y+3	; 0x03
    107e:	9c 81       	ldd	r25, Y+4	; 0x04
    1080:	01 97       	sbiw	r24, 0x01	; 1
    1082:	9c 83       	std	Y+4, r25	; 0x04
    1084:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1086:	eb 81       	ldd	r30, Y+3	; 0x03
    1088:	fc 81       	ldd	r31, Y+4	; 0x04
    108a:	88 e1       	ldi	r24, 0x18	; 24
    108c:	80 83       	st	Z, r24
	pxTopOfStack--;
    108e:	8b 81       	ldd	r24, Y+3	; 0x03
    1090:	9c 81       	ldd	r25, Y+4	; 0x04
    1092:	01 97       	sbiw	r24, 0x01	; 1
    1094:	9c 83       	std	Y+4, r25	; 0x04
    1096:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1098:	eb 81       	ldd	r30, Y+3	; 0x03
    109a:	fc 81       	ldd	r31, Y+4	; 0x04
    109c:	89 e1       	ldi	r24, 0x19	; 25
    109e:	80 83       	st	Z, r24
	pxTopOfStack--;
    10a0:	8b 81       	ldd	r24, Y+3	; 0x03
    10a2:	9c 81       	ldd	r25, Y+4	; 0x04
    10a4:	01 97       	sbiw	r24, 0x01	; 1
    10a6:	9c 83       	std	Y+4, r25	; 0x04
    10a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    10aa:	eb 81       	ldd	r30, Y+3	; 0x03
    10ac:	fc 81       	ldd	r31, Y+4	; 0x04
    10ae:	80 e2       	ldi	r24, 0x20	; 32
    10b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    10b2:	8b 81       	ldd	r24, Y+3	; 0x03
    10b4:	9c 81       	ldd	r25, Y+4	; 0x04
    10b6:	01 97       	sbiw	r24, 0x01	; 1
    10b8:	9c 83       	std	Y+4, r25	; 0x04
    10ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    10bc:	eb 81       	ldd	r30, Y+3	; 0x03
    10be:	fc 81       	ldd	r31, Y+4	; 0x04
    10c0:	81 e2       	ldi	r24, 0x21	; 33
    10c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    10c4:	8b 81       	ldd	r24, Y+3	; 0x03
    10c6:	9c 81       	ldd	r25, Y+4	; 0x04
    10c8:	01 97       	sbiw	r24, 0x01	; 1
    10ca:	9c 83       	std	Y+4, r25	; 0x04
    10cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    10ce:	eb 81       	ldd	r30, Y+3	; 0x03
    10d0:	fc 81       	ldd	r31, Y+4	; 0x04
    10d2:	82 e2       	ldi	r24, 0x22	; 34
    10d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    10d6:	8b 81       	ldd	r24, Y+3	; 0x03
    10d8:	9c 81       	ldd	r25, Y+4	; 0x04
    10da:	01 97       	sbiw	r24, 0x01	; 1
    10dc:	9c 83       	std	Y+4, r25	; 0x04
    10de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    10e0:	eb 81       	ldd	r30, Y+3	; 0x03
    10e2:	fc 81       	ldd	r31, Y+4	; 0x04
    10e4:	83 e2       	ldi	r24, 0x23	; 35
    10e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    10e8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ea:	9c 81       	ldd	r25, Y+4	; 0x04
    10ec:	01 97       	sbiw	r24, 0x01	; 1
    10ee:	9c 83       	std	Y+4, r25	; 0x04
    10f0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    10f2:	8f 81       	ldd	r24, Y+7	; 0x07
    10f4:	98 85       	ldd	r25, Y+8	; 0x08
    10f6:	9a 83       	std	Y+2, r25	; 0x02
    10f8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    10fa:	89 81       	ldd	r24, Y+1	; 0x01
    10fc:	eb 81       	ldd	r30, Y+3	; 0x03
    10fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1100:	80 83       	st	Z, r24
	pxTopOfStack--;
    1102:	8b 81       	ldd	r24, Y+3	; 0x03
    1104:	9c 81       	ldd	r25, Y+4	; 0x04
    1106:	01 97       	sbiw	r24, 0x01	; 1
    1108:	9c 83       	std	Y+4, r25	; 0x04
    110a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    110c:	89 81       	ldd	r24, Y+1	; 0x01
    110e:	9a 81       	ldd	r25, Y+2	; 0x02
    1110:	89 2f       	mov	r24, r25
    1112:	99 27       	eor	r25, r25
    1114:	9a 83       	std	Y+2, r25	; 0x02
    1116:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1118:	89 81       	ldd	r24, Y+1	; 0x01
    111a:	eb 81       	ldd	r30, Y+3	; 0x03
    111c:	fc 81       	ldd	r31, Y+4	; 0x04
    111e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1120:	8b 81       	ldd	r24, Y+3	; 0x03
    1122:	9c 81       	ldd	r25, Y+4	; 0x04
    1124:	01 97       	sbiw	r24, 0x01	; 1
    1126:	9c 83       	std	Y+4, r25	; 0x04
    1128:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    112a:	eb 81       	ldd	r30, Y+3	; 0x03
    112c:	fc 81       	ldd	r31, Y+4	; 0x04
    112e:	86 e2       	ldi	r24, 0x26	; 38
    1130:	80 83       	st	Z, r24
	pxTopOfStack--;
    1132:	8b 81       	ldd	r24, Y+3	; 0x03
    1134:	9c 81       	ldd	r25, Y+4	; 0x04
    1136:	01 97       	sbiw	r24, 0x01	; 1
    1138:	9c 83       	std	Y+4, r25	; 0x04
    113a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    113c:	eb 81       	ldd	r30, Y+3	; 0x03
    113e:	fc 81       	ldd	r31, Y+4	; 0x04
    1140:	87 e2       	ldi	r24, 0x27	; 39
    1142:	80 83       	st	Z, r24
	pxTopOfStack--;
    1144:	8b 81       	ldd	r24, Y+3	; 0x03
    1146:	9c 81       	ldd	r25, Y+4	; 0x04
    1148:	01 97       	sbiw	r24, 0x01	; 1
    114a:	9c 83       	std	Y+4, r25	; 0x04
    114c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    114e:	eb 81       	ldd	r30, Y+3	; 0x03
    1150:	fc 81       	ldd	r31, Y+4	; 0x04
    1152:	88 e2       	ldi	r24, 0x28	; 40
    1154:	80 83       	st	Z, r24
	pxTopOfStack--;
    1156:	8b 81       	ldd	r24, Y+3	; 0x03
    1158:	9c 81       	ldd	r25, Y+4	; 0x04
    115a:	01 97       	sbiw	r24, 0x01	; 1
    115c:	9c 83       	std	Y+4, r25	; 0x04
    115e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1160:	eb 81       	ldd	r30, Y+3	; 0x03
    1162:	fc 81       	ldd	r31, Y+4	; 0x04
    1164:	89 e2       	ldi	r24, 0x29	; 41
    1166:	80 83       	st	Z, r24
	pxTopOfStack--;
    1168:	8b 81       	ldd	r24, Y+3	; 0x03
    116a:	9c 81       	ldd	r25, Y+4	; 0x04
    116c:	01 97       	sbiw	r24, 0x01	; 1
    116e:	9c 83       	std	Y+4, r25	; 0x04
    1170:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1172:	eb 81       	ldd	r30, Y+3	; 0x03
    1174:	fc 81       	ldd	r31, Y+4	; 0x04
    1176:	80 e3       	ldi	r24, 0x30	; 48
    1178:	80 83       	st	Z, r24
	pxTopOfStack--;
    117a:	8b 81       	ldd	r24, Y+3	; 0x03
    117c:	9c 81       	ldd	r25, Y+4	; 0x04
    117e:	01 97       	sbiw	r24, 0x01	; 1
    1180:	9c 83       	std	Y+4, r25	; 0x04
    1182:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1184:	eb 81       	ldd	r30, Y+3	; 0x03
    1186:	fc 81       	ldd	r31, Y+4	; 0x04
    1188:	81 e3       	ldi	r24, 0x31	; 49
    118a:	80 83       	st	Z, r24
	pxTopOfStack--;
    118c:	8b 81       	ldd	r24, Y+3	; 0x03
    118e:	9c 81       	ldd	r25, Y+4	; 0x04
    1190:	01 97       	sbiw	r24, 0x01	; 1
    1192:	9c 83       	std	Y+4, r25	; 0x04
    1194:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1196:	8b 81       	ldd	r24, Y+3	; 0x03
    1198:	9c 81       	ldd	r25, Y+4	; 0x04
}
    119a:	28 96       	adiw	r28, 0x08	; 8
    119c:	0f b6       	in	r0, 0x3f	; 63
    119e:	f8 94       	cli
    11a0:	de bf       	out	0x3e, r29	; 62
    11a2:	0f be       	out	0x3f, r0	; 63
    11a4:	cd bf       	out	0x3d, r28	; 61
    11a6:	cf 91       	pop	r28
    11a8:	df 91       	pop	r29
    11aa:	08 95       	ret

000011ac <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    11ac:	df 93       	push	r29
    11ae:	cf 93       	push	r28
    11b0:	cd b7       	in	r28, 0x3d	; 61
    11b2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    11b4:	0e 94 c8 09 	call	0x1390	; 0x1390 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    11b8:	a0 91 60 08 	lds	r26, 0x0860
    11bc:	b0 91 61 08 	lds	r27, 0x0861
    11c0:	cd 91       	ld	r28, X+
    11c2:	cd bf       	out	0x3d, r28	; 61
    11c4:	dd 91       	ld	r29, X+
    11c6:	de bf       	out	0x3e, r29	; 62
    11c8:	ff 91       	pop	r31
    11ca:	ef 91       	pop	r30
    11cc:	df 91       	pop	r29
    11ce:	cf 91       	pop	r28
    11d0:	bf 91       	pop	r27
    11d2:	af 91       	pop	r26
    11d4:	9f 91       	pop	r25
    11d6:	8f 91       	pop	r24
    11d8:	7f 91       	pop	r23
    11da:	6f 91       	pop	r22
    11dc:	5f 91       	pop	r21
    11de:	4f 91       	pop	r20
    11e0:	3f 91       	pop	r19
    11e2:	2f 91       	pop	r18
    11e4:	1f 91       	pop	r17
    11e6:	0f 91       	pop	r16
    11e8:	ff 90       	pop	r15
    11ea:	ef 90       	pop	r14
    11ec:	df 90       	pop	r13
    11ee:	cf 90       	pop	r12
    11f0:	bf 90       	pop	r11
    11f2:	af 90       	pop	r10
    11f4:	9f 90       	pop	r9
    11f6:	8f 90       	pop	r8
    11f8:	7f 90       	pop	r7
    11fa:	6f 90       	pop	r6
    11fc:	5f 90       	pop	r5
    11fe:	4f 90       	pop	r4
    1200:	3f 90       	pop	r3
    1202:	2f 90       	pop	r2
    1204:	1f 90       	pop	r1
    1206:	0f 90       	pop	r0
    1208:	0f be       	out	0x3f, r0	; 63
    120a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    120c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    120e:	81 e0       	ldi	r24, 0x01	; 1
}
    1210:	cf 91       	pop	r28
    1212:	df 91       	pop	r29
    1214:	08 95       	ret

00001216 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1216:	df 93       	push	r29
    1218:	cf 93       	push	r28
    121a:	cd b7       	in	r28, 0x3d	; 61
    121c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    121e:	cf 91       	pop	r28
    1220:	df 91       	pop	r29
    1222:	08 95       	ret

00001224 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1224:	0f 92       	push	r0
    1226:	0f b6       	in	r0, 0x3f	; 63
    1228:	f8 94       	cli
    122a:	0f 92       	push	r0
    122c:	1f 92       	push	r1
    122e:	11 24       	eor	r1, r1
    1230:	2f 92       	push	r2
    1232:	3f 92       	push	r3
    1234:	4f 92       	push	r4
    1236:	5f 92       	push	r5
    1238:	6f 92       	push	r6
    123a:	7f 92       	push	r7
    123c:	8f 92       	push	r8
    123e:	9f 92       	push	r9
    1240:	af 92       	push	r10
    1242:	bf 92       	push	r11
    1244:	cf 92       	push	r12
    1246:	df 92       	push	r13
    1248:	ef 92       	push	r14
    124a:	ff 92       	push	r15
    124c:	0f 93       	push	r16
    124e:	1f 93       	push	r17
    1250:	2f 93       	push	r18
    1252:	3f 93       	push	r19
    1254:	4f 93       	push	r20
    1256:	5f 93       	push	r21
    1258:	6f 93       	push	r22
    125a:	7f 93       	push	r23
    125c:	8f 93       	push	r24
    125e:	9f 93       	push	r25
    1260:	af 93       	push	r26
    1262:	bf 93       	push	r27
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	ef 93       	push	r30
    126a:	ff 93       	push	r31
    126c:	a0 91 60 08 	lds	r26, 0x0860
    1270:	b0 91 61 08 	lds	r27, 0x0861
    1274:	0d b6       	in	r0, 0x3d	; 61
    1276:	0d 92       	st	X+, r0
    1278:	0e b6       	in	r0, 0x3e	; 62
    127a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    127c:	0e 94 98 21 	call	0x4330	; 0x4330 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1280:	a0 91 60 08 	lds	r26, 0x0860
    1284:	b0 91 61 08 	lds	r27, 0x0861
    1288:	cd 91       	ld	r28, X+
    128a:	cd bf       	out	0x3d, r28	; 61
    128c:	dd 91       	ld	r29, X+
    128e:	de bf       	out	0x3e, r29	; 62
    1290:	ff 91       	pop	r31
    1292:	ef 91       	pop	r30
    1294:	df 91       	pop	r29
    1296:	cf 91       	pop	r28
    1298:	bf 91       	pop	r27
    129a:	af 91       	pop	r26
    129c:	9f 91       	pop	r25
    129e:	8f 91       	pop	r24
    12a0:	7f 91       	pop	r23
    12a2:	6f 91       	pop	r22
    12a4:	5f 91       	pop	r21
    12a6:	4f 91       	pop	r20
    12a8:	3f 91       	pop	r19
    12aa:	2f 91       	pop	r18
    12ac:	1f 91       	pop	r17
    12ae:	0f 91       	pop	r16
    12b0:	ff 90       	pop	r15
    12b2:	ef 90       	pop	r14
    12b4:	df 90       	pop	r13
    12b6:	cf 90       	pop	r12
    12b8:	bf 90       	pop	r11
    12ba:	af 90       	pop	r10
    12bc:	9f 90       	pop	r9
    12be:	8f 90       	pop	r8
    12c0:	7f 90       	pop	r7
    12c2:	6f 90       	pop	r6
    12c4:	5f 90       	pop	r5
    12c6:	4f 90       	pop	r4
    12c8:	3f 90       	pop	r3
    12ca:	2f 90       	pop	r2
    12cc:	1f 90       	pop	r1
    12ce:	0f 90       	pop	r0
    12d0:	0f be       	out	0x3f, r0	; 63
    12d2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12d4:	08 95       	ret

000012d6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12d6:	0f 92       	push	r0
    12d8:	0f b6       	in	r0, 0x3f	; 63
    12da:	f8 94       	cli
    12dc:	0f 92       	push	r0
    12de:	1f 92       	push	r1
    12e0:	11 24       	eor	r1, r1
    12e2:	2f 92       	push	r2
    12e4:	3f 92       	push	r3
    12e6:	4f 92       	push	r4
    12e8:	5f 92       	push	r5
    12ea:	6f 92       	push	r6
    12ec:	7f 92       	push	r7
    12ee:	8f 92       	push	r8
    12f0:	9f 92       	push	r9
    12f2:	af 92       	push	r10
    12f4:	bf 92       	push	r11
    12f6:	cf 92       	push	r12
    12f8:	df 92       	push	r13
    12fa:	ef 92       	push	r14
    12fc:	ff 92       	push	r15
    12fe:	0f 93       	push	r16
    1300:	1f 93       	push	r17
    1302:	2f 93       	push	r18
    1304:	3f 93       	push	r19
    1306:	4f 93       	push	r20
    1308:	5f 93       	push	r21
    130a:	6f 93       	push	r22
    130c:	7f 93       	push	r23
    130e:	8f 93       	push	r24
    1310:	9f 93       	push	r25
    1312:	af 93       	push	r26
    1314:	bf 93       	push	r27
    1316:	cf 93       	push	r28
    1318:	df 93       	push	r29
    131a:	ef 93       	push	r30
    131c:	ff 93       	push	r31
    131e:	a0 91 60 08 	lds	r26, 0x0860
    1322:	b0 91 61 08 	lds	r27, 0x0861
    1326:	0d b6       	in	r0, 0x3d	; 61
    1328:	0d 92       	st	X+, r0
    132a:	0e b6       	in	r0, 0x3e	; 62
    132c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    132e:	0e 94 01 20 	call	0x4002	; 0x4002 <xTaskIncrementTick>
    1332:	88 23       	and	r24, r24
    1334:	11 f0       	breq	.+4      	; 0x133a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1336:	0e 94 98 21 	call	0x4330	; 0x4330 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    133a:	a0 91 60 08 	lds	r26, 0x0860
    133e:	b0 91 61 08 	lds	r27, 0x0861
    1342:	cd 91       	ld	r28, X+
    1344:	cd bf       	out	0x3d, r28	; 61
    1346:	dd 91       	ld	r29, X+
    1348:	de bf       	out	0x3e, r29	; 62
    134a:	ff 91       	pop	r31
    134c:	ef 91       	pop	r30
    134e:	df 91       	pop	r29
    1350:	cf 91       	pop	r28
    1352:	bf 91       	pop	r27
    1354:	af 91       	pop	r26
    1356:	9f 91       	pop	r25
    1358:	8f 91       	pop	r24
    135a:	7f 91       	pop	r23
    135c:	6f 91       	pop	r22
    135e:	5f 91       	pop	r21
    1360:	4f 91       	pop	r20
    1362:	3f 91       	pop	r19
    1364:	2f 91       	pop	r18
    1366:	1f 91       	pop	r17
    1368:	0f 91       	pop	r16
    136a:	ff 90       	pop	r15
    136c:	ef 90       	pop	r14
    136e:	df 90       	pop	r13
    1370:	cf 90       	pop	r12
    1372:	bf 90       	pop	r11
    1374:	af 90       	pop	r10
    1376:	9f 90       	pop	r9
    1378:	8f 90       	pop	r8
    137a:	7f 90       	pop	r7
    137c:	6f 90       	pop	r6
    137e:	5f 90       	pop	r5
    1380:	4f 90       	pop	r4
    1382:	3f 90       	pop	r3
    1384:	2f 90       	pop	r2
    1386:	1f 90       	pop	r1
    1388:	0f 90       	pop	r0
    138a:	0f be       	out	0x3f, r0	; 63
    138c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    138e:	08 95       	ret

00001390 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1390:	df 93       	push	r29
    1392:	cf 93       	push	r28
    1394:	00 d0       	rcall	.+0      	; 0x1396 <prvSetupTimerInterrupt+0x6>
    1396:	00 d0       	rcall	.+0      	; 0x1398 <prvSetupTimerInterrupt+0x8>
    1398:	00 d0       	rcall	.+0      	; 0x139a <prvSetupTimerInterrupt+0xa>
    139a:	cd b7       	in	r28, 0x3d	; 61
    139c:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    139e:	80 e8       	ldi	r24, 0x80	; 128
    13a0:	9e e3       	ldi	r25, 0x3E	; 62
    13a2:	a0 e0       	ldi	r26, 0x00	; 0
    13a4:	b0 e0       	ldi	r27, 0x00	; 0
    13a6:	8b 83       	std	Y+3, r24	; 0x03
    13a8:	9c 83       	std	Y+4, r25	; 0x04
    13aa:	ad 83       	std	Y+5, r26	; 0x05
    13ac:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    13ae:	8b 81       	ldd	r24, Y+3	; 0x03
    13b0:	9c 81       	ldd	r25, Y+4	; 0x04
    13b2:	ad 81       	ldd	r26, Y+5	; 0x05
    13b4:	be 81       	ldd	r27, Y+6	; 0x06
    13b6:	68 94       	set
    13b8:	15 f8       	bld	r1, 5
    13ba:	b6 95       	lsr	r27
    13bc:	a7 95       	ror	r26
    13be:	97 95       	ror	r25
    13c0:	87 95       	ror	r24
    13c2:	16 94       	lsr	r1
    13c4:	d1 f7       	brne	.-12     	; 0x13ba <prvSetupTimerInterrupt+0x2a>
    13c6:	8b 83       	std	Y+3, r24	; 0x03
    13c8:	9c 83       	std	Y+4, r25	; 0x04
    13ca:	ad 83       	std	Y+5, r26	; 0x05
    13cc:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    13ce:	8b 81       	ldd	r24, Y+3	; 0x03
    13d0:	9c 81       	ldd	r25, Y+4	; 0x04
    13d2:	ad 81       	ldd	r26, Y+5	; 0x05
    13d4:	be 81       	ldd	r27, Y+6	; 0x06
    13d6:	01 97       	sbiw	r24, 0x01	; 1
    13d8:	a1 09       	sbc	r26, r1
    13da:	b1 09       	sbc	r27, r1
    13dc:	8b 83       	std	Y+3, r24	; 0x03
    13de:	9c 83       	std	Y+4, r25	; 0x04
    13e0:	ad 83       	std	Y+5, r26	; 0x05
    13e2:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    13e4:	8b 81       	ldd	r24, Y+3	; 0x03
    13e6:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    13e8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ea:	9c 81       	ldd	r25, Y+4	; 0x04
    13ec:	ad 81       	ldd	r26, Y+5	; 0x05
    13ee:	be 81       	ldd	r27, Y+6	; 0x06
    13f0:	89 2f       	mov	r24, r25
    13f2:	9a 2f       	mov	r25, r26
    13f4:	ab 2f       	mov	r26, r27
    13f6:	bb 27       	eor	r27, r27
    13f8:	8b 83       	std	Y+3, r24	; 0x03
    13fa:	9c 83       	std	Y+4, r25	; 0x04
    13fc:	ad 83       	std	Y+5, r26	; 0x05
    13fe:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1400:	8b 81       	ldd	r24, Y+3	; 0x03
    1402:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1404:	eb e4       	ldi	r30, 0x4B	; 75
    1406:	f0 e0       	ldi	r31, 0x00	; 0
    1408:	8a 81       	ldd	r24, Y+2	; 0x02
    140a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    140c:	ea e4       	ldi	r30, 0x4A	; 74
    140e:	f0 e0       	ldi	r31, 0x00	; 0
    1410:	89 81       	ldd	r24, Y+1	; 0x01
    1412:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1414:	8b e0       	ldi	r24, 0x0B	; 11
    1416:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1418:	ee e4       	ldi	r30, 0x4E	; 78
    141a:	f0 e0       	ldi	r31, 0x00	; 0
    141c:	89 81       	ldd	r24, Y+1	; 0x01
    141e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1420:	e7 e5       	ldi	r30, 0x57	; 87
    1422:	f0 e0       	ldi	r31, 0x00	; 0
    1424:	80 81       	ld	r24, Z
    1426:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1428:	89 81       	ldd	r24, Y+1	; 0x01
    142a:	80 61       	ori	r24, 0x10	; 16
    142c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    142e:	e7 e5       	ldi	r30, 0x57	; 87
    1430:	f0 e0       	ldi	r31, 0x00	; 0
    1432:	89 81       	ldd	r24, Y+1	; 0x01
    1434:	80 83       	st	Z, r24
}
    1436:	26 96       	adiw	r28, 0x06	; 6
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	f8 94       	cli
    143c:	de bf       	out	0x3e, r29	; 62
    143e:	0f be       	out	0x3f, r0	; 63
    1440:	cd bf       	out	0x3d, r28	; 61
    1442:	cf 91       	pop	r28
    1444:	df 91       	pop	r29
    1446:	08 95       	ret

00001448 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1448:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    144c:	18 95       	reti

0000144e <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
    144e:	df 93       	push	r29
    1450:	cf 93       	push	r28
    1452:	cd b7       	in	r28, 0x3d	; 61
    1454:	de b7       	in	r29, 0x3e	; 62
    1456:	27 97       	sbiw	r28, 0x07	; 7
    1458:	0f b6       	in	r0, 0x3f	; 63
    145a:	f8 94       	cli
    145c:	de bf       	out	0x3e, r29	; 62
    145e:	0f be       	out	0x3f, r0	; 63
    1460:	cd bf       	out	0x3d, r28	; 61
    1462:	9d 83       	std	Y+5, r25	; 0x05
    1464:	8c 83       	std	Y+4, r24	; 0x04
    1466:	6e 83       	std	Y+6, r22	; 0x06
    1468:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    146a:	8a e1       	ldi	r24, 0x1A	; 26
    146c:	90 e0       	ldi	r25, 0x00	; 0
    146e:	0e 94 d3 06 	call	0xda6	; 0xda6 <pvPortMalloc>
    1472:	9a 83       	std	Y+2, r25	; 0x02
    1474:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
    1476:	89 81       	ldd	r24, Y+1	; 0x01
    1478:	9a 81       	ldd	r25, Y+2	; 0x02
    147a:	00 97       	sbiw	r24, 0x00	; 0
    147c:	09 f4       	brne	.+2      	; 0x1480 <xCoRoutineCreate+0x32>
    147e:	6f c0       	rjmp	.+222    	; 0x155e <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
    1480:	80 91 2a 08 	lds	r24, 0x082A
    1484:	90 91 2b 08 	lds	r25, 0x082B
    1488:	00 97       	sbiw	r24, 0x00	; 0
    148a:	41 f4       	brne	.+16     	; 0x149c <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
    148c:	89 81       	ldd	r24, Y+1	; 0x01
    148e:	9a 81       	ldd	r25, Y+2	; 0x02
    1490:	90 93 2b 08 	sts	0x082B, r25
    1494:	80 93 2a 08 	sts	0x082A, r24
                prvInitialiseCoRoutineLists();
    1498:	0e 94 95 0c 	call	0x192a	; 0x192a <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    149c:	8e 81       	ldd	r24, Y+6	; 0x06
    149e:	82 30       	cpi	r24, 0x02	; 2
    14a0:	10 f0       	brcs	.+4      	; 0x14a6 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    14a2:	81 e0       	ldi	r24, 0x01	; 1
    14a4:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
    14a6:	e9 81       	ldd	r30, Y+1	; 0x01
    14a8:	fa 81       	ldd	r31, Y+2	; 0x02
    14aa:	11 8e       	std	Z+25, r1	; 0x19
    14ac:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
    14ae:	e9 81       	ldd	r30, Y+1	; 0x01
    14b0:	fa 81       	ldd	r31, Y+2	; 0x02
    14b2:	8e 81       	ldd	r24, Y+6	; 0x06
    14b4:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
    14b6:	e9 81       	ldd	r30, Y+1	; 0x01
    14b8:	fa 81       	ldd	r31, Y+2	; 0x02
    14ba:	8f 81       	ldd	r24, Y+7	; 0x07
    14bc:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    14be:	e9 81       	ldd	r30, Y+1	; 0x01
    14c0:	fa 81       	ldd	r31, Y+2	; 0x02
    14c2:	8c 81       	ldd	r24, Y+4	; 0x04
    14c4:	9d 81       	ldd	r25, Y+5	; 0x05
    14c6:	91 83       	std	Z+1, r25	; 0x01
    14c8:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    14ca:	89 81       	ldd	r24, Y+1	; 0x01
    14cc:	9a 81       	ldd	r25, Y+2	; 0x02
    14ce:	02 96       	adiw	r24, 0x02	; 2
    14d0:	0e 94 75 10 	call	0x20ea	; 0x20ea <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    14d4:	89 81       	ldd	r24, Y+1	; 0x01
    14d6:	9a 81       	ldd	r25, Y+2	; 0x02
    14d8:	0c 96       	adiw	r24, 0x0c	; 12
    14da:	0e 94 75 10 	call	0x20ea	; 0x20ea <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    14de:	e9 81       	ldd	r30, Y+1	; 0x01
    14e0:	fa 81       	ldd	r31, Y+2	; 0x02
    14e2:	89 81       	ldd	r24, Y+1	; 0x01
    14e4:	9a 81       	ldd	r25, Y+2	; 0x02
    14e6:	91 87       	std	Z+9, r25	; 0x09
    14e8:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    14ea:	e9 81       	ldd	r30, Y+1	; 0x01
    14ec:	fa 81       	ldd	r31, Y+2	; 0x02
    14ee:	89 81       	ldd	r24, Y+1	; 0x01
    14f0:	9a 81       	ldd	r25, Y+2	; 0x02
    14f2:	93 8b       	std	Z+19, r25	; 0x13
    14f4:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    14f6:	8e 81       	ldd	r24, Y+6	; 0x06
    14f8:	28 2f       	mov	r18, r24
    14fa:	30 e0       	ldi	r19, 0x00	; 0
    14fc:	82 e0       	ldi	r24, 0x02	; 2
    14fe:	90 e0       	ldi	r25, 0x00	; 0
    1500:	82 1b       	sub	r24, r18
    1502:	93 0b       	sbc	r25, r19
    1504:	e9 81       	ldd	r30, Y+1	; 0x01
    1506:	fa 81       	ldd	r31, Y+2	; 0x02
    1508:	95 87       	std	Z+13, r25	; 0x0d
    150a:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
    150c:	e9 81       	ldd	r30, Y+1	; 0x01
    150e:	fa 81       	ldd	r31, Y+2	; 0x02
    1510:	96 89       	ldd	r25, Z+22	; 0x16
    1512:	80 91 2c 08 	lds	r24, 0x082C
    1516:	89 17       	cp	r24, r25
    1518:	28 f4       	brcc	.+10     	; 0x1524 <xCoRoutineCreate+0xd6>
    151a:	e9 81       	ldd	r30, Y+1	; 0x01
    151c:	fa 81       	ldd	r31, Y+2	; 0x02
    151e:	86 89       	ldd	r24, Z+22	; 0x16
    1520:	80 93 2c 08 	sts	0x082C, r24
    1524:	e9 81       	ldd	r30, Y+1	; 0x01
    1526:	fa 81       	ldd	r31, Y+2	; 0x02
    1528:	86 89       	ldd	r24, Z+22	; 0x16
    152a:	28 2f       	mov	r18, r24
    152c:	30 e0       	ldi	r19, 0x00	; 0
    152e:	c9 01       	movw	r24, r18
    1530:	88 0f       	add	r24, r24
    1532:	99 1f       	adc	r25, r25
    1534:	88 0f       	add	r24, r24
    1536:	99 1f       	adc	r25, r25
    1538:	88 0f       	add	r24, r24
    153a:	99 1f       	adc	r25, r25
    153c:	82 0f       	add	r24, r18
    153e:	93 1f       	adc	r25, r19
    1540:	ac 01       	movw	r20, r24
    1542:	4d 5c       	subi	r20, 0xCD	; 205
    1544:	57 4f       	sbci	r21, 0xF7	; 247
    1546:	89 81       	ldd	r24, Y+1	; 0x01
    1548:	9a 81       	ldd	r25, Y+2	; 0x02
    154a:	9c 01       	movw	r18, r24
    154c:	2e 5f       	subi	r18, 0xFE	; 254
    154e:	3f 4f       	sbci	r19, 0xFF	; 255
    1550:	ca 01       	movw	r24, r20
    1552:	b9 01       	movw	r22, r18
    1554:	0e 94 85 10 	call	0x210a	; 0x210a <vListInsertEnd>

            xReturn = pdPASS;
    1558:	81 e0       	ldi	r24, 0x01	; 1
    155a:	8b 83       	std	Y+3, r24	; 0x03
    155c:	02 c0       	rjmp	.+4      	; 0x1562 <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    155e:	8f ef       	ldi	r24, 0xFF	; 255
    1560:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    1562:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    1564:	27 96       	adiw	r28, 0x07	; 7
    1566:	0f b6       	in	r0, 0x3f	; 63
    1568:	f8 94       	cli
    156a:	de bf       	out	0x3e, r29	; 62
    156c:	0f be       	out	0x3f, r0	; 63
    156e:	cd bf       	out	0x3d, r28	; 61
    1570:	cf 91       	pop	r28
    1572:	df 91       	pop	r29
    1574:	08 95       	ret

00001576 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    1576:	df 93       	push	r29
    1578:	cf 93       	push	r28
    157a:	00 d0       	rcall	.+0      	; 0x157c <vCoRoutineAddToDelayedList+0x6>
    157c:	00 d0       	rcall	.+0      	; 0x157e <vCoRoutineAddToDelayedList+0x8>
    157e:	00 d0       	rcall	.+0      	; 0x1580 <vCoRoutineAddToDelayedList+0xa>
    1580:	cd b7       	in	r28, 0x3d	; 61
    1582:	de b7       	in	r29, 0x3e	; 62
    1584:	9c 83       	std	Y+4, r25	; 0x04
    1586:	8b 83       	std	Y+3, r24	; 0x03
    1588:	7e 83       	std	Y+6, r23	; 0x06
    158a:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    158c:	20 91 2d 08 	lds	r18, 0x082D
    1590:	30 91 2e 08 	lds	r19, 0x082E
    1594:	8b 81       	ldd	r24, Y+3	; 0x03
    1596:	9c 81       	ldd	r25, Y+4	; 0x04
    1598:	82 0f       	add	r24, r18
    159a:	93 1f       	adc	r25, r19
    159c:	9a 83       	std	Y+2, r25	; 0x02
    159e:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    15a0:	80 91 2a 08 	lds	r24, 0x082A
    15a4:	90 91 2b 08 	lds	r25, 0x082B
    15a8:	02 96       	adiw	r24, 0x02	; 2
    15aa:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    15ae:	e0 91 2a 08 	lds	r30, 0x082A
    15b2:	f0 91 2b 08 	lds	r31, 0x082B
    15b6:	89 81       	ldd	r24, Y+1	; 0x01
    15b8:	9a 81       	ldd	r25, Y+2	; 0x02
    15ba:	93 83       	std	Z+3, r25	; 0x03
    15bc:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    15be:	20 91 2d 08 	lds	r18, 0x082D
    15c2:	30 91 2e 08 	lds	r19, 0x082E
    15c6:	89 81       	ldd	r24, Y+1	; 0x01
    15c8:	9a 81       	ldd	r25, Y+2	; 0x02
    15ca:	82 17       	cp	r24, r18
    15cc:	93 07       	cpc	r25, r19
    15ce:	70 f4       	brcc	.+28     	; 0x15ec <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    15d0:	80 91 28 08 	lds	r24, 0x0828
    15d4:	90 91 29 08 	lds	r25, 0x0829
    15d8:	20 91 2a 08 	lds	r18, 0x082A
    15dc:	30 91 2b 08 	lds	r19, 0x082B
    15e0:	2e 5f       	subi	r18, 0xFE	; 254
    15e2:	3f 4f       	sbci	r19, 0xFF	; 255
    15e4:	b9 01       	movw	r22, r18
    15e6:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsert>
    15ea:	0d c0       	rjmp	.+26     	; 0x1606 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    15ec:	80 91 26 08 	lds	r24, 0x0826
    15f0:	90 91 27 08 	lds	r25, 0x0827
    15f4:	20 91 2a 08 	lds	r18, 0x082A
    15f8:	30 91 2b 08 	lds	r19, 0x082B
    15fc:	2e 5f       	subi	r18, 0xFE	; 254
    15fe:	3f 4f       	sbci	r19, 0xFF	; 255
    1600:	b9 01       	movw	r22, r18
    1602:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsert>
        }

        if( pxEventList )
    1606:	8d 81       	ldd	r24, Y+5	; 0x05
    1608:	9e 81       	ldd	r25, Y+6	; 0x06
    160a:	00 97       	sbiw	r24, 0x00	; 0
    160c:	61 f0       	breq	.+24     	; 0x1626 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    160e:	80 91 2a 08 	lds	r24, 0x082A
    1612:	90 91 2b 08 	lds	r25, 0x082B
    1616:	9c 01       	movw	r18, r24
    1618:	24 5f       	subi	r18, 0xF4	; 244
    161a:	3f 4f       	sbci	r19, 0xFF	; 255
    161c:	8d 81       	ldd	r24, Y+5	; 0x05
    161e:	9e 81       	ldd	r25, Y+6	; 0x06
    1620:	b9 01       	movw	r22, r18
    1622:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsert>
        }
    }
    1626:	26 96       	adiw	r28, 0x06	; 6
    1628:	0f b6       	in	r0, 0x3f	; 63
    162a:	f8 94       	cli
    162c:	de bf       	out	0x3e, r29	; 62
    162e:	0f be       	out	0x3f, r0	; 63
    1630:	cd bf       	out	0x3d, r28	; 61
    1632:	cf 91       	pop	r28
    1634:	df 91       	pop	r29
    1636:	08 95       	ret

00001638 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    1638:	df 93       	push	r29
    163a:	cf 93       	push	r28
    163c:	00 d0       	rcall	.+0      	; 0x163e <prvCheckPendingReadyList+0x6>
    163e:	cd b7       	in	r28, 0x3d	; 61
    1640:	de b7       	in	r29, 0x3e	; 62
    1642:	3a c0       	rjmp	.+116    	; 0x16b8 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    1644:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    1646:	e0 91 5c 08 	lds	r30, 0x085C
    164a:	f0 91 5d 08 	lds	r31, 0x085D
    164e:	86 81       	ldd	r24, Z+6	; 0x06
    1650:	97 81       	ldd	r25, Z+7	; 0x07
    1652:	9a 83       	std	Y+2, r25	; 0x02
    1654:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1656:	89 81       	ldd	r24, Y+1	; 0x01
    1658:	9a 81       	ldd	r25, Y+2	; 0x02
    165a:	0c 96       	adiw	r24, 0x0c	; 12
    165c:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    1660:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1662:	89 81       	ldd	r24, Y+1	; 0x01
    1664:	9a 81       	ldd	r25, Y+2	; 0x02
    1666:	02 96       	adiw	r24, 0x02	; 2
    1668:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    166c:	e9 81       	ldd	r30, Y+1	; 0x01
    166e:	fa 81       	ldd	r31, Y+2	; 0x02
    1670:	96 89       	ldd	r25, Z+22	; 0x16
    1672:	80 91 2c 08 	lds	r24, 0x082C
    1676:	89 17       	cp	r24, r25
    1678:	28 f4       	brcc	.+10     	; 0x1684 <prvCheckPendingReadyList+0x4c>
    167a:	e9 81       	ldd	r30, Y+1	; 0x01
    167c:	fa 81       	ldd	r31, Y+2	; 0x02
    167e:	86 89       	ldd	r24, Z+22	; 0x16
    1680:	80 93 2c 08 	sts	0x082C, r24
    1684:	e9 81       	ldd	r30, Y+1	; 0x01
    1686:	fa 81       	ldd	r31, Y+2	; 0x02
    1688:	86 89       	ldd	r24, Z+22	; 0x16
    168a:	28 2f       	mov	r18, r24
    168c:	30 e0       	ldi	r19, 0x00	; 0
    168e:	c9 01       	movw	r24, r18
    1690:	88 0f       	add	r24, r24
    1692:	99 1f       	adc	r25, r25
    1694:	88 0f       	add	r24, r24
    1696:	99 1f       	adc	r25, r25
    1698:	88 0f       	add	r24, r24
    169a:	99 1f       	adc	r25, r25
    169c:	82 0f       	add	r24, r18
    169e:	93 1f       	adc	r25, r19
    16a0:	ac 01       	movw	r20, r24
    16a2:	4d 5c       	subi	r20, 0xCD	; 205
    16a4:	57 4f       	sbci	r21, 0xF7	; 247
    16a6:	89 81       	ldd	r24, Y+1	; 0x01
    16a8:	9a 81       	ldd	r25, Y+2	; 0x02
    16aa:	9c 01       	movw	r18, r24
    16ac:	2e 5f       	subi	r18, 0xFE	; 254
    16ae:	3f 4f       	sbci	r19, 0xFF	; 255
    16b0:	ca 01       	movw	r24, r20
    16b2:	b9 01       	movw	r22, r18
    16b4:	0e 94 85 10 	call	0x210a	; 0x210a <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    16b8:	80 91 57 08 	lds	r24, 0x0857
    16bc:	88 23       	and	r24, r24
    16be:	09 f0       	breq	.+2      	; 0x16c2 <prvCheckPendingReadyList+0x8a>
    16c0:	c1 cf       	rjmp	.-126    	; 0x1644 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	cf 91       	pop	r28
    16c8:	df 91       	pop	r29
    16ca:	08 95       	ret

000016cc <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    16cc:	df 93       	push	r29
    16ce:	cf 93       	push	r28
    16d0:	00 d0       	rcall	.+0      	; 0x16d2 <prvCheckDelayedList+0x6>
    16d2:	00 d0       	rcall	.+0      	; 0x16d4 <prvCheckDelayedList+0x8>
    16d4:	cd b7       	in	r28, 0x3d	; 61
    16d6:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    16d8:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <xTaskGetTickCount>
    16dc:	20 91 2f 08 	lds	r18, 0x082F
    16e0:	30 91 30 08 	lds	r19, 0x0830
    16e4:	82 1b       	sub	r24, r18
    16e6:	93 0b       	sbc	r25, r19
    16e8:	90 93 32 08 	sts	0x0832, r25
    16ec:	80 93 31 08 	sts	0x0831, r24
    16f0:	85 c0       	rjmp	.+266    	; 0x17fc <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    16f2:	80 91 2d 08 	lds	r24, 0x082D
    16f6:	90 91 2e 08 	lds	r25, 0x082E
    16fa:	01 96       	adiw	r24, 0x01	; 1
    16fc:	90 93 2e 08 	sts	0x082E, r25
    1700:	80 93 2d 08 	sts	0x082D, r24
            xPassedTicks--;
    1704:	80 91 31 08 	lds	r24, 0x0831
    1708:	90 91 32 08 	lds	r25, 0x0832
    170c:	01 97       	sbiw	r24, 0x01	; 1
    170e:	90 93 32 08 	sts	0x0832, r25
    1712:	80 93 31 08 	sts	0x0831, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    1716:	80 91 2d 08 	lds	r24, 0x082D
    171a:	90 91 2e 08 	lds	r25, 0x082E
    171e:	00 97       	sbiw	r24, 0x00	; 0
    1720:	09 f0       	breq	.+2      	; 0x1724 <prvCheckDelayedList+0x58>
    1722:	64 c0       	rjmp	.+200    	; 0x17ec <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    1724:	80 91 26 08 	lds	r24, 0x0826
    1728:	90 91 27 08 	lds	r25, 0x0827
    172c:	9a 83       	std	Y+2, r25	; 0x02
    172e:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1730:	80 91 28 08 	lds	r24, 0x0828
    1734:	90 91 29 08 	lds	r25, 0x0829
    1738:	90 93 27 08 	sts	0x0827, r25
    173c:	80 93 26 08 	sts	0x0826, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    1740:	89 81       	ldd	r24, Y+1	; 0x01
    1742:	9a 81       	ldd	r25, Y+2	; 0x02
    1744:	90 93 29 08 	sts	0x0829, r25
    1748:	80 93 28 08 	sts	0x0828, r24
    174c:	4f c0       	rjmp	.+158    	; 0x17ec <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    174e:	e0 91 26 08 	lds	r30, 0x0826
    1752:	f0 91 27 08 	lds	r31, 0x0827
    1756:	05 80       	ldd	r0, Z+5	; 0x05
    1758:	f6 81       	ldd	r31, Z+6	; 0x06
    175a:	e0 2d       	mov	r30, r0
    175c:	86 81       	ldd	r24, Z+6	; 0x06
    175e:	97 81       	ldd	r25, Z+7	; 0x07
    1760:	9c 83       	std	Y+4, r25	; 0x04
    1762:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1764:	eb 81       	ldd	r30, Y+3	; 0x03
    1766:	fc 81       	ldd	r31, Y+4	; 0x04
    1768:	22 81       	ldd	r18, Z+2	; 0x02
    176a:	33 81       	ldd	r19, Z+3	; 0x03
    176c:	80 91 2d 08 	lds	r24, 0x082D
    1770:	90 91 2e 08 	lds	r25, 0x082E
    1774:	82 17       	cp	r24, r18
    1776:	93 07       	cpc	r25, r19
    1778:	08 f4       	brcc	.+2      	; 0x177c <prvCheckDelayedList+0xb0>
    177a:	40 c0       	rjmp	.+128    	; 0x17fc <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    177c:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    177e:	8b 81       	ldd	r24, Y+3	; 0x03
    1780:	9c 81       	ldd	r25, Y+4	; 0x04
    1782:	02 96       	adiw	r24, 0x02	; 2
    1784:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    1788:	eb 81       	ldd	r30, Y+3	; 0x03
    178a:	fc 81       	ldd	r31, Y+4	; 0x04
    178c:	84 89       	ldd	r24, Z+20	; 0x14
    178e:	95 89       	ldd	r25, Z+21	; 0x15
    1790:	00 97       	sbiw	r24, 0x00	; 0
    1792:	29 f0       	breq	.+10     	; 0x179e <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1794:	8b 81       	ldd	r24, Y+3	; 0x03
    1796:	9c 81       	ldd	r25, Y+4	; 0x04
    1798:	0c 96       	adiw	r24, 0x0c	; 12
    179a:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    179e:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    17a0:	eb 81       	ldd	r30, Y+3	; 0x03
    17a2:	fc 81       	ldd	r31, Y+4	; 0x04
    17a4:	96 89       	ldd	r25, Z+22	; 0x16
    17a6:	80 91 2c 08 	lds	r24, 0x082C
    17aa:	89 17       	cp	r24, r25
    17ac:	28 f4       	brcc	.+10     	; 0x17b8 <prvCheckDelayedList+0xec>
    17ae:	eb 81       	ldd	r30, Y+3	; 0x03
    17b0:	fc 81       	ldd	r31, Y+4	; 0x04
    17b2:	86 89       	ldd	r24, Z+22	; 0x16
    17b4:	80 93 2c 08 	sts	0x082C, r24
    17b8:	eb 81       	ldd	r30, Y+3	; 0x03
    17ba:	fc 81       	ldd	r31, Y+4	; 0x04
    17bc:	86 89       	ldd	r24, Z+22	; 0x16
    17be:	28 2f       	mov	r18, r24
    17c0:	30 e0       	ldi	r19, 0x00	; 0
    17c2:	c9 01       	movw	r24, r18
    17c4:	88 0f       	add	r24, r24
    17c6:	99 1f       	adc	r25, r25
    17c8:	88 0f       	add	r24, r24
    17ca:	99 1f       	adc	r25, r25
    17cc:	88 0f       	add	r24, r24
    17ce:	99 1f       	adc	r25, r25
    17d0:	82 0f       	add	r24, r18
    17d2:	93 1f       	adc	r25, r19
    17d4:	ac 01       	movw	r20, r24
    17d6:	4d 5c       	subi	r20, 0xCD	; 205
    17d8:	57 4f       	sbci	r21, 0xF7	; 247
    17da:	8b 81       	ldd	r24, Y+3	; 0x03
    17dc:	9c 81       	ldd	r25, Y+4	; 0x04
    17de:	9c 01       	movw	r18, r24
    17e0:	2e 5f       	subi	r18, 0xFE	; 254
    17e2:	3f 4f       	sbci	r19, 0xFF	; 255
    17e4:	ca 01       	movw	r24, r20
    17e6:	b9 01       	movw	r22, r18
    17e8:	0e 94 85 10 	call	0x210a	; 0x210a <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    17ec:	e0 91 26 08 	lds	r30, 0x0826
    17f0:	f0 91 27 08 	lds	r31, 0x0827
    17f4:	80 81       	ld	r24, Z
    17f6:	88 23       	and	r24, r24
    17f8:	09 f0       	breq	.+2      	; 0x17fc <prvCheckDelayedList+0x130>
    17fa:	a9 cf       	rjmp	.-174    	; 0x174e <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    17fc:	80 91 31 08 	lds	r24, 0x0831
    1800:	90 91 32 08 	lds	r25, 0x0832
    1804:	00 97       	sbiw	r24, 0x00	; 0
    1806:	09 f0       	breq	.+2      	; 0x180a <prvCheckDelayedList+0x13e>
    1808:	74 cf       	rjmp	.-280    	; 0x16f2 <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    180a:	80 91 2d 08 	lds	r24, 0x082D
    180e:	90 91 2e 08 	lds	r25, 0x082E
    1812:	90 93 30 08 	sts	0x0830, r25
    1816:	80 93 2f 08 	sts	0x082F, r24
    }
    181a:	0f 90       	pop	r0
    181c:	0f 90       	pop	r0
    181e:	0f 90       	pop	r0
    1820:	0f 90       	pop	r0
    1822:	cf 91       	pop	r28
    1824:	df 91       	pop	r29
    1826:	08 95       	ret

00001828 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    1828:	df 93       	push	r29
    182a:	cf 93       	push	r28
    182c:	00 d0       	rcall	.+0      	; 0x182e <vCoRoutineSchedule+0x6>
    182e:	cd b7       	in	r28, 0x3d	; 61
    1830:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    1832:	80 91 26 08 	lds	r24, 0x0826
    1836:	90 91 27 08 	lds	r25, 0x0827
    183a:	00 97       	sbiw	r24, 0x00	; 0
    183c:	09 f4       	brne	.+2      	; 0x1840 <vCoRoutineSchedule+0x18>
    183e:	70 c0       	rjmp	.+224    	; 0x1920 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    1840:	0e 94 1c 0b 	call	0x1638	; 0x1638 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    1844:	0e 94 66 0b 	call	0x16cc	; 0x16cc <prvCheckDelayedList>
    1848:	0a c0       	rjmp	.+20     	; 0x185e <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    184a:	80 91 2c 08 	lds	r24, 0x082C
    184e:	88 23       	and	r24, r24
    1850:	09 f4       	brne	.+2      	; 0x1854 <vCoRoutineSchedule+0x2c>
    1852:	66 c0       	rjmp	.+204    	; 0x1920 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    1854:	80 91 2c 08 	lds	r24, 0x082C
    1858:	81 50       	subi	r24, 0x01	; 1
    185a:	80 93 2c 08 	sts	0x082C, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    185e:	80 91 2c 08 	lds	r24, 0x082C
    1862:	28 2f       	mov	r18, r24
    1864:	30 e0       	ldi	r19, 0x00	; 0
    1866:	c9 01       	movw	r24, r18
    1868:	88 0f       	add	r24, r24
    186a:	99 1f       	adc	r25, r25
    186c:	88 0f       	add	r24, r24
    186e:	99 1f       	adc	r25, r25
    1870:	88 0f       	add	r24, r24
    1872:	99 1f       	adc	r25, r25
    1874:	82 0f       	add	r24, r18
    1876:	93 1f       	adc	r25, r19
    1878:	fc 01       	movw	r30, r24
    187a:	ed 5c       	subi	r30, 0xCD	; 205
    187c:	f7 4f       	sbci	r31, 0xF7	; 247
    187e:	80 81       	ld	r24, Z
    1880:	88 23       	and	r24, r24
    1882:	19 f3       	breq	.-58     	; 0x184a <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1884:	80 91 2c 08 	lds	r24, 0x082C
    1888:	28 2f       	mov	r18, r24
    188a:	30 e0       	ldi	r19, 0x00	; 0
    188c:	c9 01       	movw	r24, r18
    188e:	88 0f       	add	r24, r24
    1890:	99 1f       	adc	r25, r25
    1892:	88 0f       	add	r24, r24
    1894:	99 1f       	adc	r25, r25
    1896:	88 0f       	add	r24, r24
    1898:	99 1f       	adc	r25, r25
    189a:	82 0f       	add	r24, r18
    189c:	93 1f       	adc	r25, r19
    189e:	8d 5c       	subi	r24, 0xCD	; 205
    18a0:	97 4f       	sbci	r25, 0xF7	; 247
    18a2:	9a 83       	std	Y+2, r25	; 0x02
    18a4:	89 83       	std	Y+1, r24	; 0x01
    18a6:	e9 81       	ldd	r30, Y+1	; 0x01
    18a8:	fa 81       	ldd	r31, Y+2	; 0x02
    18aa:	01 80       	ldd	r0, Z+1	; 0x01
    18ac:	f2 81       	ldd	r31, Z+2	; 0x02
    18ae:	e0 2d       	mov	r30, r0
    18b0:	82 81       	ldd	r24, Z+2	; 0x02
    18b2:	93 81       	ldd	r25, Z+3	; 0x03
    18b4:	e9 81       	ldd	r30, Y+1	; 0x01
    18b6:	fa 81       	ldd	r31, Y+2	; 0x02
    18b8:	92 83       	std	Z+2, r25	; 0x02
    18ba:	81 83       	std	Z+1, r24	; 0x01
    18bc:	e9 81       	ldd	r30, Y+1	; 0x01
    18be:	fa 81       	ldd	r31, Y+2	; 0x02
    18c0:	21 81       	ldd	r18, Z+1	; 0x01
    18c2:	32 81       	ldd	r19, Z+2	; 0x02
    18c4:	89 81       	ldd	r24, Y+1	; 0x01
    18c6:	9a 81       	ldd	r25, Y+2	; 0x02
    18c8:	03 96       	adiw	r24, 0x03	; 3
    18ca:	28 17       	cp	r18, r24
    18cc:	39 07       	cpc	r19, r25
    18ce:	59 f4       	brne	.+22     	; 0x18e6 <vCoRoutineSchedule+0xbe>
    18d0:	e9 81       	ldd	r30, Y+1	; 0x01
    18d2:	fa 81       	ldd	r31, Y+2	; 0x02
    18d4:	01 80       	ldd	r0, Z+1	; 0x01
    18d6:	f2 81       	ldd	r31, Z+2	; 0x02
    18d8:	e0 2d       	mov	r30, r0
    18da:	82 81       	ldd	r24, Z+2	; 0x02
    18dc:	93 81       	ldd	r25, Z+3	; 0x03
    18de:	e9 81       	ldd	r30, Y+1	; 0x01
    18e0:	fa 81       	ldd	r31, Y+2	; 0x02
    18e2:	92 83       	std	Z+2, r25	; 0x02
    18e4:	81 83       	std	Z+1, r24	; 0x01
    18e6:	e9 81       	ldd	r30, Y+1	; 0x01
    18e8:	fa 81       	ldd	r31, Y+2	; 0x02
    18ea:	01 80       	ldd	r0, Z+1	; 0x01
    18ec:	f2 81       	ldd	r31, Z+2	; 0x02
    18ee:	e0 2d       	mov	r30, r0
    18f0:	86 81       	ldd	r24, Z+6	; 0x06
    18f2:	97 81       	ldd	r25, Z+7	; 0x07
    18f4:	90 93 2b 08 	sts	0x082B, r25
    18f8:	80 93 2a 08 	sts	0x082A, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    18fc:	e0 91 2a 08 	lds	r30, 0x082A
    1900:	f0 91 2b 08 	lds	r31, 0x082B
    1904:	40 81       	ld	r20, Z
    1906:	51 81       	ldd	r21, Z+1	; 0x01
    1908:	80 91 2a 08 	lds	r24, 0x082A
    190c:	90 91 2b 08 	lds	r25, 0x082B
    1910:	e0 91 2a 08 	lds	r30, 0x082A
    1914:	f0 91 2b 08 	lds	r31, 0x082B
    1918:	27 89       	ldd	r18, Z+23	; 0x17
    191a:	62 2f       	mov	r22, r18
    191c:	fa 01       	movw	r30, r20
    191e:	09 95       	icall
        }
    }
    1920:	0f 90       	pop	r0
    1922:	0f 90       	pop	r0
    1924:	cf 91       	pop	r28
    1926:	df 91       	pop	r29
    1928:	08 95       	ret

0000192a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    192a:	df 93       	push	r29
    192c:	cf 93       	push	r28
    192e:	0f 92       	push	r0
    1930:	cd b7       	in	r28, 0x3d	; 61
    1932:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1934:	19 82       	std	Y+1, r1	; 0x01
    1936:	13 c0       	rjmp	.+38     	; 0x195e <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1938:	89 81       	ldd	r24, Y+1	; 0x01
    193a:	28 2f       	mov	r18, r24
    193c:	30 e0       	ldi	r19, 0x00	; 0
    193e:	c9 01       	movw	r24, r18
    1940:	88 0f       	add	r24, r24
    1942:	99 1f       	adc	r25, r25
    1944:	88 0f       	add	r24, r24
    1946:	99 1f       	adc	r25, r25
    1948:	88 0f       	add	r24, r24
    194a:	99 1f       	adc	r25, r25
    194c:	82 0f       	add	r24, r18
    194e:	93 1f       	adc	r25, r19
    1950:	8d 5c       	subi	r24, 0xCD	; 205
    1952:	97 4f       	sbci	r25, 0xF7	; 247
    1954:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1958:	89 81       	ldd	r24, Y+1	; 0x01
    195a:	8f 5f       	subi	r24, 0xFF	; 255
    195c:	89 83       	std	Y+1, r24	; 0x01
    195e:	89 81       	ldd	r24, Y+1	; 0x01
    1960:	82 30       	cpi	r24, 0x02	; 2
    1962:	50 f3       	brcs	.-44     	; 0x1938 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1964:	85 e4       	ldi	r24, 0x45	; 69
    1966:	98 e0       	ldi	r25, 0x08	; 8
    1968:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    196c:	8e e4       	ldi	r24, 0x4E	; 78
    196e:	98 e0       	ldi	r25, 0x08	; 8
    1970:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1974:	87 e5       	ldi	r24, 0x57	; 87
    1976:	98 e0       	ldi	r25, 0x08	; 8
    1978:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    197c:	85 e4       	ldi	r24, 0x45	; 69
    197e:	98 e0       	ldi	r25, 0x08	; 8
    1980:	90 93 27 08 	sts	0x0827, r25
    1984:	80 93 26 08 	sts	0x0826, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1988:	8e e4       	ldi	r24, 0x4E	; 78
    198a:	98 e0       	ldi	r25, 0x08	; 8
    198c:	90 93 29 08 	sts	0x0829, r25
    1990:	80 93 28 08 	sts	0x0828, r24
    }
    1994:	0f 90       	pop	r0
    1996:	cf 91       	pop	r28
    1998:	df 91       	pop	r29
    199a:	08 95       	ret

0000199c <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    199c:	df 93       	push	r29
    199e:	cf 93       	push	r28
    19a0:	00 d0       	rcall	.+0      	; 0x19a2 <xCoRoutineRemoveFromEventList+0x6>
    19a2:	00 d0       	rcall	.+0      	; 0x19a4 <xCoRoutineRemoveFromEventList+0x8>
    19a4:	0f 92       	push	r0
    19a6:	cd b7       	in	r28, 0x3d	; 61
    19a8:	de b7       	in	r29, 0x3e	; 62
    19aa:	9d 83       	std	Y+5, r25	; 0x05
    19ac:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    19ae:	ec 81       	ldd	r30, Y+4	; 0x04
    19b0:	fd 81       	ldd	r31, Y+5	; 0x05
    19b2:	05 80       	ldd	r0, Z+5	; 0x05
    19b4:	f6 81       	ldd	r31, Z+6	; 0x06
    19b6:	e0 2d       	mov	r30, r0
    19b8:	86 81       	ldd	r24, Z+6	; 0x06
    19ba:	97 81       	ldd	r25, Z+7	; 0x07
    19bc:	9b 83       	std	Y+3, r25	; 0x03
    19be:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    19c0:	8a 81       	ldd	r24, Y+2	; 0x02
    19c2:	9b 81       	ldd	r25, Y+3	; 0x03
    19c4:	0c 96       	adiw	r24, 0x0c	; 12
    19c6:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    19ca:	8a 81       	ldd	r24, Y+2	; 0x02
    19cc:	9b 81       	ldd	r25, Y+3	; 0x03
    19ce:	9c 01       	movw	r18, r24
    19d0:	24 5f       	subi	r18, 0xF4	; 244
    19d2:	3f 4f       	sbci	r19, 0xFF	; 255
    19d4:	87 e5       	ldi	r24, 0x57	; 87
    19d6:	98 e0       	ldi	r25, 0x08	; 8
    19d8:	b9 01       	movw	r22, r18
    19da:	0e 94 85 10 	call	0x210a	; 0x210a <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    19de:	ea 81       	ldd	r30, Y+2	; 0x02
    19e0:	fb 81       	ldd	r31, Y+3	; 0x03
    19e2:	96 89       	ldd	r25, Z+22	; 0x16
    19e4:	e0 91 2a 08 	lds	r30, 0x082A
    19e8:	f0 91 2b 08 	lds	r31, 0x082B
    19ec:	86 89       	ldd	r24, Z+22	; 0x16
    19ee:	98 17       	cp	r25, r24
    19f0:	18 f0       	brcs	.+6      	; 0x19f8 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	89 83       	std	Y+1, r24	; 0x01
    19f6:	01 c0       	rjmp	.+2      	; 0x19fa <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    19f8:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    19fa:	89 81       	ldd	r24, Y+1	; 0x01
    }
    19fc:	0f 90       	pop	r0
    19fe:	0f 90       	pop	r0
    1a00:	0f 90       	pop	r0
    1a02:	0f 90       	pop	r0
    1a04:	0f 90       	pop	r0
    1a06:	cf 91       	pop	r28
    1a08:	df 91       	pop	r29
    1a0a:	08 95       	ret

00001a0c <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1a0c:	df 93       	push	r29
    1a0e:	cf 93       	push	r28
    1a10:	00 d0       	rcall	.+0      	; 0x1a12 <xEventGroupCreate+0x6>
    1a12:	cd b7       	in	r28, 0x3d	; 61
    1a14:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1a16:	8b e0       	ldi	r24, 0x0B	; 11
    1a18:	90 e0       	ldi	r25, 0x00	; 0
    1a1a:	0e 94 d3 06 	call	0xda6	; 0xda6 <pvPortMalloc>
    1a1e:	9a 83       	std	Y+2, r25	; 0x02
    1a20:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    1a22:	89 81       	ldd	r24, Y+1	; 0x01
    1a24:	9a 81       	ldd	r25, Y+2	; 0x02
    1a26:	00 97       	sbiw	r24, 0x00	; 0
    1a28:	49 f0       	breq	.+18     	; 0x1a3c <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1a2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a2e:	11 82       	std	Z+1, r1	; 0x01
    1a30:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1a32:	89 81       	ldd	r24, Y+1	; 0x01
    1a34:	9a 81       	ldd	r25, Y+2	; 0x02
    1a36:	02 96       	adiw	r24, 0x02	; 2
    1a38:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1a3c:	89 81       	ldd	r24, Y+1	; 0x01
    1a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1a40:	0f 90       	pop	r0
    1a42:	0f 90       	pop	r0
    1a44:	cf 91       	pop	r28
    1a46:	df 91       	pop	r29
    1a48:	08 95       	ret

00001a4a <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1a4a:	df 93       	push	r29
    1a4c:	cf 93       	push	r28
    1a4e:	cd b7       	in	r28, 0x3d	; 61
    1a50:	de b7       	in	r29, 0x3e	; 62
    1a52:	60 97       	sbiw	r28, 0x10	; 16
    1a54:	0f b6       	in	r0, 0x3f	; 63
    1a56:	f8 94       	cli
    1a58:	de bf       	out	0x3e, r29	; 62
    1a5a:	0f be       	out	0x3f, r0	; 63
    1a5c:	cd bf       	out	0x3d, r28	; 61
    1a5e:	9a 87       	std	Y+10, r25	; 0x0a
    1a60:	89 87       	std	Y+9, r24	; 0x09
    1a62:	7c 87       	std	Y+12, r23	; 0x0c
    1a64:	6b 87       	std	Y+11, r22	; 0x0b
    1a66:	5e 87       	std	Y+14, r21	; 0x0e
    1a68:	4d 87       	std	Y+13, r20	; 0x0d
    1a6a:	38 8b       	std	Y+16, r19	; 0x10
    1a6c:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    1a6e:	89 85       	ldd	r24, Y+9	; 0x09
    1a70:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a72:	9c 83       	std	Y+4, r25	; 0x04
    1a74:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1a76:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1a78:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a80:	80 81       	ld	r24, Z
    1a82:	91 81       	ldd	r25, Z+1	; 0x01
    1a84:	98 87       	std	Y+8, r25	; 0x08
    1a86:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1a88:	89 85       	ldd	r24, Y+9	; 0x09
    1a8a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a8c:	2b 85       	ldd	r18, Y+11	; 0x0b
    1a8e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1a90:	b9 01       	movw	r22, r18
    1a92:	0e 94 fc 0e 	call	0x1df8	; 0x1df8 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1a96:	2f 81       	ldd	r18, Y+7	; 0x07
    1a98:	38 85       	ldd	r19, Y+8	; 0x08
    1a9a:	8b 85       	ldd	r24, Y+11	; 0x0b
    1a9c:	9c 85       	ldd	r25, Y+12	; 0x0c
    1a9e:	28 2b       	or	r18, r24
    1aa0:	39 2b       	or	r19, r25
    1aa2:	8d 85       	ldd	r24, Y+13	; 0x0d
    1aa4:	9e 85       	ldd	r25, Y+14	; 0x0e
    1aa6:	28 23       	and	r18, r24
    1aa8:	39 23       	and	r19, r25
    1aaa:	8d 85       	ldd	r24, Y+13	; 0x0d
    1aac:	9e 85       	ldd	r25, Y+14	; 0x0e
    1aae:	28 17       	cp	r18, r24
    1ab0:	39 07       	cpc	r19, r25
    1ab2:	c9 f4       	brne	.+50     	; 0x1ae6 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1ab4:	2f 81       	ldd	r18, Y+7	; 0x07
    1ab6:	38 85       	ldd	r19, Y+8	; 0x08
    1ab8:	8b 85       	ldd	r24, Y+11	; 0x0b
    1aba:	9c 85       	ldd	r25, Y+12	; 0x0c
    1abc:	82 2b       	or	r24, r18
    1abe:	93 2b       	or	r25, r19
    1ac0:	9e 83       	std	Y+6, r25	; 0x06
    1ac2:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1ac4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ac6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ac8:	20 81       	ld	r18, Z
    1aca:	31 81       	ldd	r19, Z+1	; 0x01
    1acc:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ace:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ad0:	80 95       	com	r24
    1ad2:	90 95       	com	r25
    1ad4:	82 23       	and	r24, r18
    1ad6:	93 23       	and	r25, r19
    1ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    1ada:	fc 81       	ldd	r31, Y+4	; 0x04
    1adc:	91 83       	std	Z+1, r25	; 0x01
    1ade:	80 83       	st	Z, r24

            xTicksToWait = 0;
    1ae0:	18 8a       	std	Y+16, r1	; 0x10
    1ae2:	1f 86       	std	Y+15, r1	; 0x0f
    1ae4:	1e c0       	rjmp	.+60     	; 0x1b22 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1ae6:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ae8:	98 89       	ldd	r25, Y+16	; 0x10
    1aea:	00 97       	sbiw	r24, 0x00	; 0
    1aec:	91 f0       	breq	.+36     	; 0x1b12 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1aee:	8b 81       	ldd	r24, Y+3	; 0x03
    1af0:	9c 81       	ldd	r25, Y+4	; 0x04
    1af2:	bc 01       	movw	r22, r24
    1af4:	6e 5f       	subi	r22, 0xFE	; 254
    1af6:	7f 4f       	sbci	r23, 0xFF	; 255
    1af8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1afa:	9e 85       	ldd	r25, Y+14	; 0x0e
    1afc:	9c 01       	movw	r18, r24
    1afe:	35 60       	ori	r19, 0x05	; 5
    1b00:	4f 85       	ldd	r20, Y+15	; 0x0f
    1b02:	58 89       	ldd	r21, Y+16	; 0x10
    1b04:	cb 01       	movw	r24, r22
    1b06:	b9 01       	movw	r22, r18
    1b08:	0e 94 27 22 	call	0x444e	; 0x444e <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1b0c:	1e 82       	std	Y+6, r1	; 0x06
    1b0e:	1d 82       	std	Y+5, r1	; 0x05
    1b10:	08 c0       	rjmp	.+16     	; 0x1b22 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1b12:	eb 81       	ldd	r30, Y+3	; 0x03
    1b14:	fc 81       	ldd	r31, Y+4	; 0x04
    1b16:	80 81       	ld	r24, Z
    1b18:	91 81       	ldd	r25, Z+1	; 0x01
    1b1a:	9e 83       	std	Y+6, r25	; 0x06
    1b1c:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1b1e:	81 e0       	ldi	r24, 0x01	; 1
    1b20:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1b22:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    1b26:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1b28:	8f 85       	ldd	r24, Y+15	; 0x0f
    1b2a:	98 89       	ldd	r25, Y+16	; 0x10
    1b2c:	00 97       	sbiw	r24, 0x00	; 0
    1b2e:	09 f4       	brne	.+2      	; 0x1b32 <xEventGroupSync+0xe8>
    1b30:	3a c0       	rjmp	.+116    	; 0x1ba6 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    1b32:	8a 81       	ldd	r24, Y+2	; 0x02
    1b34:	88 23       	and	r24, r24
    1b36:	11 f4       	brne	.+4      	; 0x1b3c <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1b38:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1b3c:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <uxTaskResetEventItemValue>
    1b40:	9e 83       	std	Y+6, r25	; 0x06
    1b42:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1b44:	8d 81       	ldd	r24, Y+5	; 0x05
    1b46:	9e 81       	ldd	r25, Y+6	; 0x06
    1b48:	80 70       	andi	r24, 0x00	; 0
    1b4a:	92 70       	andi	r25, 0x02	; 2
    1b4c:	00 97       	sbiw	r24, 0x00	; 0
    1b4e:	31 f5       	brne	.+76     	; 0x1b9c <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    1b50:	0f b6       	in	r0, 0x3f	; 63
    1b52:	f8 94       	cli
    1b54:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    1b56:	eb 81       	ldd	r30, Y+3	; 0x03
    1b58:	fc 81       	ldd	r31, Y+4	; 0x04
    1b5a:	80 81       	ld	r24, Z
    1b5c:	91 81       	ldd	r25, Z+1	; 0x01
    1b5e:	9e 83       	std	Y+6, r25	; 0x06
    1b60:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1b62:	2d 81       	ldd	r18, Y+5	; 0x05
    1b64:	3e 81       	ldd	r19, Y+6	; 0x06
    1b66:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b68:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b6a:	28 23       	and	r18, r24
    1b6c:	39 23       	and	r19, r25
    1b6e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b70:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b72:	28 17       	cp	r18, r24
    1b74:	39 07       	cpc	r19, r25
    1b76:	71 f4       	brne	.+28     	; 0x1b94 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1b78:	eb 81       	ldd	r30, Y+3	; 0x03
    1b7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b7c:	20 81       	ld	r18, Z
    1b7e:	31 81       	ldd	r19, Z+1	; 0x01
    1b80:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b82:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b84:	80 95       	com	r24
    1b86:	90 95       	com	r25
    1b88:	82 23       	and	r24, r18
    1b8a:	93 23       	and	r25, r19
    1b8c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b8e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b90:	91 83       	std	Z+1, r25	; 0x01
    1b92:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    1b94:	0f 90       	pop	r0
    1b96:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    1b98:	81 e0       	ldi	r24, 0x01	; 1
    1b9a:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1b9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b9e:	9e 81       	ldd	r25, Y+6	; 0x06
    1ba0:	90 70       	andi	r25, 0x00	; 0
    1ba2:	9e 83       	std	Y+6, r25	; 0x06
    1ba4:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1ba6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ba8:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1baa:	60 96       	adiw	r28, 0x10	; 16
    1bac:	0f b6       	in	r0, 0x3f	; 63
    1bae:	f8 94       	cli
    1bb0:	de bf       	out	0x3e, r29	; 62
    1bb2:	0f be       	out	0x3f, r0	; 63
    1bb4:	cd bf       	out	0x3d, r28	; 61
    1bb6:	cf 91       	pop	r28
    1bb8:	df 91       	pop	r29
    1bba:	08 95       	ret

00001bbc <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1bbc:	0f 93       	push	r16
    1bbe:	1f 93       	push	r17
    1bc0:	df 93       	push	r29
    1bc2:	cf 93       	push	r28
    1bc4:	cd b7       	in	r28, 0x3d	; 61
    1bc6:	de b7       	in	r29, 0x3e	; 62
    1bc8:	63 97       	sbiw	r28, 0x13	; 19
    1bca:	0f b6       	in	r0, 0x3f	; 63
    1bcc:	f8 94       	cli
    1bce:	de bf       	out	0x3e, r29	; 62
    1bd0:	0f be       	out	0x3f, r0	; 63
    1bd2:	cd bf       	out	0x3d, r28	; 61
    1bd4:	9d 87       	std	Y+13, r25	; 0x0d
    1bd6:	8c 87       	std	Y+12, r24	; 0x0c
    1bd8:	7f 87       	std	Y+15, r23	; 0x0f
    1bda:	6e 87       	std	Y+14, r22	; 0x0e
    1bdc:	48 8b       	std	Y+16, r20	; 0x10
    1bde:	29 8b       	std	Y+17, r18	; 0x11
    1be0:	1b 8b       	std	Y+19, r17	; 0x13
    1be2:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    1be4:	8c 85       	ldd	r24, Y+12	; 0x0c
    1be6:	9d 85       	ldd	r25, Y+13	; 0x0d
    1be8:	9b 87       	std	Y+11, r25	; 0x0b
    1bea:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1bec:	1f 82       	std	Y+7, r1	; 0x07
    1bee:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1bf0:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1bf2:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1bf6:	ea 85       	ldd	r30, Y+10	; 0x0a
    1bf8:	fb 85       	ldd	r31, Y+11	; 0x0b
    1bfa:	80 81       	ld	r24, Z
    1bfc:	91 81       	ldd	r25, Z+1	; 0x01
    1bfe:	9a 83       	std	Y+2, r25	; 0x02
    1c00:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1c02:	89 81       	ldd	r24, Y+1	; 0x01
    1c04:	9a 81       	ldd	r25, Y+2	; 0x02
    1c06:	2e 85       	ldd	r18, Y+14	; 0x0e
    1c08:	3f 85       	ldd	r19, Y+15	; 0x0f
    1c0a:	b9 01       	movw	r22, r18
    1c0c:	49 89       	ldd	r20, Y+17	; 0x11
    1c0e:	0e 94 19 10 	call	0x2032	; 0x2032 <prvTestWaitCondition>
    1c12:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    1c14:	8d 81       	ldd	r24, Y+5	; 0x05
    1c16:	88 23       	and	r24, r24
    1c18:	c1 f0       	breq	.+48     	; 0x1c4a <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1c1a:	89 81       	ldd	r24, Y+1	; 0x01
    1c1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c1e:	99 87       	std	Y+9, r25	; 0x09
    1c20:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    1c22:	1b 8a       	std	Y+19, r1	; 0x13
    1c24:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1c26:	88 89       	ldd	r24, Y+16	; 0x10
    1c28:	88 23       	and	r24, r24
    1c2a:	e9 f1       	breq	.+122    	; 0x1ca6 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1c2c:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c2e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c30:	20 81       	ld	r18, Z
    1c32:	31 81       	ldd	r19, Z+1	; 0x01
    1c34:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c36:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c38:	80 95       	com	r24
    1c3a:	90 95       	com	r25
    1c3c:	82 23       	and	r24, r18
    1c3e:	93 23       	and	r25, r19
    1c40:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c42:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c44:	91 83       	std	Z+1, r25	; 0x01
    1c46:	80 83       	st	Z, r24
    1c48:	2e c0       	rjmp	.+92     	; 0x1ca6 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1c4a:	8a 89       	ldd	r24, Y+18	; 0x12
    1c4c:	9b 89       	ldd	r25, Y+19	; 0x13
    1c4e:	00 97       	sbiw	r24, 0x00	; 0
    1c50:	39 f4       	brne	.+14     	; 0x1c60 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    1c52:	89 81       	ldd	r24, Y+1	; 0x01
    1c54:	9a 81       	ldd	r25, Y+2	; 0x02
    1c56:	99 87       	std	Y+9, r25	; 0x09
    1c58:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    1c5a:	81 e0       	ldi	r24, 0x01	; 1
    1c5c:	8b 83       	std	Y+3, r24	; 0x03
    1c5e:	23 c0       	rjmp	.+70     	; 0x1ca6 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    1c60:	88 89       	ldd	r24, Y+16	; 0x10
    1c62:	88 23       	and	r24, r24
    1c64:	29 f0       	breq	.+10     	; 0x1c70 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1c66:	8e 81       	ldd	r24, Y+6	; 0x06
    1c68:	9f 81       	ldd	r25, Y+7	; 0x07
    1c6a:	91 60       	ori	r25, 0x01	; 1
    1c6c:	9f 83       	std	Y+7, r25	; 0x07
    1c6e:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    1c70:	89 89       	ldd	r24, Y+17	; 0x11
    1c72:	88 23       	and	r24, r24
    1c74:	29 f0       	breq	.+10     	; 0x1c80 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1c76:	8e 81       	ldd	r24, Y+6	; 0x06
    1c78:	9f 81       	ldd	r25, Y+7	; 0x07
    1c7a:	94 60       	ori	r25, 0x04	; 4
    1c7c:	9f 83       	std	Y+7, r25	; 0x07
    1c7e:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1c80:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c82:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c84:	bc 01       	movw	r22, r24
    1c86:	6e 5f       	subi	r22, 0xFE	; 254
    1c88:	7f 4f       	sbci	r23, 0xFF	; 255
    1c8a:	2e 85       	ldd	r18, Y+14	; 0x0e
    1c8c:	3f 85       	ldd	r19, Y+15	; 0x0f
    1c8e:	8e 81       	ldd	r24, Y+6	; 0x06
    1c90:	9f 81       	ldd	r25, Y+7	; 0x07
    1c92:	28 2b       	or	r18, r24
    1c94:	39 2b       	or	r19, r25
    1c96:	4a 89       	ldd	r20, Y+18	; 0x12
    1c98:	5b 89       	ldd	r21, Y+19	; 0x13
    1c9a:	cb 01       	movw	r24, r22
    1c9c:	b9 01       	movw	r22, r18
    1c9e:	0e 94 27 22 	call	0x444e	; 0x444e <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    1ca2:	19 86       	std	Y+9, r1	; 0x09
    1ca4:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1ca6:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    1caa:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1cac:	8a 89       	ldd	r24, Y+18	; 0x12
    1cae:	9b 89       	ldd	r25, Y+19	; 0x13
    1cb0:	00 97       	sbiw	r24, 0x00	; 0
    1cb2:	09 f4       	brne	.+2      	; 0x1cb6 <xEventGroupWaitBits+0xfa>
    1cb4:	3c c0       	rjmp	.+120    	; 0x1d2e <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    1cb6:	8c 81       	ldd	r24, Y+4	; 0x04
    1cb8:	88 23       	and	r24, r24
    1cba:	11 f4       	brne	.+4      	; 0x1cc0 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1cbc:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1cc0:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <uxTaskResetEventItemValue>
    1cc4:	99 87       	std	Y+9, r25	; 0x09
    1cc6:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1cc8:	88 85       	ldd	r24, Y+8	; 0x08
    1cca:	99 85       	ldd	r25, Y+9	; 0x09
    1ccc:	80 70       	andi	r24, 0x00	; 0
    1cce:	92 70       	andi	r25, 0x02	; 2
    1cd0:	00 97       	sbiw	r24, 0x00	; 0
    1cd2:	41 f5       	brne	.+80     	; 0x1d24 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	f8 94       	cli
    1cd8:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1cda:	ea 85       	ldd	r30, Y+10	; 0x0a
    1cdc:	fb 85       	ldd	r31, Y+11	; 0x0b
    1cde:	80 81       	ld	r24, Z
    1ce0:	91 81       	ldd	r25, Z+1	; 0x01
    1ce2:	99 87       	std	Y+9, r25	; 0x09
    1ce4:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1ce6:	88 85       	ldd	r24, Y+8	; 0x08
    1ce8:	99 85       	ldd	r25, Y+9	; 0x09
    1cea:	2e 85       	ldd	r18, Y+14	; 0x0e
    1cec:	3f 85       	ldd	r19, Y+15	; 0x0f
    1cee:	b9 01       	movw	r22, r18
    1cf0:	49 89       	ldd	r20, Y+17	; 0x11
    1cf2:	0e 94 19 10 	call	0x2032	; 0x2032 <prvTestWaitCondition>
    1cf6:	88 23       	and	r24, r24
    1cf8:	89 f0       	breq	.+34     	; 0x1d1c <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1cfa:	88 89       	ldd	r24, Y+16	; 0x10
    1cfc:	88 23       	and	r24, r24
    1cfe:	71 f0       	breq	.+28     	; 0x1d1c <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1d00:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d02:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d04:	20 81       	ld	r18, Z
    1d06:	31 81       	ldd	r19, Z+1	; 0x01
    1d08:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d0a:	9f 85       	ldd	r25, Y+15	; 0x0f
    1d0c:	80 95       	com	r24
    1d0e:	90 95       	com	r25
    1d10:	82 23       	and	r24, r18
    1d12:	93 23       	and	r25, r19
    1d14:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d16:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d18:	91 83       	std	Z+1, r25	; 0x01
    1d1a:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1d1c:	81 e0       	ldi	r24, 0x01	; 1
    1d1e:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    1d20:	0f 90       	pop	r0
    1d22:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1d24:	88 85       	ldd	r24, Y+8	; 0x08
    1d26:	99 85       	ldd	r25, Y+9	; 0x09
    1d28:	90 70       	andi	r25, 0x00	; 0
    1d2a:	99 87       	std	Y+9, r25	; 0x09
    1d2c:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1d2e:	88 85       	ldd	r24, Y+8	; 0x08
    1d30:	99 85       	ldd	r25, Y+9	; 0x09
}
    1d32:	63 96       	adiw	r28, 0x13	; 19
    1d34:	0f b6       	in	r0, 0x3f	; 63
    1d36:	f8 94       	cli
    1d38:	de bf       	out	0x3e, r29	; 62
    1d3a:	0f be       	out	0x3f, r0	; 63
    1d3c:	cd bf       	out	0x3d, r28	; 61
    1d3e:	cf 91       	pop	r28
    1d40:	df 91       	pop	r29
    1d42:	1f 91       	pop	r17
    1d44:	0f 91       	pop	r16
    1d46:	08 95       	ret

00001d48 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1d48:	df 93       	push	r29
    1d4a:	cf 93       	push	r28
    1d4c:	cd b7       	in	r28, 0x3d	; 61
    1d4e:	de b7       	in	r29, 0x3e	; 62
    1d50:	28 97       	sbiw	r28, 0x08	; 8
    1d52:	0f b6       	in	r0, 0x3f	; 63
    1d54:	f8 94       	cli
    1d56:	de bf       	out	0x3e, r29	; 62
    1d58:	0f be       	out	0x3f, r0	; 63
    1d5a:	cd bf       	out	0x3d, r28	; 61
    1d5c:	9e 83       	std	Y+6, r25	; 0x06
    1d5e:	8d 83       	std	Y+5, r24	; 0x05
    1d60:	78 87       	std	Y+8, r23	; 0x08
    1d62:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    1d64:	8d 81       	ldd	r24, Y+5	; 0x05
    1d66:	9e 81       	ldd	r25, Y+6	; 0x06
    1d68:	9c 83       	std	Y+4, r25	; 0x04
    1d6a:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1d6c:	0f b6       	in	r0, 0x3f	; 63
    1d6e:	f8 94       	cli
    1d70:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    1d72:	eb 81       	ldd	r30, Y+3	; 0x03
    1d74:	fc 81       	ldd	r31, Y+4	; 0x04
    1d76:	80 81       	ld	r24, Z
    1d78:	91 81       	ldd	r25, Z+1	; 0x01
    1d7a:	9a 83       	std	Y+2, r25	; 0x02
    1d7c:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1d7e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d80:	fc 81       	ldd	r31, Y+4	; 0x04
    1d82:	20 81       	ld	r18, Z
    1d84:	31 81       	ldd	r19, Z+1	; 0x01
    1d86:	8f 81       	ldd	r24, Y+7	; 0x07
    1d88:	98 85       	ldd	r25, Y+8	; 0x08
    1d8a:	80 95       	com	r24
    1d8c:	90 95       	com	r25
    1d8e:	82 23       	and	r24, r18
    1d90:	93 23       	and	r25, r19
    1d92:	eb 81       	ldd	r30, Y+3	; 0x03
    1d94:	fc 81       	ldd	r31, Y+4	; 0x04
    1d96:	91 83       	std	Z+1, r25	; 0x01
    1d98:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    1d9a:	0f 90       	pop	r0
    1d9c:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1d9e:	89 81       	ldd	r24, Y+1	; 0x01
    1da0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1da2:	28 96       	adiw	r28, 0x08	; 8
    1da4:	0f b6       	in	r0, 0x3f	; 63
    1da6:	f8 94       	cli
    1da8:	de bf       	out	0x3e, r29	; 62
    1daa:	0f be       	out	0x3f, r0	; 63
    1dac:	cd bf       	out	0x3d, r28	; 61
    1dae:	cf 91       	pop	r28
    1db0:	df 91       	pop	r29
    1db2:	08 95       	ret

00001db4 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1db4:	df 93       	push	r29
    1db6:	cf 93       	push	r28
    1db8:	cd b7       	in	r28, 0x3d	; 61
    1dba:	de b7       	in	r29, 0x3e	; 62
    1dbc:	27 97       	sbiw	r28, 0x07	; 7
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	de bf       	out	0x3e, r29	; 62
    1dc4:	0f be       	out	0x3f, r0	; 63
    1dc6:	cd bf       	out	0x3d, r28	; 61
    1dc8:	9f 83       	std	Y+7, r25	; 0x07
    1dca:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1dcc:	8e 81       	ldd	r24, Y+6	; 0x06
    1dce:	9f 81       	ldd	r25, Y+7	; 0x07
    1dd0:	9c 83       	std	Y+4, r25	; 0x04
    1dd2:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1dd4:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1dd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dda:	80 81       	ld	r24, Z
    1ddc:	91 81       	ldd	r25, Z+1	; 0x01
    1dde:	9a 83       	std	Y+2, r25	; 0x02
    1de0:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    1de2:	89 81       	ldd	r24, Y+1	; 0x01
    1de4:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1de6:	27 96       	adiw	r28, 0x07	; 7
    1de8:	0f b6       	in	r0, 0x3f	; 63
    1dea:	f8 94       	cli
    1dec:	de bf       	out	0x3e, r29	; 62
    1dee:	0f be       	out	0x3f, r0	; 63
    1df0:	cd bf       	out	0x3d, r28	; 61
    1df2:	cf 91       	pop	r28
    1df4:	df 91       	pop	r29
    1df6:	08 95       	ret

00001df8 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1df8:	df 93       	push	r29
    1dfa:	cf 93       	push	r28
    1dfc:	cd b7       	in	r28, 0x3d	; 61
    1dfe:	de b7       	in	r29, 0x3e	; 62
    1e00:	65 97       	sbiw	r28, 0x15	; 21
    1e02:	0f b6       	in	r0, 0x3f	; 63
    1e04:	f8 94       	cli
    1e06:	de bf       	out	0x3e, r29	; 62
    1e08:	0f be       	out	0x3f, r0	; 63
    1e0a:	cd bf       	out	0x3d, r28	; 61
    1e0c:	9b 8b       	std	Y+19, r25	; 0x13
    1e0e:	8a 8b       	std	Y+18, r24	; 0x12
    1e10:	7d 8b       	std	Y+21, r23	; 0x15
    1e12:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1e14:	19 86       	std	Y+9, r1	; 0x09
    1e16:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1e18:	8a 89       	ldd	r24, Y+18	; 0x12
    1e1a:	9b 89       	ldd	r25, Y+19	; 0x13
    1e1c:	9b 83       	std	Y+3, r25	; 0x03
    1e1e:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    1e20:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    1e22:	8a 81       	ldd	r24, Y+2	; 0x02
    1e24:	9b 81       	ldd	r25, Y+3	; 0x03
    1e26:	02 96       	adiw	r24, 0x02	; 2
    1e28:	9b 87       	std	Y+11, r25	; 0x0b
    1e2a:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e2c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e2e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e30:	03 96       	adiw	r24, 0x03	; 3
    1e32:	9d 87       	std	Y+13, r25	; 0x0d
    1e34:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1e36:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1e3a:	ea 85       	ldd	r30, Y+10	; 0x0a
    1e3c:	fb 85       	ldd	r31, Y+11	; 0x0b
    1e3e:	85 81       	ldd	r24, Z+5	; 0x05
    1e40:	96 81       	ldd	r25, Z+6	; 0x06
    1e42:	99 8b       	std	Y+17, r25	; 0x11
    1e44:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1e46:	ea 81       	ldd	r30, Y+2	; 0x02
    1e48:	fb 81       	ldd	r31, Y+3	; 0x03
    1e4a:	20 81       	ld	r18, Z
    1e4c:	31 81       	ldd	r19, Z+1	; 0x01
    1e4e:	8c 89       	ldd	r24, Y+20	; 0x14
    1e50:	9d 89       	ldd	r25, Y+21	; 0x15
    1e52:	82 2b       	or	r24, r18
    1e54:	93 2b       	or	r25, r19
    1e56:	ea 81       	ldd	r30, Y+2	; 0x02
    1e58:	fb 81       	ldd	r31, Y+3	; 0x03
    1e5a:	91 83       	std	Z+1, r25	; 0x01
    1e5c:	80 83       	st	Z, r24
    1e5e:	59 c0       	rjmp	.+178    	; 0x1f12 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1e60:	e8 89       	ldd	r30, Y+16	; 0x10
    1e62:	f9 89       	ldd	r31, Y+17	; 0x11
    1e64:	82 81       	ldd	r24, Z+2	; 0x02
    1e66:	93 81       	ldd	r25, Z+3	; 0x03
    1e68:	9f 87       	std	Y+15, r25	; 0x0f
    1e6a:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1e6c:	e8 89       	ldd	r30, Y+16	; 0x10
    1e6e:	f9 89       	ldd	r31, Y+17	; 0x11
    1e70:	80 81       	ld	r24, Z
    1e72:	91 81       	ldd	r25, Z+1	; 0x01
    1e74:	9f 83       	std	Y+7, r25	; 0x07
    1e76:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    1e78:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1e7a:	8e 81       	ldd	r24, Y+6	; 0x06
    1e7c:	9f 81       	ldd	r25, Y+7	; 0x07
    1e7e:	80 70       	andi	r24, 0x00	; 0
    1e80:	9d 83       	std	Y+5, r25	; 0x05
    1e82:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1e84:	8e 81       	ldd	r24, Y+6	; 0x06
    1e86:	9f 81       	ldd	r25, Y+7	; 0x07
    1e88:	90 70       	andi	r25, 0x00	; 0
    1e8a:	9f 83       	std	Y+7, r25	; 0x07
    1e8c:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1e8e:	8c 81       	ldd	r24, Y+4	; 0x04
    1e90:	9d 81       	ldd	r25, Y+5	; 0x05
    1e92:	80 70       	andi	r24, 0x00	; 0
    1e94:	94 70       	andi	r25, 0x04	; 4
    1e96:	00 97       	sbiw	r24, 0x00	; 0
    1e98:	69 f4       	brne	.+26     	; 0x1eb4 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1e9a:	ea 81       	ldd	r30, Y+2	; 0x02
    1e9c:	fb 81       	ldd	r31, Y+3	; 0x03
    1e9e:	20 81       	ld	r18, Z
    1ea0:	31 81       	ldd	r19, Z+1	; 0x01
    1ea2:	8e 81       	ldd	r24, Y+6	; 0x06
    1ea4:	9f 81       	ldd	r25, Y+7	; 0x07
    1ea6:	82 23       	and	r24, r18
    1ea8:	93 23       	and	r25, r19
    1eaa:	00 97       	sbiw	r24, 0x00	; 0
    1eac:	91 f0       	breq	.+36     	; 0x1ed2 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	89 83       	std	Y+1, r24	; 0x01
    1eb2:	0f c0       	rjmp	.+30     	; 0x1ed2 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1eb4:	ea 81       	ldd	r30, Y+2	; 0x02
    1eb6:	fb 81       	ldd	r31, Y+3	; 0x03
    1eb8:	20 81       	ld	r18, Z
    1eba:	31 81       	ldd	r19, Z+1	; 0x01
    1ebc:	8e 81       	ldd	r24, Y+6	; 0x06
    1ebe:	9f 81       	ldd	r25, Y+7	; 0x07
    1ec0:	28 23       	and	r18, r24
    1ec2:	39 23       	and	r19, r25
    1ec4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ec6:	9f 81       	ldd	r25, Y+7	; 0x07
    1ec8:	28 17       	cp	r18, r24
    1eca:	39 07       	cpc	r19, r25
    1ecc:	11 f4       	brne	.+4      	; 0x1ed2 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1ece:	81 e0       	ldi	r24, 0x01	; 1
    1ed0:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    1ed2:	89 81       	ldd	r24, Y+1	; 0x01
    1ed4:	88 23       	and	r24, r24
    1ed6:	c9 f0       	breq	.+50     	; 0x1f0a <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1ed8:	8c 81       	ldd	r24, Y+4	; 0x04
    1eda:	9d 81       	ldd	r25, Y+5	; 0x05
    1edc:	80 70       	andi	r24, 0x00	; 0
    1ede:	91 70       	andi	r25, 0x01	; 1
    1ee0:	00 97       	sbiw	r24, 0x00	; 0
    1ee2:	41 f0       	breq	.+16     	; 0x1ef4 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1ee4:	88 85       	ldd	r24, Y+8	; 0x08
    1ee6:	99 85       	ldd	r25, Y+9	; 0x09
    1ee8:	2e 81       	ldd	r18, Y+6	; 0x06
    1eea:	3f 81       	ldd	r19, Y+7	; 0x07
    1eec:	82 2b       	or	r24, r18
    1eee:	93 2b       	or	r25, r19
    1ef0:	99 87       	std	Y+9, r25	; 0x09
    1ef2:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1ef4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ef6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ef8:	80 81       	ld	r24, Z
    1efa:	91 81       	ldd	r25, Z+1	; 0x01
    1efc:	9c 01       	movw	r18, r24
    1efe:	32 60       	ori	r19, 0x02	; 2
    1f00:	88 89       	ldd	r24, Y+16	; 0x10
    1f02:	99 89       	ldd	r25, Y+17	; 0x11
    1f04:	b9 01       	movw	r22, r18
    1f06:	0e 94 32 24 	call	0x4864	; 0x4864 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1f0a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f0c:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f0e:	99 8b       	std	Y+17, r25	; 0x11
    1f10:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    1f12:	28 89       	ldd	r18, Y+16	; 0x10
    1f14:	39 89       	ldd	r19, Y+17	; 0x11
    1f16:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f18:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f1a:	28 17       	cp	r18, r24
    1f1c:	39 07       	cpc	r19, r25
    1f1e:	09 f0       	breq	.+2      	; 0x1f22 <xEventGroupSetBits+0x12a>
    1f20:	9f cf       	rjmp	.-194    	; 0x1e60 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1f22:	ea 81       	ldd	r30, Y+2	; 0x02
    1f24:	fb 81       	ldd	r31, Y+3	; 0x03
    1f26:	20 81       	ld	r18, Z
    1f28:	31 81       	ldd	r19, Z+1	; 0x01
    1f2a:	88 85       	ldd	r24, Y+8	; 0x08
    1f2c:	99 85       	ldd	r25, Y+9	; 0x09
    1f2e:	80 95       	com	r24
    1f30:	90 95       	com	r25
    1f32:	82 23       	and	r24, r18
    1f34:	93 23       	and	r25, r19
    1f36:	ea 81       	ldd	r30, Y+2	; 0x02
    1f38:	fb 81       	ldd	r31, Y+3	; 0x03
    1f3a:	91 83       	std	Z+1, r25	; 0x01
    1f3c:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1f3e:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    1f42:	ea 81       	ldd	r30, Y+2	; 0x02
    1f44:	fb 81       	ldd	r31, Y+3	; 0x03
    1f46:	80 81       	ld	r24, Z
    1f48:	91 81       	ldd	r25, Z+1	; 0x01
}
    1f4a:	65 96       	adiw	r28, 0x15	; 21
    1f4c:	0f b6       	in	r0, 0x3f	; 63
    1f4e:	f8 94       	cli
    1f50:	de bf       	out	0x3e, r29	; 62
    1f52:	0f be       	out	0x3f, r0	; 63
    1f54:	cd bf       	out	0x3d, r28	; 61
    1f56:	cf 91       	pop	r28
    1f58:	df 91       	pop	r29
    1f5a:	08 95       	ret

00001f5c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1f5c:	df 93       	push	r29
    1f5e:	cf 93       	push	r28
    1f60:	00 d0       	rcall	.+0      	; 0x1f62 <vEventGroupDelete+0x6>
    1f62:	00 d0       	rcall	.+0      	; 0x1f64 <vEventGroupDelete+0x8>
    1f64:	00 d0       	rcall	.+0      	; 0x1f66 <vEventGroupDelete+0xa>
    1f66:	cd b7       	in	r28, 0x3d	; 61
    1f68:	de b7       	in	r29, 0x3e	; 62
    1f6a:	9e 83       	std	Y+6, r25	; 0x06
    1f6c:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    1f6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f70:	9e 81       	ldd	r25, Y+6	; 0x06
    1f72:	9c 83       	std	Y+4, r25	; 0x04
    1f74:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1f76:	8b 81       	ldd	r24, Y+3	; 0x03
    1f78:	9c 81       	ldd	r25, Y+4	; 0x04
    1f7a:	02 96       	adiw	r24, 0x02	; 2
    1f7c:	9a 83       	std	Y+2, r25	; 0x02
    1f7e:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    1f80:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
    1f84:	08 c0       	rjmp	.+16     	; 0x1f96 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1f86:	e9 81       	ldd	r30, Y+1	; 0x01
    1f88:	fa 81       	ldd	r31, Y+2	; 0x02
    1f8a:	85 81       	ldd	r24, Z+5	; 0x05
    1f8c:	96 81       	ldd	r25, Z+6	; 0x06
    1f8e:	60 e0       	ldi	r22, 0x00	; 0
    1f90:	72 e0       	ldi	r23, 0x02	; 2
    1f92:	0e 94 32 24 	call	0x4864	; 0x4864 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1f96:	e9 81       	ldd	r30, Y+1	; 0x01
    1f98:	fa 81       	ldd	r31, Y+2	; 0x02
    1f9a:	80 81       	ld	r24, Z
    1f9c:	88 23       	and	r24, r24
    1f9e:	99 f7       	brne	.-26     	; 0x1f86 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    1fa0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fa4:	0e 94 2d 07 	call	0xe5a	; 0xe5a <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    1fa8:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
}
    1fac:	26 96       	adiw	r28, 0x06	; 6
    1fae:	0f b6       	in	r0, 0x3f	; 63
    1fb0:	f8 94       	cli
    1fb2:	de bf       	out	0x3e, r29	; 62
    1fb4:	0f be       	out	0x3f, r0	; 63
    1fb6:	cd bf       	out	0x3d, r28	; 61
    1fb8:	cf 91       	pop	r28
    1fba:	df 91       	pop	r29
    1fbc:	08 95       	ret

00001fbe <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    1fbe:	df 93       	push	r29
    1fc0:	cf 93       	push	r28
    1fc2:	00 d0       	rcall	.+0      	; 0x1fc4 <vEventGroupSetBitsCallback+0x6>
    1fc4:	00 d0       	rcall	.+0      	; 0x1fc6 <vEventGroupSetBitsCallback+0x8>
    1fc6:	00 d0       	rcall	.+0      	; 0x1fc8 <vEventGroupSetBitsCallback+0xa>
    1fc8:	cd b7       	in	r28, 0x3d	; 61
    1fca:	de b7       	in	r29, 0x3e	; 62
    1fcc:	9a 83       	std	Y+2, r25	; 0x02
    1fce:	89 83       	std	Y+1, r24	; 0x01
    1fd0:	4b 83       	std	Y+3, r20	; 0x03
    1fd2:	5c 83       	std	Y+4, r21	; 0x04
    1fd4:	6d 83       	std	Y+5, r22	; 0x05
    1fd6:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1fd8:	89 81       	ldd	r24, Y+1	; 0x01
    1fda:	9a 81       	ldd	r25, Y+2	; 0x02
    1fdc:	2b 81       	ldd	r18, Y+3	; 0x03
    1fde:	3c 81       	ldd	r19, Y+4	; 0x04
    1fe0:	b9 01       	movw	r22, r18
    1fe2:	0e 94 fc 0e 	call	0x1df8	; 0x1df8 <xEventGroupSetBits>
}
    1fe6:	26 96       	adiw	r28, 0x06	; 6
    1fe8:	0f b6       	in	r0, 0x3f	; 63
    1fea:	f8 94       	cli
    1fec:	de bf       	out	0x3e, r29	; 62
    1fee:	0f be       	out	0x3f, r0	; 63
    1ff0:	cd bf       	out	0x3d, r28	; 61
    1ff2:	cf 91       	pop	r28
    1ff4:	df 91       	pop	r29
    1ff6:	08 95       	ret

00001ff8 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1ff8:	df 93       	push	r29
    1ffa:	cf 93       	push	r28
    1ffc:	00 d0       	rcall	.+0      	; 0x1ffe <vEventGroupClearBitsCallback+0x6>
    1ffe:	00 d0       	rcall	.+0      	; 0x2000 <vEventGroupClearBitsCallback+0x8>
    2000:	00 d0       	rcall	.+0      	; 0x2002 <vEventGroupClearBitsCallback+0xa>
    2002:	cd b7       	in	r28, 0x3d	; 61
    2004:	de b7       	in	r29, 0x3e	; 62
    2006:	9a 83       	std	Y+2, r25	; 0x02
    2008:	89 83       	std	Y+1, r24	; 0x01
    200a:	4b 83       	std	Y+3, r20	; 0x03
    200c:	5c 83       	std	Y+4, r21	; 0x04
    200e:	6d 83       	std	Y+5, r22	; 0x05
    2010:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2012:	89 81       	ldd	r24, Y+1	; 0x01
    2014:	9a 81       	ldd	r25, Y+2	; 0x02
    2016:	2b 81       	ldd	r18, Y+3	; 0x03
    2018:	3c 81       	ldd	r19, Y+4	; 0x04
    201a:	b9 01       	movw	r22, r18
    201c:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <xEventGroupClearBits>
}
    2020:	26 96       	adiw	r28, 0x06	; 6
    2022:	0f b6       	in	r0, 0x3f	; 63
    2024:	f8 94       	cli
    2026:	de bf       	out	0x3e, r29	; 62
    2028:	0f be       	out	0x3f, r0	; 63
    202a:	cd bf       	out	0x3d, r28	; 61
    202c:	cf 91       	pop	r28
    202e:	df 91       	pop	r29
    2030:	08 95       	ret

00002032 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    2032:	df 93       	push	r29
    2034:	cf 93       	push	r28
    2036:	00 d0       	rcall	.+0      	; 0x2038 <prvTestWaitCondition+0x6>
    2038:	00 d0       	rcall	.+0      	; 0x203a <prvTestWaitCondition+0x8>
    203a:	00 d0       	rcall	.+0      	; 0x203c <prvTestWaitCondition+0xa>
    203c:	cd b7       	in	r28, 0x3d	; 61
    203e:	de b7       	in	r29, 0x3e	; 62
    2040:	9b 83       	std	Y+3, r25	; 0x03
    2042:	8a 83       	std	Y+2, r24	; 0x02
    2044:	7d 83       	std	Y+5, r23	; 0x05
    2046:	6c 83       	std	Y+4, r22	; 0x04
    2048:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    204a:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    204c:	8e 81       	ldd	r24, Y+6	; 0x06
    204e:	88 23       	and	r24, r24
    2050:	59 f4       	brne	.+22     	; 0x2068 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2052:	8a 81       	ldd	r24, Y+2	; 0x02
    2054:	9b 81       	ldd	r25, Y+3	; 0x03
    2056:	2c 81       	ldd	r18, Y+4	; 0x04
    2058:	3d 81       	ldd	r19, Y+5	; 0x05
    205a:	82 23       	and	r24, r18
    205c:	93 23       	and	r25, r19
    205e:	00 97       	sbiw	r24, 0x00	; 0
    2060:	81 f0       	breq	.+32     	; 0x2082 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2062:	81 e0       	ldi	r24, 0x01	; 1
    2064:	89 83       	std	Y+1, r24	; 0x01
    2066:	0d c0       	rjmp	.+26     	; 0x2082 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2068:	2a 81       	ldd	r18, Y+2	; 0x02
    206a:	3b 81       	ldd	r19, Y+3	; 0x03
    206c:	8c 81       	ldd	r24, Y+4	; 0x04
    206e:	9d 81       	ldd	r25, Y+5	; 0x05
    2070:	28 23       	and	r18, r24
    2072:	39 23       	and	r19, r25
    2074:	8c 81       	ldd	r24, Y+4	; 0x04
    2076:	9d 81       	ldd	r25, Y+5	; 0x05
    2078:	28 17       	cp	r18, r24
    207a:	39 07       	cpc	r19, r25
    207c:	11 f4       	brne	.+4      	; 0x2082 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    207e:	81 e0       	ldi	r24, 0x01	; 1
    2080:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    2082:	89 81       	ldd	r24, Y+1	; 0x01
}
    2084:	26 96       	adiw	r28, 0x06	; 6
    2086:	0f b6       	in	r0, 0x3f	; 63
    2088:	f8 94       	cli
    208a:	de bf       	out	0x3e, r29	; 62
    208c:	0f be       	out	0x3f, r0	; 63
    208e:	cd bf       	out	0x3d, r28	; 61
    2090:	cf 91       	pop	r28
    2092:	df 91       	pop	r29
    2094:	08 95       	ret

00002096 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2096:	df 93       	push	r29
    2098:	cf 93       	push	r28
    209a:	00 d0       	rcall	.+0      	; 0x209c <vListInitialise+0x6>
    209c:	cd b7       	in	r28, 0x3d	; 61
    209e:	de b7       	in	r29, 0x3e	; 62
    20a0:	9a 83       	std	Y+2, r25	; 0x02
    20a2:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    20a4:	89 81       	ldd	r24, Y+1	; 0x01
    20a6:	9a 81       	ldd	r25, Y+2	; 0x02
    20a8:	03 96       	adiw	r24, 0x03	; 3
    20aa:	e9 81       	ldd	r30, Y+1	; 0x01
    20ac:	fa 81       	ldd	r31, Y+2	; 0x02
    20ae:	92 83       	std	Z+2, r25	; 0x02
    20b0:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    20b2:	e9 81       	ldd	r30, Y+1	; 0x01
    20b4:	fa 81       	ldd	r31, Y+2	; 0x02
    20b6:	8f ef       	ldi	r24, 0xFF	; 255
    20b8:	9f ef       	ldi	r25, 0xFF	; 255
    20ba:	94 83       	std	Z+4, r25	; 0x04
    20bc:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    20be:	89 81       	ldd	r24, Y+1	; 0x01
    20c0:	9a 81       	ldd	r25, Y+2	; 0x02
    20c2:	03 96       	adiw	r24, 0x03	; 3
    20c4:	e9 81       	ldd	r30, Y+1	; 0x01
    20c6:	fa 81       	ldd	r31, Y+2	; 0x02
    20c8:	96 83       	std	Z+6, r25	; 0x06
    20ca:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    20cc:	89 81       	ldd	r24, Y+1	; 0x01
    20ce:	9a 81       	ldd	r25, Y+2	; 0x02
    20d0:	03 96       	adiw	r24, 0x03	; 3
    20d2:	e9 81       	ldd	r30, Y+1	; 0x01
    20d4:	fa 81       	ldd	r31, Y+2	; 0x02
    20d6:	90 87       	std	Z+8, r25	; 0x08
    20d8:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    20da:	e9 81       	ldd	r30, Y+1	; 0x01
    20dc:	fa 81       	ldd	r31, Y+2	; 0x02
    20de:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    20e0:	0f 90       	pop	r0
    20e2:	0f 90       	pop	r0
    20e4:	cf 91       	pop	r28
    20e6:	df 91       	pop	r29
    20e8:	08 95       	ret

000020ea <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    20ea:	df 93       	push	r29
    20ec:	cf 93       	push	r28
    20ee:	00 d0       	rcall	.+0      	; 0x20f0 <vListInitialiseItem+0x6>
    20f0:	cd b7       	in	r28, 0x3d	; 61
    20f2:	de b7       	in	r29, 0x3e	; 62
    20f4:	9a 83       	std	Y+2, r25	; 0x02
    20f6:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    20f8:	e9 81       	ldd	r30, Y+1	; 0x01
    20fa:	fa 81       	ldd	r31, Y+2	; 0x02
    20fc:	11 86       	std	Z+9, r1	; 0x09
    20fe:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2100:	0f 90       	pop	r0
    2102:	0f 90       	pop	r0
    2104:	cf 91       	pop	r28
    2106:	df 91       	pop	r29
    2108:	08 95       	ret

0000210a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    210a:	df 93       	push	r29
    210c:	cf 93       	push	r28
    210e:	00 d0       	rcall	.+0      	; 0x2110 <vListInsertEnd+0x6>
    2110:	00 d0       	rcall	.+0      	; 0x2112 <vListInsertEnd+0x8>
    2112:	00 d0       	rcall	.+0      	; 0x2114 <vListInsertEnd+0xa>
    2114:	cd b7       	in	r28, 0x3d	; 61
    2116:	de b7       	in	r29, 0x3e	; 62
    2118:	9c 83       	std	Y+4, r25	; 0x04
    211a:	8b 83       	std	Y+3, r24	; 0x03
    211c:	7e 83       	std	Y+6, r23	; 0x06
    211e:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    2120:	eb 81       	ldd	r30, Y+3	; 0x03
    2122:	fc 81       	ldd	r31, Y+4	; 0x04
    2124:	81 81       	ldd	r24, Z+1	; 0x01
    2126:	92 81       	ldd	r25, Z+2	; 0x02
    2128:	9a 83       	std	Y+2, r25	; 0x02
    212a:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    212c:	ed 81       	ldd	r30, Y+5	; 0x05
    212e:	fe 81       	ldd	r31, Y+6	; 0x06
    2130:	89 81       	ldd	r24, Y+1	; 0x01
    2132:	9a 81       	ldd	r25, Y+2	; 0x02
    2134:	93 83       	std	Z+3, r25	; 0x03
    2136:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2138:	e9 81       	ldd	r30, Y+1	; 0x01
    213a:	fa 81       	ldd	r31, Y+2	; 0x02
    213c:	84 81       	ldd	r24, Z+4	; 0x04
    213e:	95 81       	ldd	r25, Z+5	; 0x05
    2140:	ed 81       	ldd	r30, Y+5	; 0x05
    2142:	fe 81       	ldd	r31, Y+6	; 0x06
    2144:	95 83       	std	Z+5, r25	; 0x05
    2146:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2148:	e9 81       	ldd	r30, Y+1	; 0x01
    214a:	fa 81       	ldd	r31, Y+2	; 0x02
    214c:	04 80       	ldd	r0, Z+4	; 0x04
    214e:	f5 81       	ldd	r31, Z+5	; 0x05
    2150:	e0 2d       	mov	r30, r0
    2152:	8d 81       	ldd	r24, Y+5	; 0x05
    2154:	9e 81       	ldd	r25, Y+6	; 0x06
    2156:	93 83       	std	Z+3, r25	; 0x03
    2158:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    215a:	e9 81       	ldd	r30, Y+1	; 0x01
    215c:	fa 81       	ldd	r31, Y+2	; 0x02
    215e:	8d 81       	ldd	r24, Y+5	; 0x05
    2160:	9e 81       	ldd	r25, Y+6	; 0x06
    2162:	95 83       	std	Z+5, r25	; 0x05
    2164:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2166:	ed 81       	ldd	r30, Y+5	; 0x05
    2168:	fe 81       	ldd	r31, Y+6	; 0x06
    216a:	8b 81       	ldd	r24, Y+3	; 0x03
    216c:	9c 81       	ldd	r25, Y+4	; 0x04
    216e:	91 87       	std	Z+9, r25	; 0x09
    2170:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2172:	eb 81       	ldd	r30, Y+3	; 0x03
    2174:	fc 81       	ldd	r31, Y+4	; 0x04
    2176:	80 81       	ld	r24, Z
    2178:	8f 5f       	subi	r24, 0xFF	; 255
    217a:	eb 81       	ldd	r30, Y+3	; 0x03
    217c:	fc 81       	ldd	r31, Y+4	; 0x04
    217e:	80 83       	st	Z, r24
}
    2180:	26 96       	adiw	r28, 0x06	; 6
    2182:	0f b6       	in	r0, 0x3f	; 63
    2184:	f8 94       	cli
    2186:	de bf       	out	0x3e, r29	; 62
    2188:	0f be       	out	0x3f, r0	; 63
    218a:	cd bf       	out	0x3d, r28	; 61
    218c:	cf 91       	pop	r28
    218e:	df 91       	pop	r29
    2190:	08 95       	ret

00002192 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    2192:	df 93       	push	r29
    2194:	cf 93       	push	r28
    2196:	cd b7       	in	r28, 0x3d	; 61
    2198:	de b7       	in	r29, 0x3e	; 62
    219a:	28 97       	sbiw	r28, 0x08	; 8
    219c:	0f b6       	in	r0, 0x3f	; 63
    219e:	f8 94       	cli
    21a0:	de bf       	out	0x3e, r29	; 62
    21a2:	0f be       	out	0x3f, r0	; 63
    21a4:	cd bf       	out	0x3d, r28	; 61
    21a6:	9e 83       	std	Y+6, r25	; 0x06
    21a8:	8d 83       	std	Y+5, r24	; 0x05
    21aa:	78 87       	std	Y+8, r23	; 0x08
    21ac:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    21ae:	ef 81       	ldd	r30, Y+7	; 0x07
    21b0:	f8 85       	ldd	r31, Y+8	; 0x08
    21b2:	80 81       	ld	r24, Z
    21b4:	91 81       	ldd	r25, Z+1	; 0x01
    21b6:	9a 83       	std	Y+2, r25	; 0x02
    21b8:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    21ba:	89 81       	ldd	r24, Y+1	; 0x01
    21bc:	9a 81       	ldd	r25, Y+2	; 0x02
    21be:	2f ef       	ldi	r18, 0xFF	; 255
    21c0:	8f 3f       	cpi	r24, 0xFF	; 255
    21c2:	92 07       	cpc	r25, r18
    21c4:	39 f4       	brne	.+14     	; 0x21d4 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    21c6:	ed 81       	ldd	r30, Y+5	; 0x05
    21c8:	fe 81       	ldd	r31, Y+6	; 0x06
    21ca:	87 81       	ldd	r24, Z+7	; 0x07
    21cc:	90 85       	ldd	r25, Z+8	; 0x08
    21ce:	9c 83       	std	Y+4, r25	; 0x04
    21d0:	8b 83       	std	Y+3, r24	; 0x03
    21d2:	18 c0       	rjmp	.+48     	; 0x2204 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    21d4:	8d 81       	ldd	r24, Y+5	; 0x05
    21d6:	9e 81       	ldd	r25, Y+6	; 0x06
    21d8:	03 96       	adiw	r24, 0x03	; 3
    21da:	9c 83       	std	Y+4, r25	; 0x04
    21dc:	8b 83       	std	Y+3, r24	; 0x03
    21de:	06 c0       	rjmp	.+12     	; 0x21ec <vListInsert+0x5a>
    21e0:	eb 81       	ldd	r30, Y+3	; 0x03
    21e2:	fc 81       	ldd	r31, Y+4	; 0x04
    21e4:	82 81       	ldd	r24, Z+2	; 0x02
    21e6:	93 81       	ldd	r25, Z+3	; 0x03
    21e8:	9c 83       	std	Y+4, r25	; 0x04
    21ea:	8b 83       	std	Y+3, r24	; 0x03
    21ec:	eb 81       	ldd	r30, Y+3	; 0x03
    21ee:	fc 81       	ldd	r31, Y+4	; 0x04
    21f0:	02 80       	ldd	r0, Z+2	; 0x02
    21f2:	f3 81       	ldd	r31, Z+3	; 0x03
    21f4:	e0 2d       	mov	r30, r0
    21f6:	20 81       	ld	r18, Z
    21f8:	31 81       	ldd	r19, Z+1	; 0x01
    21fa:	89 81       	ldd	r24, Y+1	; 0x01
    21fc:	9a 81       	ldd	r25, Y+2	; 0x02
    21fe:	82 17       	cp	r24, r18
    2200:	93 07       	cpc	r25, r19
    2202:	70 f7       	brcc	.-36     	; 0x21e0 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    2204:	eb 81       	ldd	r30, Y+3	; 0x03
    2206:	fc 81       	ldd	r31, Y+4	; 0x04
    2208:	82 81       	ldd	r24, Z+2	; 0x02
    220a:	93 81       	ldd	r25, Z+3	; 0x03
    220c:	ef 81       	ldd	r30, Y+7	; 0x07
    220e:	f8 85       	ldd	r31, Y+8	; 0x08
    2210:	93 83       	std	Z+3, r25	; 0x03
    2212:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2214:	ef 81       	ldd	r30, Y+7	; 0x07
    2216:	f8 85       	ldd	r31, Y+8	; 0x08
    2218:	02 80       	ldd	r0, Z+2	; 0x02
    221a:	f3 81       	ldd	r31, Z+3	; 0x03
    221c:	e0 2d       	mov	r30, r0
    221e:	8f 81       	ldd	r24, Y+7	; 0x07
    2220:	98 85       	ldd	r25, Y+8	; 0x08
    2222:	95 83       	std	Z+5, r25	; 0x05
    2224:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    2226:	ef 81       	ldd	r30, Y+7	; 0x07
    2228:	f8 85       	ldd	r31, Y+8	; 0x08
    222a:	8b 81       	ldd	r24, Y+3	; 0x03
    222c:	9c 81       	ldd	r25, Y+4	; 0x04
    222e:	95 83       	std	Z+5, r25	; 0x05
    2230:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    2232:	eb 81       	ldd	r30, Y+3	; 0x03
    2234:	fc 81       	ldd	r31, Y+4	; 0x04
    2236:	8f 81       	ldd	r24, Y+7	; 0x07
    2238:	98 85       	ldd	r25, Y+8	; 0x08
    223a:	93 83       	std	Z+3, r25	; 0x03
    223c:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    223e:	ef 81       	ldd	r30, Y+7	; 0x07
    2240:	f8 85       	ldd	r31, Y+8	; 0x08
    2242:	8d 81       	ldd	r24, Y+5	; 0x05
    2244:	9e 81       	ldd	r25, Y+6	; 0x06
    2246:	91 87       	std	Z+9, r25	; 0x09
    2248:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    224a:	ed 81       	ldd	r30, Y+5	; 0x05
    224c:	fe 81       	ldd	r31, Y+6	; 0x06
    224e:	80 81       	ld	r24, Z
    2250:	8f 5f       	subi	r24, 0xFF	; 255
    2252:	ed 81       	ldd	r30, Y+5	; 0x05
    2254:	fe 81       	ldd	r31, Y+6	; 0x06
    2256:	80 83       	st	Z, r24
}
    2258:	28 96       	adiw	r28, 0x08	; 8
    225a:	0f b6       	in	r0, 0x3f	; 63
    225c:	f8 94       	cli
    225e:	de bf       	out	0x3e, r29	; 62
    2260:	0f be       	out	0x3f, r0	; 63
    2262:	cd bf       	out	0x3d, r28	; 61
    2264:	cf 91       	pop	r28
    2266:	df 91       	pop	r29
    2268:	08 95       	ret

0000226a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    226a:	df 93       	push	r29
    226c:	cf 93       	push	r28
    226e:	00 d0       	rcall	.+0      	; 0x2270 <uxListRemove+0x6>
    2270:	00 d0       	rcall	.+0      	; 0x2272 <uxListRemove+0x8>
    2272:	cd b7       	in	r28, 0x3d	; 61
    2274:	de b7       	in	r29, 0x3e	; 62
    2276:	9c 83       	std	Y+4, r25	; 0x04
    2278:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    227a:	eb 81       	ldd	r30, Y+3	; 0x03
    227c:	fc 81       	ldd	r31, Y+4	; 0x04
    227e:	80 85       	ldd	r24, Z+8	; 0x08
    2280:	91 85       	ldd	r25, Z+9	; 0x09
    2282:	9a 83       	std	Y+2, r25	; 0x02
    2284:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2286:	eb 81       	ldd	r30, Y+3	; 0x03
    2288:	fc 81       	ldd	r31, Y+4	; 0x04
    228a:	a2 81       	ldd	r26, Z+2	; 0x02
    228c:	b3 81       	ldd	r27, Z+3	; 0x03
    228e:	eb 81       	ldd	r30, Y+3	; 0x03
    2290:	fc 81       	ldd	r31, Y+4	; 0x04
    2292:	84 81       	ldd	r24, Z+4	; 0x04
    2294:	95 81       	ldd	r25, Z+5	; 0x05
    2296:	15 96       	adiw	r26, 0x05	; 5
    2298:	9c 93       	st	X, r25
    229a:	8e 93       	st	-X, r24
    229c:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    229e:	eb 81       	ldd	r30, Y+3	; 0x03
    22a0:	fc 81       	ldd	r31, Y+4	; 0x04
    22a2:	a4 81       	ldd	r26, Z+4	; 0x04
    22a4:	b5 81       	ldd	r27, Z+5	; 0x05
    22a6:	eb 81       	ldd	r30, Y+3	; 0x03
    22a8:	fc 81       	ldd	r31, Y+4	; 0x04
    22aa:	82 81       	ldd	r24, Z+2	; 0x02
    22ac:	93 81       	ldd	r25, Z+3	; 0x03
    22ae:	13 96       	adiw	r26, 0x03	; 3
    22b0:	9c 93       	st	X, r25
    22b2:	8e 93       	st	-X, r24
    22b4:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    22b6:	e9 81       	ldd	r30, Y+1	; 0x01
    22b8:	fa 81       	ldd	r31, Y+2	; 0x02
    22ba:	21 81       	ldd	r18, Z+1	; 0x01
    22bc:	32 81       	ldd	r19, Z+2	; 0x02
    22be:	8b 81       	ldd	r24, Y+3	; 0x03
    22c0:	9c 81       	ldd	r25, Y+4	; 0x04
    22c2:	28 17       	cp	r18, r24
    22c4:	39 07       	cpc	r19, r25
    22c6:	41 f4       	brne	.+16     	; 0x22d8 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    22c8:	eb 81       	ldd	r30, Y+3	; 0x03
    22ca:	fc 81       	ldd	r31, Y+4	; 0x04
    22cc:	84 81       	ldd	r24, Z+4	; 0x04
    22ce:	95 81       	ldd	r25, Z+5	; 0x05
    22d0:	e9 81       	ldd	r30, Y+1	; 0x01
    22d2:	fa 81       	ldd	r31, Y+2	; 0x02
    22d4:	92 83       	std	Z+2, r25	; 0x02
    22d6:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    22d8:	eb 81       	ldd	r30, Y+3	; 0x03
    22da:	fc 81       	ldd	r31, Y+4	; 0x04
    22dc:	11 86       	std	Z+9, r1	; 0x09
    22de:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    22e0:	e9 81       	ldd	r30, Y+1	; 0x01
    22e2:	fa 81       	ldd	r31, Y+2	; 0x02
    22e4:	80 81       	ld	r24, Z
    22e6:	81 50       	subi	r24, 0x01	; 1
    22e8:	e9 81       	ldd	r30, Y+1	; 0x01
    22ea:	fa 81       	ldd	r31, Y+2	; 0x02
    22ec:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    22ee:	e9 81       	ldd	r30, Y+1	; 0x01
    22f0:	fa 81       	ldd	r31, Y+2	; 0x02
    22f2:	80 81       	ld	r24, Z
}
    22f4:	0f 90       	pop	r0
    22f6:	0f 90       	pop	r0
    22f8:	0f 90       	pop	r0
    22fa:	0f 90       	pop	r0
    22fc:	cf 91       	pop	r28
    22fe:	df 91       	pop	r29
    2300:	08 95       	ret

00002302 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    2302:	df 93       	push	r29
    2304:	cf 93       	push	r28
    2306:	00 d0       	rcall	.+0      	; 0x2308 <xQueueGenericReset+0x6>
    2308:	00 d0       	rcall	.+0      	; 0x230a <xQueueGenericReset+0x8>
    230a:	00 d0       	rcall	.+0      	; 0x230c <xQueueGenericReset+0xa>
    230c:	cd b7       	in	r28, 0x3d	; 61
    230e:	de b7       	in	r29, 0x3e	; 62
    2310:	9d 83       	std	Y+5, r25	; 0x05
    2312:	8c 83       	std	Y+4, r24	; 0x04
    2314:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    231a:	8c 81       	ldd	r24, Y+4	; 0x04
    231c:	9d 81       	ldd	r25, Y+5	; 0x05
    231e:	9a 83       	std	Y+2, r25	; 0x02
    2320:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    2322:	89 81       	ldd	r24, Y+1	; 0x01
    2324:	9a 81       	ldd	r25, Y+2	; 0x02
    2326:	00 97       	sbiw	r24, 0x00	; 0
    2328:	09 f4       	brne	.+2      	; 0x232c <xQueueGenericReset+0x2a>
    232a:	8b c0       	rjmp	.+278    	; 0x2442 <xQueueGenericReset+0x140>
    232c:	e9 81       	ldd	r30, Y+1	; 0x01
    232e:	fa 81       	ldd	r31, Y+2	; 0x02
    2330:	83 8d       	ldd	r24, Z+27	; 0x1b
    2332:	88 23       	and	r24, r24
    2334:	09 f4       	brne	.+2      	; 0x2338 <xQueueGenericReset+0x36>
    2336:	85 c0       	rjmp	.+266    	; 0x2442 <xQueueGenericReset+0x140>
    2338:	e9 81       	ldd	r30, Y+1	; 0x01
    233a:	fa 81       	ldd	r31, Y+2	; 0x02
    233c:	83 8d       	ldd	r24, Z+27	; 0x1b
    233e:	28 2f       	mov	r18, r24
    2340:	30 e0       	ldi	r19, 0x00	; 0
    2342:	8f ef       	ldi	r24, 0xFF	; 255
    2344:	9f e7       	ldi	r25, 0x7F	; 127
    2346:	b9 01       	movw	r22, r18
    2348:	0e 94 ef 3d 	call	0x7bde	; 0x7bde <__udivmodhi4>
    234c:	cb 01       	movw	r24, r22
    234e:	9c 01       	movw	r18, r24
    2350:	e9 81       	ldd	r30, Y+1	; 0x01
    2352:	fa 81       	ldd	r31, Y+2	; 0x02
    2354:	84 8d       	ldd	r24, Z+28	; 0x1c
    2356:	88 2f       	mov	r24, r24
    2358:	90 e0       	ldi	r25, 0x00	; 0
    235a:	28 17       	cp	r18, r24
    235c:	39 07       	cpc	r19, r25
    235e:	08 f4       	brcc	.+2      	; 0x2362 <xQueueGenericReset+0x60>
    2360:	70 c0       	rjmp	.+224    	; 0x2442 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    2362:	0f b6       	in	r0, 0x3f	; 63
    2364:	f8 94       	cli
    2366:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2368:	e9 81       	ldd	r30, Y+1	; 0x01
    236a:	fa 81       	ldd	r31, Y+2	; 0x02
    236c:	40 81       	ld	r20, Z
    236e:	51 81       	ldd	r21, Z+1	; 0x01
    2370:	e9 81       	ldd	r30, Y+1	; 0x01
    2372:	fa 81       	ldd	r31, Y+2	; 0x02
    2374:	83 8d       	ldd	r24, Z+27	; 0x1b
    2376:	28 2f       	mov	r18, r24
    2378:	30 e0       	ldi	r19, 0x00	; 0
    237a:	e9 81       	ldd	r30, Y+1	; 0x01
    237c:	fa 81       	ldd	r31, Y+2	; 0x02
    237e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2380:	88 2f       	mov	r24, r24
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	bc 01       	movw	r22, r24
    2386:	26 9f       	mul	r18, r22
    2388:	c0 01       	movw	r24, r0
    238a:	27 9f       	mul	r18, r23
    238c:	90 0d       	add	r25, r0
    238e:	36 9f       	mul	r19, r22
    2390:	90 0d       	add	r25, r0
    2392:	11 24       	eor	r1, r1
    2394:	84 0f       	add	r24, r20
    2396:	95 1f       	adc	r25, r21
    2398:	e9 81       	ldd	r30, Y+1	; 0x01
    239a:	fa 81       	ldd	r31, Y+2	; 0x02
    239c:	95 83       	std	Z+5, r25	; 0x05
    239e:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    23a0:	e9 81       	ldd	r30, Y+1	; 0x01
    23a2:	fa 81       	ldd	r31, Y+2	; 0x02
    23a4:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    23a6:	e9 81       	ldd	r30, Y+1	; 0x01
    23a8:	fa 81       	ldd	r31, Y+2	; 0x02
    23aa:	80 81       	ld	r24, Z
    23ac:	91 81       	ldd	r25, Z+1	; 0x01
    23ae:	e9 81       	ldd	r30, Y+1	; 0x01
    23b0:	fa 81       	ldd	r31, Y+2	; 0x02
    23b2:	93 83       	std	Z+3, r25	; 0x03
    23b4:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    23b6:	e9 81       	ldd	r30, Y+1	; 0x01
    23b8:	fa 81       	ldd	r31, Y+2	; 0x02
    23ba:	40 81       	ld	r20, Z
    23bc:	51 81       	ldd	r21, Z+1	; 0x01
    23be:	e9 81       	ldd	r30, Y+1	; 0x01
    23c0:	fa 81       	ldd	r31, Y+2	; 0x02
    23c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    23c4:	88 2f       	mov	r24, r24
    23c6:	90 e0       	ldi	r25, 0x00	; 0
    23c8:	9c 01       	movw	r18, r24
    23ca:	21 50       	subi	r18, 0x01	; 1
    23cc:	30 40       	sbci	r19, 0x00	; 0
    23ce:	e9 81       	ldd	r30, Y+1	; 0x01
    23d0:	fa 81       	ldd	r31, Y+2	; 0x02
    23d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    23d4:	88 2f       	mov	r24, r24
    23d6:	90 e0       	ldi	r25, 0x00	; 0
    23d8:	bc 01       	movw	r22, r24
    23da:	26 9f       	mul	r18, r22
    23dc:	c0 01       	movw	r24, r0
    23de:	27 9f       	mul	r18, r23
    23e0:	90 0d       	add	r25, r0
    23e2:	36 9f       	mul	r19, r22
    23e4:	90 0d       	add	r25, r0
    23e6:	11 24       	eor	r1, r1
    23e8:	84 0f       	add	r24, r20
    23ea:	95 1f       	adc	r25, r21
    23ec:	e9 81       	ldd	r30, Y+1	; 0x01
    23ee:	fa 81       	ldd	r31, Y+2	; 0x02
    23f0:	97 83       	std	Z+7, r25	; 0x07
    23f2:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    23f4:	e9 81       	ldd	r30, Y+1	; 0x01
    23f6:	fa 81       	ldd	r31, Y+2	; 0x02
    23f8:	8f ef       	ldi	r24, 0xFF	; 255
    23fa:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    23fc:	e9 81       	ldd	r30, Y+1	; 0x01
    23fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2400:	8f ef       	ldi	r24, 0xFF	; 255
    2402:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    2404:	8e 81       	ldd	r24, Y+6	; 0x06
    2406:	88 23       	and	r24, r24
    2408:	79 f4       	brne	.+30     	; 0x2428 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    240a:	e9 81       	ldd	r30, Y+1	; 0x01
    240c:	fa 81       	ldd	r31, Y+2	; 0x02
    240e:	80 85       	ldd	r24, Z+8	; 0x08
    2410:	88 23       	and	r24, r24
    2412:	a1 f0       	breq	.+40     	; 0x243c <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2414:	89 81       	ldd	r24, Y+1	; 0x01
    2416:	9a 81       	ldd	r25, Y+2	; 0x02
    2418:	08 96       	adiw	r24, 0x08	; 8
    241a:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    241e:	88 23       	and	r24, r24
    2420:	69 f0       	breq	.+26     	; 0x243c <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2422:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    2426:	0a c0       	rjmp	.+20     	; 0x243c <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2428:	89 81       	ldd	r24, Y+1	; 0x01
    242a:	9a 81       	ldd	r25, Y+2	; 0x02
    242c:	08 96       	adiw	r24, 0x08	; 8
    242e:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2432:	89 81       	ldd	r24, Y+1	; 0x01
    2434:	9a 81       	ldd	r25, Y+2	; 0x02
    2436:	41 96       	adiw	r24, 0x11	; 17
    2438:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    243c:	0f 90       	pop	r0
    243e:	0f be       	out	0x3f, r0	; 63
    2440:	01 c0       	rjmp	.+2      	; 0x2444 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    2442:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    2444:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2446:	26 96       	adiw	r28, 0x06	; 6
    2448:	0f b6       	in	r0, 0x3f	; 63
    244a:	f8 94       	cli
    244c:	de bf       	out	0x3e, r29	; 62
    244e:	0f be       	out	0x3f, r0	; 63
    2450:	cd bf       	out	0x3d, r28	; 61
    2452:	cf 91       	pop	r28
    2454:	df 91       	pop	r29
    2456:	08 95       	ret

00002458 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    2458:	0f 93       	push	r16
    245a:	1f 93       	push	r17
    245c:	df 93       	push	r29
    245e:	cf 93       	push	r28
    2460:	cd b7       	in	r28, 0x3d	; 61
    2462:	de b7       	in	r29, 0x3e	; 62
    2464:	29 97       	sbiw	r28, 0x09	; 9
    2466:	0f b6       	in	r0, 0x3f	; 63
    2468:	f8 94       	cli
    246a:	de bf       	out	0x3e, r29	; 62
    246c:	0f be       	out	0x3f, r0	; 63
    246e:	cd bf       	out	0x3d, r28	; 61
    2470:	8f 83       	std	Y+7, r24	; 0x07
    2472:	68 87       	std	Y+8, r22	; 0x08
    2474:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    2476:	1e 82       	std	Y+6, r1	; 0x06
    2478:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    247a:	8f 81       	ldd	r24, Y+7	; 0x07
    247c:	88 23       	and	r24, r24
    247e:	09 f4       	brne	.+2      	; 0x2482 <xQueueGenericCreate+0x2a>
    2480:	52 c0       	rjmp	.+164    	; 0x2526 <xQueueGenericCreate+0xce>
    2482:	8f 81       	ldd	r24, Y+7	; 0x07
    2484:	28 2f       	mov	r18, r24
    2486:	30 e0       	ldi	r19, 0x00	; 0
    2488:	8f ef       	ldi	r24, 0xFF	; 255
    248a:	9f e7       	ldi	r25, 0x7F	; 127
    248c:	b9 01       	movw	r22, r18
    248e:	0e 94 ef 3d 	call	0x7bde	; 0x7bde <__udivmodhi4>
    2492:	cb 01       	movw	r24, r22
    2494:	9c 01       	movw	r18, r24
    2496:	88 85       	ldd	r24, Y+8	; 0x08
    2498:	88 2f       	mov	r24, r24
    249a:	90 e0       	ldi	r25, 0x00	; 0
    249c:	28 17       	cp	r18, r24
    249e:	39 07       	cpc	r19, r25
    24a0:	08 f4       	brcc	.+2      	; 0x24a4 <xQueueGenericCreate+0x4c>
    24a2:	41 c0       	rjmp	.+130    	; 0x2526 <xQueueGenericCreate+0xce>
    24a4:	8f 81       	ldd	r24, Y+7	; 0x07
    24a6:	28 2f       	mov	r18, r24
    24a8:	30 e0       	ldi	r19, 0x00	; 0
    24aa:	88 85       	ldd	r24, Y+8	; 0x08
    24ac:	88 2f       	mov	r24, r24
    24ae:	90 e0       	ldi	r25, 0x00	; 0
    24b0:	ac 01       	movw	r20, r24
    24b2:	24 9f       	mul	r18, r20
    24b4:	c0 01       	movw	r24, r0
    24b6:	25 9f       	mul	r18, r21
    24b8:	90 0d       	add	r25, r0
    24ba:	34 9f       	mul	r19, r20
    24bc:	90 0d       	add	r25, r0
    24be:	11 24       	eor	r1, r1
    24c0:	5f e7       	ldi	r21, 0x7F	; 127
    24c2:	81 3e       	cpi	r24, 0xE1	; 225
    24c4:	95 07       	cpc	r25, r21
    24c6:	78 f5       	brcc	.+94     	; 0x2526 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    24c8:	8f 81       	ldd	r24, Y+7	; 0x07
    24ca:	28 2f       	mov	r18, r24
    24cc:	30 e0       	ldi	r19, 0x00	; 0
    24ce:	88 85       	ldd	r24, Y+8	; 0x08
    24d0:	88 2f       	mov	r24, r24
    24d2:	90 e0       	ldi	r25, 0x00	; 0
    24d4:	ac 01       	movw	r20, r24
    24d6:	24 9f       	mul	r18, r20
    24d8:	c0 01       	movw	r24, r0
    24da:	25 9f       	mul	r18, r21
    24dc:	90 0d       	add	r25, r0
    24de:	34 9f       	mul	r19, r20
    24e0:	90 0d       	add	r25, r0
    24e2:	11 24       	eor	r1, r1
    24e4:	9c 83       	std	Y+4, r25	; 0x04
    24e6:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    24e8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ea:	9c 81       	ldd	r25, Y+4	; 0x04
    24ec:	4f 96       	adiw	r24, 0x1f	; 31
    24ee:	0e 94 d3 06 	call	0xda6	; 0xda6 <pvPortMalloc>
    24f2:	9e 83       	std	Y+6, r25	; 0x06
    24f4:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    24f6:	8d 81       	ldd	r24, Y+5	; 0x05
    24f8:	9e 81       	ldd	r25, Y+6	; 0x06
    24fa:	00 97       	sbiw	r24, 0x00	; 0
    24fc:	a1 f0       	breq	.+40     	; 0x2526 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    24fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2500:	9e 81       	ldd	r25, Y+6	; 0x06
    2502:	9a 83       	std	Y+2, r25	; 0x02
    2504:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2506:	89 81       	ldd	r24, Y+1	; 0x01
    2508:	9a 81       	ldd	r25, Y+2	; 0x02
    250a:	4f 96       	adiw	r24, 0x1f	; 31
    250c:	9a 83       	std	Y+2, r25	; 0x02
    250e:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2510:	29 81       	ldd	r18, Y+1	; 0x01
    2512:	3a 81       	ldd	r19, Y+2	; 0x02
    2514:	ed 81       	ldd	r30, Y+5	; 0x05
    2516:	fe 81       	ldd	r31, Y+6	; 0x06
    2518:	8f 81       	ldd	r24, Y+7	; 0x07
    251a:	68 85       	ldd	r22, Y+8	; 0x08
    251c:	a9 01       	movw	r20, r18
    251e:	29 85       	ldd	r18, Y+9	; 0x09
    2520:	8f 01       	movw	r16, r30
    2522:	0e 94 a0 12 	call	0x2540	; 0x2540 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    2526:	8d 81       	ldd	r24, Y+5	; 0x05
    2528:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    252a:	29 96       	adiw	r28, 0x09	; 9
    252c:	0f b6       	in	r0, 0x3f	; 63
    252e:	f8 94       	cli
    2530:	de bf       	out	0x3e, r29	; 62
    2532:	0f be       	out	0x3f, r0	; 63
    2534:	cd bf       	out	0x3d, r28	; 61
    2536:	cf 91       	pop	r28
    2538:	df 91       	pop	r29
    253a:	1f 91       	pop	r17
    253c:	0f 91       	pop	r16
    253e:	08 95       	ret

00002540 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    2540:	0f 93       	push	r16
    2542:	1f 93       	push	r17
    2544:	df 93       	push	r29
    2546:	cf 93       	push	r28
    2548:	cd b7       	in	r28, 0x3d	; 61
    254a:	de b7       	in	r29, 0x3e	; 62
    254c:	27 97       	sbiw	r28, 0x07	; 7
    254e:	0f b6       	in	r0, 0x3f	; 63
    2550:	f8 94       	cli
    2552:	de bf       	out	0x3e, r29	; 62
    2554:	0f be       	out	0x3f, r0	; 63
    2556:	cd bf       	out	0x3d, r28	; 61
    2558:	89 83       	std	Y+1, r24	; 0x01
    255a:	6a 83       	std	Y+2, r22	; 0x02
    255c:	5c 83       	std	Y+4, r21	; 0x04
    255e:	4b 83       	std	Y+3, r20	; 0x03
    2560:	2d 83       	std	Y+5, r18	; 0x05
    2562:	1f 83       	std	Y+7, r17	; 0x07
    2564:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    2566:	8a 81       	ldd	r24, Y+2	; 0x02
    2568:	88 23       	and	r24, r24
    256a:	39 f4       	brne	.+14     	; 0x257a <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    256c:	8e 81       	ldd	r24, Y+6	; 0x06
    256e:	9f 81       	ldd	r25, Y+7	; 0x07
    2570:	ee 81       	ldd	r30, Y+6	; 0x06
    2572:	ff 81       	ldd	r31, Y+7	; 0x07
    2574:	91 83       	std	Z+1, r25	; 0x01
    2576:	80 83       	st	Z, r24
    2578:	06 c0       	rjmp	.+12     	; 0x2586 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    257a:	8b 81       	ldd	r24, Y+3	; 0x03
    257c:	9c 81       	ldd	r25, Y+4	; 0x04
    257e:	ee 81       	ldd	r30, Y+6	; 0x06
    2580:	ff 81       	ldd	r31, Y+7	; 0x07
    2582:	91 83       	std	Z+1, r25	; 0x01
    2584:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2586:	ee 81       	ldd	r30, Y+6	; 0x06
    2588:	ff 81       	ldd	r31, Y+7	; 0x07
    258a:	89 81       	ldd	r24, Y+1	; 0x01
    258c:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    258e:	ee 81       	ldd	r30, Y+6	; 0x06
    2590:	ff 81       	ldd	r31, Y+7	; 0x07
    2592:	8a 81       	ldd	r24, Y+2	; 0x02
    2594:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2596:	8e 81       	ldd	r24, Y+6	; 0x06
    2598:	9f 81       	ldd	r25, Y+7	; 0x07
    259a:	61 e0       	ldi	r22, 0x01	; 1
    259c:	0e 94 81 11 	call	0x2302	; 0x2302 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    25a0:	27 96       	adiw	r28, 0x07	; 7
    25a2:	0f b6       	in	r0, 0x3f	; 63
    25a4:	f8 94       	cli
    25a6:	de bf       	out	0x3e, r29	; 62
    25a8:	0f be       	out	0x3f, r0	; 63
    25aa:	cd bf       	out	0x3d, r28	; 61
    25ac:	cf 91       	pop	r28
    25ae:	df 91       	pop	r29
    25b0:	1f 91       	pop	r17
    25b2:	0f 91       	pop	r16
    25b4:	08 95       	ret

000025b6 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    25b6:	df 93       	push	r29
    25b8:	cf 93       	push	r28
    25ba:	cd b7       	in	r28, 0x3d	; 61
    25bc:	de b7       	in	r29, 0x3e	; 62
    25be:	2f 97       	sbiw	r28, 0x0f	; 15
    25c0:	0f b6       	in	r0, 0x3f	; 63
    25c2:	f8 94       	cli
    25c4:	de bf       	out	0x3e, r29	; 62
    25c6:	0f be       	out	0x3f, r0	; 63
    25c8:	cd bf       	out	0x3d, r28	; 61
    25ca:	99 87       	std	Y+9, r25	; 0x09
    25cc:	88 87       	std	Y+8, r24	; 0x08
    25ce:	7b 87       	std	Y+11, r23	; 0x0b
    25d0:	6a 87       	std	Y+10, r22	; 0x0a
    25d2:	5d 87       	std	Y+13, r21	; 0x0d
    25d4:	4c 87       	std	Y+12, r20	; 0x0c
    25d6:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    25d8:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    25da:	88 85       	ldd	r24, Y+8	; 0x08
    25dc:	99 85       	ldd	r25, Y+9	; 0x09
    25de:	9a 83       	std	Y+2, r25	; 0x02
    25e0:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    25e2:	0f b6       	in	r0, 0x3f	; 63
    25e4:	f8 94       	cli
    25e6:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    25e8:	e9 81       	ldd	r30, Y+1	; 0x01
    25ea:	fa 81       	ldd	r31, Y+2	; 0x02
    25ec:	92 8d       	ldd	r25, Z+26	; 0x1a
    25ee:	e9 81       	ldd	r30, Y+1	; 0x01
    25f0:	fa 81       	ldd	r31, Y+2	; 0x02
    25f2:	83 8d       	ldd	r24, Z+27	; 0x1b
    25f4:	98 17       	cp	r25, r24
    25f6:	18 f0       	brcs	.+6      	; 0x25fe <xQueueGenericSend+0x48>
    25f8:	8e 85       	ldd	r24, Y+14	; 0x0e
    25fa:	82 30       	cpi	r24, 0x02	; 2
    25fc:	11 f5       	brne	.+68     	; 0x2642 <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    25fe:	89 81       	ldd	r24, Y+1	; 0x01
    2600:	9a 81       	ldd	r25, Y+2	; 0x02
    2602:	2a 85       	ldd	r18, Y+10	; 0x0a
    2604:	3b 85       	ldd	r19, Y+11	; 0x0b
    2606:	b9 01       	movw	r22, r18
    2608:	4e 85       	ldd	r20, Y+14	; 0x0e
    260a:	0e 94 31 17 	call	0x2e62	; 0x2e62 <prvCopyDataToQueue>
    260e:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2610:	e9 81       	ldd	r30, Y+1	; 0x01
    2612:	fa 81       	ldd	r31, Y+2	; 0x02
    2614:	81 89       	ldd	r24, Z+17	; 0x11
    2616:	88 23       	and	r24, r24
    2618:	51 f0       	breq	.+20     	; 0x262e <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    261a:	89 81       	ldd	r24, Y+1	; 0x01
    261c:	9a 81       	ldd	r25, Y+2	; 0x02
    261e:	41 96       	adiw	r24, 0x11	; 17
    2620:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    2624:	88 23       	and	r24, r24
    2626:	41 f0       	breq	.+16     	; 0x2638 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    2628:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    262c:	05 c0       	rjmp	.+10     	; 0x2638 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    262e:	8b 81       	ldd	r24, Y+3	; 0x03
    2630:	88 23       	and	r24, r24
    2632:	11 f0       	breq	.+4      	; 0x2638 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    2634:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    2638:	0f 90       	pop	r0
    263a:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    263c:	81 e0       	ldi	r24, 0x01	; 1
    263e:	8f 87       	std	Y+15, r24	; 0x0f
    2640:	5c c0       	rjmp	.+184    	; 0x26fa <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2642:	8c 85       	ldd	r24, Y+12	; 0x0c
    2644:	9d 85       	ldd	r25, Y+13	; 0x0d
    2646:	00 97       	sbiw	r24, 0x00	; 0
    2648:	21 f4       	brne	.+8      	; 0x2652 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    264a:	0f 90       	pop	r0
    264c:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    264e:	1f 86       	std	Y+15, r1	; 0x0f
    2650:	54 c0       	rjmp	.+168    	; 0x26fa <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    2652:	8c 81       	ldd	r24, Y+4	; 0x04
    2654:	88 23       	and	r24, r24
    2656:	31 f4       	brne	.+12     	; 0x2664 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2658:	ce 01       	movw	r24, r28
    265a:	05 96       	adiw	r24, 0x05	; 5
    265c:	0e 94 5e 25 	call	0x4abc	; 0x4abc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2660:	81 e0       	ldi	r24, 0x01	; 1
    2662:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2664:	0f 90       	pop	r0
    2666:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2668:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    266c:	0f b6       	in	r0, 0x3f	; 63
    266e:	f8 94       	cli
    2670:	0f 92       	push	r0
    2672:	e9 81       	ldd	r30, Y+1	; 0x01
    2674:	fa 81       	ldd	r31, Y+2	; 0x02
    2676:	85 8d       	ldd	r24, Z+29	; 0x1d
    2678:	8f 3f       	cpi	r24, 0xFF	; 255
    267a:	19 f4       	brne	.+6      	; 0x2682 <xQueueGenericSend+0xcc>
    267c:	e9 81       	ldd	r30, Y+1	; 0x01
    267e:	fa 81       	ldd	r31, Y+2	; 0x02
    2680:	15 8e       	std	Z+29, r1	; 0x1d
    2682:	e9 81       	ldd	r30, Y+1	; 0x01
    2684:	fa 81       	ldd	r31, Y+2	; 0x02
    2686:	86 8d       	ldd	r24, Z+30	; 0x1e
    2688:	8f 3f       	cpi	r24, 0xFF	; 255
    268a:	19 f4       	brne	.+6      	; 0x2692 <xQueueGenericSend+0xdc>
    268c:	e9 81       	ldd	r30, Y+1	; 0x01
    268e:	fa 81       	ldd	r31, Y+2	; 0x02
    2690:	16 8e       	std	Z+30, r1	; 0x1e
    2692:	0f 90       	pop	r0
    2694:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2696:	ce 01       	movw	r24, r28
    2698:	05 96       	adiw	r24, 0x05	; 5
    269a:	9e 01       	movw	r18, r28
    269c:	24 5f       	subi	r18, 0xF4	; 244
    269e:	3f 4f       	sbci	r19, 0xFF	; 255
    26a0:	b9 01       	movw	r22, r18
    26a2:	0e 94 77 25 	call	0x4aee	; 0x4aee <xTaskCheckForTimeOut>
    26a6:	88 23       	and	r24, r24
    26a8:	09 f5       	brne	.+66     	; 0x26ec <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    26aa:	89 81       	ldd	r24, Y+1	; 0x01
    26ac:	9a 81       	ldd	r25, Y+2	; 0x02
    26ae:	0e 94 ad 18 	call	0x315a	; 0x315a <prvIsQueueFull>
    26b2:	88 23       	and	r24, r24
    26b4:	a1 f0       	breq	.+40     	; 0x26de <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    26b6:	89 81       	ldd	r24, Y+1	; 0x01
    26b8:	9a 81       	ldd	r25, Y+2	; 0x02
    26ba:	08 96       	adiw	r24, 0x08	; 8
    26bc:	2c 85       	ldd	r18, Y+12	; 0x0c
    26be:	3d 85       	ldd	r19, Y+13	; 0x0d
    26c0:	b9 01       	movw	r22, r18
    26c2:	0e 94 05 22 	call	0x440a	; 0x440a <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    26c6:	89 81       	ldd	r24, Y+1	; 0x01
    26c8:	9a 81       	ldd	r25, Y+2	; 0x02
    26ca:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    26ce:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    26d2:	88 23       	and	r24, r24
    26d4:	09 f0       	breq	.+2      	; 0x26d8 <xQueueGenericSend+0x122>
    26d6:	85 cf       	rjmp	.-246    	; 0x25e2 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    26d8:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    26dc:	82 cf       	rjmp	.-252    	; 0x25e2 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    26de:	89 81       	ldd	r24, Y+1	; 0x01
    26e0:	9a 81       	ldd	r25, Y+2	; 0x02
    26e2:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    26e6:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    26ea:	7b cf       	rjmp	.-266    	; 0x25e2 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    26ec:	89 81       	ldd	r24, Y+1	; 0x01
    26ee:	9a 81       	ldd	r25, Y+2	; 0x02
    26f0:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    26f4:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    26f8:	1f 86       	std	Y+15, r1	; 0x0f
    26fa:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    26fc:	2f 96       	adiw	r28, 0x0f	; 15
    26fe:	0f b6       	in	r0, 0x3f	; 63
    2700:	f8 94       	cli
    2702:	de bf       	out	0x3e, r29	; 62
    2704:	0f be       	out	0x3f, r0	; 63
    2706:	cd bf       	out	0x3d, r28	; 61
    2708:	cf 91       	pop	r28
    270a:	df 91       	pop	r29
    270c:	08 95       	ret

0000270e <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    270e:	df 93       	push	r29
    2710:	cf 93       	push	r28
    2712:	cd b7       	in	r28, 0x3d	; 61
    2714:	de b7       	in	r29, 0x3e	; 62
    2716:	2d 97       	sbiw	r28, 0x0d	; 13
    2718:	0f b6       	in	r0, 0x3f	; 63
    271a:	f8 94       	cli
    271c:	de bf       	out	0x3e, r29	; 62
    271e:	0f be       	out	0x3f, r0	; 63
    2720:	cd bf       	out	0x3d, r28	; 61
    2722:	98 87       	std	Y+8, r25	; 0x08
    2724:	8f 83       	std	Y+7, r24	; 0x07
    2726:	7a 87       	std	Y+10, r23	; 0x0a
    2728:	69 87       	std	Y+9, r22	; 0x09
    272a:	5c 87       	std	Y+12, r21	; 0x0c
    272c:	4b 87       	std	Y+11, r20	; 0x0b
    272e:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2730:	8f 81       	ldd	r24, Y+7	; 0x07
    2732:	98 85       	ldd	r25, Y+8	; 0x08
    2734:	9c 83       	std	Y+4, r25	; 0x04
    2736:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2738:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    273a:	eb 81       	ldd	r30, Y+3	; 0x03
    273c:	fc 81       	ldd	r31, Y+4	; 0x04
    273e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2740:	eb 81       	ldd	r30, Y+3	; 0x03
    2742:	fc 81       	ldd	r31, Y+4	; 0x04
    2744:	83 8d       	ldd	r24, Z+27	; 0x1b
    2746:	98 17       	cp	r25, r24
    2748:	18 f0       	brcs	.+6      	; 0x2750 <xQueueGenericSendFromISR+0x42>
    274a:	8d 85       	ldd	r24, Y+13	; 0x0d
    274c:	82 30       	cpi	r24, 0x02	; 2
    274e:	81 f5       	brne	.+96     	; 0x27b0 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2750:	eb 81       	ldd	r30, Y+3	; 0x03
    2752:	fc 81       	ldd	r31, Y+4	; 0x04
    2754:	86 8d       	ldd	r24, Z+30	; 0x1e
    2756:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2758:	eb 81       	ldd	r30, Y+3	; 0x03
    275a:	fc 81       	ldd	r31, Y+4	; 0x04
    275c:	82 8d       	ldd	r24, Z+26	; 0x1a
    275e:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2760:	8b 81       	ldd	r24, Y+3	; 0x03
    2762:	9c 81       	ldd	r25, Y+4	; 0x04
    2764:	29 85       	ldd	r18, Y+9	; 0x09
    2766:	3a 85       	ldd	r19, Y+10	; 0x0a
    2768:	b9 01       	movw	r22, r18
    276a:	4d 85       	ldd	r20, Y+13	; 0x0d
    276c:	0e 94 31 17 	call	0x2e62	; 0x2e62 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2770:	8a 81       	ldd	r24, Y+2	; 0x02
    2772:	8f 3f       	cpi	r24, 0xFF	; 255
    2774:	a9 f4       	brne	.+42     	; 0x27a0 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2776:	eb 81       	ldd	r30, Y+3	; 0x03
    2778:	fc 81       	ldd	r31, Y+4	; 0x04
    277a:	81 89       	ldd	r24, Z+17	; 0x11
    277c:	88 23       	and	r24, r24
    277e:	a9 f0       	breq	.+42     	; 0x27aa <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2780:	8b 81       	ldd	r24, Y+3	; 0x03
    2782:	9c 81       	ldd	r25, Y+4	; 0x04
    2784:	41 96       	adiw	r24, 0x11	; 17
    2786:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    278a:	88 23       	and	r24, r24
    278c:	71 f0       	breq	.+28     	; 0x27aa <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    278e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2790:	9c 85       	ldd	r25, Y+12	; 0x0c
    2792:	00 97       	sbiw	r24, 0x00	; 0
    2794:	51 f0       	breq	.+20     	; 0x27aa <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2796:	eb 85       	ldd	r30, Y+11	; 0x0b
    2798:	fc 85       	ldd	r31, Y+12	; 0x0c
    279a:	81 e0       	ldi	r24, 0x01	; 1
    279c:	80 83       	st	Z, r24
    279e:	05 c0       	rjmp	.+10     	; 0x27aa <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    27a0:	8a 81       	ldd	r24, Y+2	; 0x02
    27a2:	8f 5f       	subi	r24, 0xFF	; 255
    27a4:	eb 81       	ldd	r30, Y+3	; 0x03
    27a6:	fc 81       	ldd	r31, Y+4	; 0x04
    27a8:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    27aa:	81 e0       	ldi	r24, 0x01	; 1
    27ac:	8e 83       	std	Y+6, r24	; 0x06
    27ae:	01 c0       	rjmp	.+2      	; 0x27b2 <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    27b0:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    27b2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    27b4:	2d 96       	adiw	r28, 0x0d	; 13
    27b6:	0f b6       	in	r0, 0x3f	; 63
    27b8:	f8 94       	cli
    27ba:	de bf       	out	0x3e, r29	; 62
    27bc:	0f be       	out	0x3f, r0	; 63
    27be:	cd bf       	out	0x3d, r28	; 61
    27c0:	cf 91       	pop	r28
    27c2:	df 91       	pop	r29
    27c4:	08 95       	ret

000027c6 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    27c6:	df 93       	push	r29
    27c8:	cf 93       	push	r28
    27ca:	cd b7       	in	r28, 0x3d	; 61
    27cc:	de b7       	in	r29, 0x3e	; 62
    27ce:	2a 97       	sbiw	r28, 0x0a	; 10
    27d0:	0f b6       	in	r0, 0x3f	; 63
    27d2:	f8 94       	cli
    27d4:	de bf       	out	0x3e, r29	; 62
    27d6:	0f be       	out	0x3f, r0	; 63
    27d8:	cd bf       	out	0x3d, r28	; 61
    27da:	98 87       	std	Y+8, r25	; 0x08
    27dc:	8f 83       	std	Y+7, r24	; 0x07
    27de:	7a 87       	std	Y+10, r23	; 0x0a
    27e0:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    27e2:	8f 81       	ldd	r24, Y+7	; 0x07
    27e4:	98 85       	ldd	r25, Y+8	; 0x08
    27e6:	9c 83       	std	Y+4, r25	; 0x04
    27e8:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    27ea:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    27ec:	eb 81       	ldd	r30, Y+3	; 0x03
    27ee:	fc 81       	ldd	r31, Y+4	; 0x04
    27f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    27f2:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    27f4:	eb 81       	ldd	r30, Y+3	; 0x03
    27f6:	fc 81       	ldd	r31, Y+4	; 0x04
    27f8:	93 8d       	ldd	r25, Z+27	; 0x1b
    27fa:	8a 81       	ldd	r24, Y+2	; 0x02
    27fc:	89 17       	cp	r24, r25
    27fe:	48 f5       	brcc	.+82     	; 0x2852 <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2800:	eb 81       	ldd	r30, Y+3	; 0x03
    2802:	fc 81       	ldd	r31, Y+4	; 0x04
    2804:	86 8d       	ldd	r24, Z+30	; 0x1e
    2806:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2808:	8a 81       	ldd	r24, Y+2	; 0x02
    280a:	8f 5f       	subi	r24, 0xFF	; 255
    280c:	eb 81       	ldd	r30, Y+3	; 0x03
    280e:	fc 81       	ldd	r31, Y+4	; 0x04
    2810:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2812:	89 81       	ldd	r24, Y+1	; 0x01
    2814:	8f 3f       	cpi	r24, 0xFF	; 255
    2816:	a9 f4       	brne	.+42     	; 0x2842 <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2818:	eb 81       	ldd	r30, Y+3	; 0x03
    281a:	fc 81       	ldd	r31, Y+4	; 0x04
    281c:	81 89       	ldd	r24, Z+17	; 0x11
    281e:	88 23       	and	r24, r24
    2820:	a9 f0       	breq	.+42     	; 0x284c <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2822:	8b 81       	ldd	r24, Y+3	; 0x03
    2824:	9c 81       	ldd	r25, Y+4	; 0x04
    2826:	41 96       	adiw	r24, 0x11	; 17
    2828:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    282c:	88 23       	and	r24, r24
    282e:	71 f0       	breq	.+28     	; 0x284c <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2830:	89 85       	ldd	r24, Y+9	; 0x09
    2832:	9a 85       	ldd	r25, Y+10	; 0x0a
    2834:	00 97       	sbiw	r24, 0x00	; 0
    2836:	51 f0       	breq	.+20     	; 0x284c <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2838:	e9 85       	ldd	r30, Y+9	; 0x09
    283a:	fa 85       	ldd	r31, Y+10	; 0x0a
    283c:	81 e0       	ldi	r24, 0x01	; 1
    283e:	80 83       	st	Z, r24
    2840:	05 c0       	rjmp	.+10     	; 0x284c <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2842:	89 81       	ldd	r24, Y+1	; 0x01
    2844:	8f 5f       	subi	r24, 0xFF	; 255
    2846:	eb 81       	ldd	r30, Y+3	; 0x03
    2848:	fc 81       	ldd	r31, Y+4	; 0x04
    284a:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    284c:	81 e0       	ldi	r24, 0x01	; 1
    284e:	8e 83       	std	Y+6, r24	; 0x06
    2850:	01 c0       	rjmp	.+2      	; 0x2854 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2852:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2854:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2856:	2a 96       	adiw	r28, 0x0a	; 10
    2858:	0f b6       	in	r0, 0x3f	; 63
    285a:	f8 94       	cli
    285c:	de bf       	out	0x3e, r29	; 62
    285e:	0f be       	out	0x3f, r0	; 63
    2860:	cd bf       	out	0x3d, r28	; 61
    2862:	cf 91       	pop	r28
    2864:	df 91       	pop	r29
    2866:	08 95       	ret

00002868 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    2868:	df 93       	push	r29
    286a:	cf 93       	push	r28
    286c:	cd b7       	in	r28, 0x3d	; 61
    286e:	de b7       	in	r29, 0x3e	; 62
    2870:	2e 97       	sbiw	r28, 0x0e	; 14
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	de bf       	out	0x3e, r29	; 62
    2878:	0f be       	out	0x3f, r0	; 63
    287a:	cd bf       	out	0x3d, r28	; 61
    287c:	99 87       	std	Y+9, r25	; 0x09
    287e:	88 87       	std	Y+8, r24	; 0x08
    2880:	7b 87       	std	Y+11, r23	; 0x0b
    2882:	6a 87       	std	Y+10, r22	; 0x0a
    2884:	5d 87       	std	Y+13, r21	; 0x0d
    2886:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    2888:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    288a:	88 85       	ldd	r24, Y+8	; 0x08
    288c:	99 85       	ldd	r25, Y+9	; 0x09
    288e:	9b 83       	std	Y+3, r25	; 0x03
    2890:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2892:	0f b6       	in	r0, 0x3f	; 63
    2894:	f8 94       	cli
    2896:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2898:	ea 81       	ldd	r30, Y+2	; 0x02
    289a:	fb 81       	ldd	r31, Y+3	; 0x03
    289c:	82 8d       	ldd	r24, Z+26	; 0x1a
    289e:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    28a0:	89 81       	ldd	r24, Y+1	; 0x01
    28a2:	88 23       	and	r24, r24
    28a4:	f9 f0       	breq	.+62     	; 0x28e4 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    28a6:	8a 81       	ldd	r24, Y+2	; 0x02
    28a8:	9b 81       	ldd	r25, Y+3	; 0x03
    28aa:	2a 85       	ldd	r18, Y+10	; 0x0a
    28ac:	3b 85       	ldd	r19, Y+11	; 0x0b
    28ae:	b9 01       	movw	r22, r18
    28b0:	0e 94 d7 17 	call	0x2fae	; 0x2fae <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    28b4:	89 81       	ldd	r24, Y+1	; 0x01
    28b6:	81 50       	subi	r24, 0x01	; 1
    28b8:	ea 81       	ldd	r30, Y+2	; 0x02
    28ba:	fb 81       	ldd	r31, Y+3	; 0x03
    28bc:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28be:	ea 81       	ldd	r30, Y+2	; 0x02
    28c0:	fb 81       	ldd	r31, Y+3	; 0x03
    28c2:	80 85       	ldd	r24, Z+8	; 0x08
    28c4:	88 23       	and	r24, r24
    28c6:	49 f0       	breq	.+18     	; 0x28da <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    28c8:	8a 81       	ldd	r24, Y+2	; 0x02
    28ca:	9b 81       	ldd	r25, Y+3	; 0x03
    28cc:	08 96       	adiw	r24, 0x08	; 8
    28ce:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    28d2:	88 23       	and	r24, r24
    28d4:	11 f0       	breq	.+4      	; 0x28da <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    28d6:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    28da:	0f 90       	pop	r0
    28dc:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    28de:	81 e0       	ldi	r24, 0x01	; 1
    28e0:	8e 87       	std	Y+14, r24	; 0x0e
    28e2:	63 c0       	rjmp	.+198    	; 0x29aa <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    28e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    28e6:	9d 85       	ldd	r25, Y+13	; 0x0d
    28e8:	00 97       	sbiw	r24, 0x00	; 0
    28ea:	21 f4       	brne	.+8      	; 0x28f4 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    28ec:	0f 90       	pop	r0
    28ee:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    28f0:	1e 86       	std	Y+14, r1	; 0x0e
    28f2:	5b c0       	rjmp	.+182    	; 0x29aa <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    28f4:	8c 81       	ldd	r24, Y+4	; 0x04
    28f6:	88 23       	and	r24, r24
    28f8:	31 f4       	brne	.+12     	; 0x2906 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    28fa:	ce 01       	movw	r24, r28
    28fc:	05 96       	adiw	r24, 0x05	; 5
    28fe:	0e 94 5e 25 	call	0x4abc	; 0x4abc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2902:	81 e0       	ldi	r24, 0x01	; 1
    2904:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2906:	0f 90       	pop	r0
    2908:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    290a:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    290e:	0f b6       	in	r0, 0x3f	; 63
    2910:	f8 94       	cli
    2912:	0f 92       	push	r0
    2914:	ea 81       	ldd	r30, Y+2	; 0x02
    2916:	fb 81       	ldd	r31, Y+3	; 0x03
    2918:	85 8d       	ldd	r24, Z+29	; 0x1d
    291a:	8f 3f       	cpi	r24, 0xFF	; 255
    291c:	19 f4       	brne	.+6      	; 0x2924 <xQueueReceive+0xbc>
    291e:	ea 81       	ldd	r30, Y+2	; 0x02
    2920:	fb 81       	ldd	r31, Y+3	; 0x03
    2922:	15 8e       	std	Z+29, r1	; 0x1d
    2924:	ea 81       	ldd	r30, Y+2	; 0x02
    2926:	fb 81       	ldd	r31, Y+3	; 0x03
    2928:	86 8d       	ldd	r24, Z+30	; 0x1e
    292a:	8f 3f       	cpi	r24, 0xFF	; 255
    292c:	19 f4       	brne	.+6      	; 0x2934 <xQueueReceive+0xcc>
    292e:	ea 81       	ldd	r30, Y+2	; 0x02
    2930:	fb 81       	ldd	r31, Y+3	; 0x03
    2932:	16 8e       	std	Z+30, r1	; 0x1e
    2934:	0f 90       	pop	r0
    2936:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2938:	ce 01       	movw	r24, r28
    293a:	05 96       	adiw	r24, 0x05	; 5
    293c:	9e 01       	movw	r18, r28
    293e:	24 5f       	subi	r18, 0xF4	; 244
    2940:	3f 4f       	sbci	r19, 0xFF	; 255
    2942:	b9 01       	movw	r22, r18
    2944:	0e 94 77 25 	call	0x4aee	; 0x4aee <xTaskCheckForTimeOut>
    2948:	88 23       	and	r24, r24
    294a:	09 f5       	brne	.+66     	; 0x298e <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    294c:	8a 81       	ldd	r24, Y+2	; 0x02
    294e:	9b 81       	ldd	r25, Y+3	; 0x03
    2950:	0e 94 71 18 	call	0x30e2	; 0x30e2 <prvIsQueueEmpty>
    2954:	88 23       	and	r24, r24
    2956:	a1 f0       	breq	.+40     	; 0x2980 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2958:	8a 81       	ldd	r24, Y+2	; 0x02
    295a:	9b 81       	ldd	r25, Y+3	; 0x03
    295c:	41 96       	adiw	r24, 0x11	; 17
    295e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2960:	3d 85       	ldd	r19, Y+13	; 0x0d
    2962:	b9 01       	movw	r22, r18
    2964:	0e 94 05 22 	call	0x440a	; 0x440a <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2968:	8a 81       	ldd	r24, Y+2	; 0x02
    296a:	9b 81       	ldd	r25, Y+3	; 0x03
    296c:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2970:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    2974:	88 23       	and	r24, r24
    2976:	09 f0       	breq	.+2      	; 0x297a <xQueueReceive+0x112>
    2978:	8c cf       	rjmp	.-232    	; 0x2892 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    297a:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    297e:	89 cf       	rjmp	.-238    	; 0x2892 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2980:	8a 81       	ldd	r24, Y+2	; 0x02
    2982:	9b 81       	ldd	r25, Y+3	; 0x03
    2984:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2988:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    298c:	82 cf       	rjmp	.-252    	; 0x2892 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    298e:	8a 81       	ldd	r24, Y+2	; 0x02
    2990:	9b 81       	ldd	r25, Y+3	; 0x03
    2992:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2996:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    299a:	8a 81       	ldd	r24, Y+2	; 0x02
    299c:	9b 81       	ldd	r25, Y+3	; 0x03
    299e:	0e 94 71 18 	call	0x30e2	; 0x30e2 <prvIsQueueEmpty>
    29a2:	88 23       	and	r24, r24
    29a4:	09 f4       	brne	.+2      	; 0x29a8 <xQueueReceive+0x140>
    29a6:	75 cf       	rjmp	.-278    	; 0x2892 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    29a8:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    29aa:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    29ac:	2e 96       	adiw	r28, 0x0e	; 14
    29ae:	0f b6       	in	r0, 0x3f	; 63
    29b0:	f8 94       	cli
    29b2:	de bf       	out	0x3e, r29	; 62
    29b4:	0f be       	out	0x3f, r0	; 63
    29b6:	cd bf       	out	0x3d, r28	; 61
    29b8:	cf 91       	pop	r28
    29ba:	df 91       	pop	r29
    29bc:	08 95       	ret

000029be <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    29be:	df 93       	push	r29
    29c0:	cf 93       	push	r28
    29c2:	cd b7       	in	r28, 0x3d	; 61
    29c4:	de b7       	in	r29, 0x3e	; 62
    29c6:	2c 97       	sbiw	r28, 0x0c	; 12
    29c8:	0f b6       	in	r0, 0x3f	; 63
    29ca:	f8 94       	cli
    29cc:	de bf       	out	0x3e, r29	; 62
    29ce:	0f be       	out	0x3f, r0	; 63
    29d0:	cd bf       	out	0x3d, r28	; 61
    29d2:	99 87       	std	Y+9, r25	; 0x09
    29d4:	88 87       	std	Y+8, r24	; 0x08
    29d6:	7b 87       	std	Y+11, r23	; 0x0b
    29d8:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    29da:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    29dc:	88 85       	ldd	r24, Y+8	; 0x08
    29de:	99 85       	ldd	r25, Y+9	; 0x09
    29e0:	9b 83       	std	Y+3, r25	; 0x03
    29e2:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    29e4:	0f b6       	in	r0, 0x3f	; 63
    29e6:	f8 94       	cli
    29e8:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    29ea:	ea 81       	ldd	r30, Y+2	; 0x02
    29ec:	fb 81       	ldd	r31, Y+3	; 0x03
    29ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    29f0:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    29f2:	89 81       	ldd	r24, Y+1	; 0x01
    29f4:	88 23       	and	r24, r24
    29f6:	c1 f0       	breq	.+48     	; 0x2a28 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    29f8:	89 81       	ldd	r24, Y+1	; 0x01
    29fa:	81 50       	subi	r24, 0x01	; 1
    29fc:	ea 81       	ldd	r30, Y+2	; 0x02
    29fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2a00:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a02:	ea 81       	ldd	r30, Y+2	; 0x02
    2a04:	fb 81       	ldd	r31, Y+3	; 0x03
    2a06:	80 85       	ldd	r24, Z+8	; 0x08
    2a08:	88 23       	and	r24, r24
    2a0a:	49 f0       	breq	.+18     	; 0x2a1e <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2a10:	08 96       	adiw	r24, 0x08	; 8
    2a12:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    2a16:	88 23       	and	r24, r24
    2a18:	11 f0       	breq	.+4      	; 0x2a1e <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2a1a:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2a1e:	0f 90       	pop	r0
    2a20:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2a22:	81 e0       	ldi	r24, 0x01	; 1
    2a24:	8c 87       	std	Y+12, r24	; 0x0c
    2a26:	63 c0       	rjmp	.+198    	; 0x2aee <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2a28:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a2a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a2c:	00 97       	sbiw	r24, 0x00	; 0
    2a2e:	21 f4       	brne	.+8      	; 0x2a38 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2a30:	0f 90       	pop	r0
    2a32:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2a34:	1c 86       	std	Y+12, r1	; 0x0c
    2a36:	5b c0       	rjmp	.+182    	; 0x2aee <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2a38:	8c 81       	ldd	r24, Y+4	; 0x04
    2a3a:	88 23       	and	r24, r24
    2a3c:	31 f4       	brne	.+12     	; 0x2a4a <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2a3e:	ce 01       	movw	r24, r28
    2a40:	05 96       	adiw	r24, 0x05	; 5
    2a42:	0e 94 5e 25 	call	0x4abc	; 0x4abc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2a46:	81 e0       	ldi	r24, 0x01	; 1
    2a48:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2a4a:	0f 90       	pop	r0
    2a4c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2a4e:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2a52:	0f b6       	in	r0, 0x3f	; 63
    2a54:	f8 94       	cli
    2a56:	0f 92       	push	r0
    2a58:	ea 81       	ldd	r30, Y+2	; 0x02
    2a5a:	fb 81       	ldd	r31, Y+3	; 0x03
    2a5c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a5e:	8f 3f       	cpi	r24, 0xFF	; 255
    2a60:	19 f4       	brne	.+6      	; 0x2a68 <xQueueSemaphoreTake+0xaa>
    2a62:	ea 81       	ldd	r30, Y+2	; 0x02
    2a64:	fb 81       	ldd	r31, Y+3	; 0x03
    2a66:	15 8e       	std	Z+29, r1	; 0x1d
    2a68:	ea 81       	ldd	r30, Y+2	; 0x02
    2a6a:	fb 81       	ldd	r31, Y+3	; 0x03
    2a6c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a6e:	8f 3f       	cpi	r24, 0xFF	; 255
    2a70:	19 f4       	brne	.+6      	; 0x2a78 <xQueueSemaphoreTake+0xba>
    2a72:	ea 81       	ldd	r30, Y+2	; 0x02
    2a74:	fb 81       	ldd	r31, Y+3	; 0x03
    2a76:	16 8e       	std	Z+30, r1	; 0x1e
    2a78:	0f 90       	pop	r0
    2a7a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2a7c:	ce 01       	movw	r24, r28
    2a7e:	05 96       	adiw	r24, 0x05	; 5
    2a80:	9e 01       	movw	r18, r28
    2a82:	26 5f       	subi	r18, 0xF6	; 246
    2a84:	3f 4f       	sbci	r19, 0xFF	; 255
    2a86:	b9 01       	movw	r22, r18
    2a88:	0e 94 77 25 	call	0x4aee	; 0x4aee <xTaskCheckForTimeOut>
    2a8c:	88 23       	and	r24, r24
    2a8e:	09 f5       	brne	.+66     	; 0x2ad2 <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a90:	8a 81       	ldd	r24, Y+2	; 0x02
    2a92:	9b 81       	ldd	r25, Y+3	; 0x03
    2a94:	0e 94 71 18 	call	0x30e2	; 0x30e2 <prvIsQueueEmpty>
    2a98:	88 23       	and	r24, r24
    2a9a:	a1 f0       	breq	.+40     	; 0x2ac4 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a9e:	9b 81       	ldd	r25, Y+3	; 0x03
    2aa0:	41 96       	adiw	r24, 0x11	; 17
    2aa2:	2a 85       	ldd	r18, Y+10	; 0x0a
    2aa4:	3b 85       	ldd	r19, Y+11	; 0x0b
    2aa6:	b9 01       	movw	r22, r18
    2aa8:	0e 94 05 22 	call	0x440a	; 0x440a <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2aac:	8a 81       	ldd	r24, Y+2	; 0x02
    2aae:	9b 81       	ldd	r25, Y+3	; 0x03
    2ab0:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2ab4:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    2ab8:	88 23       	and	r24, r24
    2aba:	09 f0       	breq	.+2      	; 0x2abe <xQueueSemaphoreTake+0x100>
    2abc:	93 cf       	rjmp	.-218    	; 0x29e4 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2abe:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    2ac2:	90 cf       	rjmp	.-224    	; 0x29e4 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2ac4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac8:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2acc:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    2ad0:	89 cf       	rjmp	.-238    	; 0x29e4 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ad6:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2ada:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2ade:	8a 81       	ldd	r24, Y+2	; 0x02
    2ae0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ae2:	0e 94 71 18 	call	0x30e2	; 0x30e2 <prvIsQueueEmpty>
    2ae6:	88 23       	and	r24, r24
    2ae8:	09 f4       	brne	.+2      	; 0x2aec <xQueueSemaphoreTake+0x12e>
    2aea:	7c cf       	rjmp	.-264    	; 0x29e4 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2aec:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2aee:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2af0:	2c 96       	adiw	r28, 0x0c	; 12
    2af2:	0f b6       	in	r0, 0x3f	; 63
    2af4:	f8 94       	cli
    2af6:	de bf       	out	0x3e, r29	; 62
    2af8:	0f be       	out	0x3f, r0	; 63
    2afa:	cd bf       	out	0x3d, r28	; 61
    2afc:	cf 91       	pop	r28
    2afe:	df 91       	pop	r29
    2b00:	08 95       	ret

00002b02 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2b02:	df 93       	push	r29
    2b04:	cf 93       	push	r28
    2b06:	cd b7       	in	r28, 0x3d	; 61
    2b08:	de b7       	in	r29, 0x3e	; 62
    2b0a:	60 97       	sbiw	r28, 0x10	; 16
    2b0c:	0f b6       	in	r0, 0x3f	; 63
    2b0e:	f8 94       	cli
    2b10:	de bf       	out	0x3e, r29	; 62
    2b12:	0f be       	out	0x3f, r0	; 63
    2b14:	cd bf       	out	0x3d, r28	; 61
    2b16:	9b 87       	std	Y+11, r25	; 0x0b
    2b18:	8a 87       	std	Y+10, r24	; 0x0a
    2b1a:	7d 87       	std	Y+13, r23	; 0x0d
    2b1c:	6c 87       	std	Y+12, r22	; 0x0c
    2b1e:	5f 87       	std	Y+15, r21	; 0x0f
    2b20:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    2b22:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2b24:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b26:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b28:	9b 83       	std	Y+3, r25	; 0x03
    2b2a:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2b2c:	0f b6       	in	r0, 0x3f	; 63
    2b2e:	f8 94       	cli
    2b30:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2b32:	ea 81       	ldd	r30, Y+2	; 0x02
    2b34:	fb 81       	ldd	r31, Y+3	; 0x03
    2b36:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b38:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b3a:	89 81       	ldd	r24, Y+1	; 0x01
    2b3c:	88 23       	and	r24, r24
    2b3e:	31 f1       	breq	.+76     	; 0x2b8c <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2b40:	ea 81       	ldd	r30, Y+2	; 0x02
    2b42:	fb 81       	ldd	r31, Y+3	; 0x03
    2b44:	86 81       	ldd	r24, Z+6	; 0x06
    2b46:	97 81       	ldd	r25, Z+7	; 0x07
    2b48:	9d 83       	std	Y+5, r25	; 0x05
    2b4a:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2b4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b50:	2c 85       	ldd	r18, Y+12	; 0x0c
    2b52:	3d 85       	ldd	r19, Y+13	; 0x0d
    2b54:	b9 01       	movw	r22, r18
    2b56:	0e 94 d7 17 	call	0x2fae	; 0x2fae <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2b5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b5e:	8c 81       	ldd	r24, Y+4	; 0x04
    2b60:	9d 81       	ldd	r25, Y+5	; 0x05
    2b62:	97 83       	std	Z+7, r25	; 0x07
    2b64:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b66:	ea 81       	ldd	r30, Y+2	; 0x02
    2b68:	fb 81       	ldd	r31, Y+3	; 0x03
    2b6a:	81 89       	ldd	r24, Z+17	; 0x11
    2b6c:	88 23       	and	r24, r24
    2b6e:	49 f0       	breq	.+18     	; 0x2b82 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b70:	8a 81       	ldd	r24, Y+2	; 0x02
    2b72:	9b 81       	ldd	r25, Y+3	; 0x03
    2b74:	41 96       	adiw	r24, 0x11	; 17
    2b76:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    2b7a:	88 23       	and	r24, r24
    2b7c:	11 f0       	breq	.+4      	; 0x2b82 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2b7e:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2b82:	0f 90       	pop	r0
    2b84:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2b86:	81 e0       	ldi	r24, 0x01	; 1
    2b88:	88 8b       	std	Y+16, r24	; 0x10
    2b8a:	63 c0       	rjmp	.+198    	; 0x2c52 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2b8c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2b8e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2b90:	00 97       	sbiw	r24, 0x00	; 0
    2b92:	21 f4       	brne	.+8      	; 0x2b9c <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2b94:	0f 90       	pop	r0
    2b96:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2b98:	18 8a       	std	Y+16, r1	; 0x10
    2b9a:	5b c0       	rjmp	.+182    	; 0x2c52 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2b9c:	8e 81       	ldd	r24, Y+6	; 0x06
    2b9e:	88 23       	and	r24, r24
    2ba0:	31 f4       	brne	.+12     	; 0x2bae <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2ba2:	ce 01       	movw	r24, r28
    2ba4:	07 96       	adiw	r24, 0x07	; 7
    2ba6:	0e 94 5e 25 	call	0x4abc	; 0x4abc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2baa:	81 e0       	ldi	r24, 0x01	; 1
    2bac:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2bae:	0f 90       	pop	r0
    2bb0:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2bb2:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2bb6:	0f b6       	in	r0, 0x3f	; 63
    2bb8:	f8 94       	cli
    2bba:	0f 92       	push	r0
    2bbc:	ea 81       	ldd	r30, Y+2	; 0x02
    2bbe:	fb 81       	ldd	r31, Y+3	; 0x03
    2bc0:	85 8d       	ldd	r24, Z+29	; 0x1d
    2bc2:	8f 3f       	cpi	r24, 0xFF	; 255
    2bc4:	19 f4       	brne	.+6      	; 0x2bcc <xQueuePeek+0xca>
    2bc6:	ea 81       	ldd	r30, Y+2	; 0x02
    2bc8:	fb 81       	ldd	r31, Y+3	; 0x03
    2bca:	15 8e       	std	Z+29, r1	; 0x1d
    2bcc:	ea 81       	ldd	r30, Y+2	; 0x02
    2bce:	fb 81       	ldd	r31, Y+3	; 0x03
    2bd0:	86 8d       	ldd	r24, Z+30	; 0x1e
    2bd2:	8f 3f       	cpi	r24, 0xFF	; 255
    2bd4:	19 f4       	brne	.+6      	; 0x2bdc <xQueuePeek+0xda>
    2bd6:	ea 81       	ldd	r30, Y+2	; 0x02
    2bd8:	fb 81       	ldd	r31, Y+3	; 0x03
    2bda:	16 8e       	std	Z+30, r1	; 0x1e
    2bdc:	0f 90       	pop	r0
    2bde:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2be0:	ce 01       	movw	r24, r28
    2be2:	07 96       	adiw	r24, 0x07	; 7
    2be4:	9e 01       	movw	r18, r28
    2be6:	22 5f       	subi	r18, 0xF2	; 242
    2be8:	3f 4f       	sbci	r19, 0xFF	; 255
    2bea:	b9 01       	movw	r22, r18
    2bec:	0e 94 77 25 	call	0x4aee	; 0x4aee <xTaskCheckForTimeOut>
    2bf0:	88 23       	and	r24, r24
    2bf2:	09 f5       	brne	.+66     	; 0x2c36 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    2bf6:	9b 81       	ldd	r25, Y+3	; 0x03
    2bf8:	0e 94 71 18 	call	0x30e2	; 0x30e2 <prvIsQueueEmpty>
    2bfc:	88 23       	and	r24, r24
    2bfe:	a1 f0       	breq	.+40     	; 0x2c28 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2c00:	8a 81       	ldd	r24, Y+2	; 0x02
    2c02:	9b 81       	ldd	r25, Y+3	; 0x03
    2c04:	41 96       	adiw	r24, 0x11	; 17
    2c06:	2e 85       	ldd	r18, Y+14	; 0x0e
    2c08:	3f 85       	ldd	r19, Y+15	; 0x0f
    2c0a:	b9 01       	movw	r22, r18
    2c0c:	0e 94 05 22 	call	0x440a	; 0x440a <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2c10:	8a 81       	ldd	r24, Y+2	; 0x02
    2c12:	9b 81       	ldd	r25, Y+3	; 0x03
    2c14:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2c18:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    2c1c:	88 23       	and	r24, r24
    2c1e:	09 f0       	breq	.+2      	; 0x2c22 <xQueuePeek+0x120>
    2c20:	85 cf       	rjmp	.-246    	; 0x2b2c <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    2c22:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    2c26:	82 cf       	rjmp	.-252    	; 0x2b2c <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2c28:	8a 81       	ldd	r24, Y+2	; 0x02
    2c2a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c2c:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2c30:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    2c34:	7b cf       	rjmp	.-266    	; 0x2b2c <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2c36:	8a 81       	ldd	r24, Y+2	; 0x02
    2c38:	9b 81       	ldd	r25, Y+3	; 0x03
    2c3a:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2c3e:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c42:	8a 81       	ldd	r24, Y+2	; 0x02
    2c44:	9b 81       	ldd	r25, Y+3	; 0x03
    2c46:	0e 94 71 18 	call	0x30e2	; 0x30e2 <prvIsQueueEmpty>
    2c4a:	88 23       	and	r24, r24
    2c4c:	09 f4       	brne	.+2      	; 0x2c50 <xQueuePeek+0x14e>
    2c4e:	6e cf       	rjmp	.-292    	; 0x2b2c <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2c50:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2c52:	88 89       	ldd	r24, Y+16	; 0x10
}
    2c54:	60 96       	adiw	r28, 0x10	; 16
    2c56:	0f b6       	in	r0, 0x3f	; 63
    2c58:	f8 94       	cli
    2c5a:	de bf       	out	0x3e, r29	; 62
    2c5c:	0f be       	out	0x3f, r0	; 63
    2c5e:	cd bf       	out	0x3d, r28	; 61
    2c60:	cf 91       	pop	r28
    2c62:	df 91       	pop	r29
    2c64:	08 95       	ret

00002c66 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2c66:	df 93       	push	r29
    2c68:	cf 93       	push	r28
    2c6a:	cd b7       	in	r28, 0x3d	; 61
    2c6c:	de b7       	in	r29, 0x3e	; 62
    2c6e:	2c 97       	sbiw	r28, 0x0c	; 12
    2c70:	0f b6       	in	r0, 0x3f	; 63
    2c72:	f8 94       	cli
    2c74:	de bf       	out	0x3e, r29	; 62
    2c76:	0f be       	out	0x3f, r0	; 63
    2c78:	cd bf       	out	0x3d, r28	; 61
    2c7a:	98 87       	std	Y+8, r25	; 0x08
    2c7c:	8f 83       	std	Y+7, r24	; 0x07
    2c7e:	7a 87       	std	Y+10, r23	; 0x0a
    2c80:	69 87       	std	Y+9, r22	; 0x09
    2c82:	5c 87       	std	Y+12, r21	; 0x0c
    2c84:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2c86:	8f 81       	ldd	r24, Y+7	; 0x07
    2c88:	98 85       	ldd	r25, Y+8	; 0x08
    2c8a:	9c 83       	std	Y+4, r25	; 0x04
    2c8c:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2c8e:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2c90:	eb 81       	ldd	r30, Y+3	; 0x03
    2c92:	fc 81       	ldd	r31, Y+4	; 0x04
    2c94:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c96:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2c98:	8a 81       	ldd	r24, Y+2	; 0x02
    2c9a:	88 23       	and	r24, r24
    2c9c:	81 f1       	breq	.+96     	; 0x2cfe <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2c9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2ca0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca2:	85 8d       	ldd	r24, Z+29	; 0x1d
    2ca4:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2ca6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca8:	9c 81       	ldd	r25, Y+4	; 0x04
    2caa:	29 85       	ldd	r18, Y+9	; 0x09
    2cac:	3a 85       	ldd	r19, Y+10	; 0x0a
    2cae:	b9 01       	movw	r22, r18
    2cb0:	0e 94 d7 17 	call	0x2fae	; 0x2fae <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2cb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb6:	81 50       	subi	r24, 0x01	; 1
    2cb8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cba:	fc 81       	ldd	r31, Y+4	; 0x04
    2cbc:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2cbe:	89 81       	ldd	r24, Y+1	; 0x01
    2cc0:	8f 3f       	cpi	r24, 0xFF	; 255
    2cc2:	a9 f4       	brne	.+42     	; 0x2cee <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2cc4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc8:	80 85       	ldd	r24, Z+8	; 0x08
    2cca:	88 23       	and	r24, r24
    2ccc:	a9 f0       	breq	.+42     	; 0x2cf8 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2cce:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd2:	08 96       	adiw	r24, 0x08	; 8
    2cd4:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    2cd8:	88 23       	and	r24, r24
    2cda:	71 f0       	breq	.+28     	; 0x2cf8 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2cdc:	8b 85       	ldd	r24, Y+11	; 0x0b
    2cde:	9c 85       	ldd	r25, Y+12	; 0x0c
    2ce0:	00 97       	sbiw	r24, 0x00	; 0
    2ce2:	51 f0       	breq	.+20     	; 0x2cf8 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    2ce4:	eb 85       	ldd	r30, Y+11	; 0x0b
    2ce6:	fc 85       	ldd	r31, Y+12	; 0x0c
    2ce8:	81 e0       	ldi	r24, 0x01	; 1
    2cea:	80 83       	st	Z, r24
    2cec:	05 c0       	rjmp	.+10     	; 0x2cf8 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2cee:	89 81       	ldd	r24, Y+1	; 0x01
    2cf0:	8f 5f       	subi	r24, 0xFF	; 255
    2cf2:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf4:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf6:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    2cf8:	81 e0       	ldi	r24, 0x01	; 1
    2cfa:	8e 83       	std	Y+6, r24	; 0x06
    2cfc:	01 c0       	rjmp	.+2      	; 0x2d00 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    2cfe:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2d00:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2d02:	2c 96       	adiw	r28, 0x0c	; 12
    2d04:	0f b6       	in	r0, 0x3f	; 63
    2d06:	f8 94       	cli
    2d08:	de bf       	out	0x3e, r29	; 62
    2d0a:	0f be       	out	0x3f, r0	; 63
    2d0c:	cd bf       	out	0x3d, r28	; 61
    2d0e:	cf 91       	pop	r28
    2d10:	df 91       	pop	r29
    2d12:	08 95       	ret

00002d14 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2d14:	df 93       	push	r29
    2d16:	cf 93       	push	r28
    2d18:	cd b7       	in	r28, 0x3d	; 61
    2d1a:	de b7       	in	r29, 0x3e	; 62
    2d1c:	2a 97       	sbiw	r28, 0x0a	; 10
    2d1e:	0f b6       	in	r0, 0x3f	; 63
    2d20:	f8 94       	cli
    2d22:	de bf       	out	0x3e, r29	; 62
    2d24:	0f be       	out	0x3f, r0	; 63
    2d26:	cd bf       	out	0x3d, r28	; 61
    2d28:	98 87       	std	Y+8, r25	; 0x08
    2d2a:	8f 83       	std	Y+7, r24	; 0x07
    2d2c:	7a 87       	std	Y+10, r23	; 0x0a
    2d2e:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2d30:	8f 81       	ldd	r24, Y+7	; 0x07
    2d32:	98 85       	ldd	r25, Y+8	; 0x08
    2d34:	9a 83       	std	Y+2, r25	; 0x02
    2d36:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d38:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d40:	88 23       	and	r24, r24
    2d42:	b1 f0       	breq	.+44     	; 0x2d70 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2d44:	e9 81       	ldd	r30, Y+1	; 0x01
    2d46:	fa 81       	ldd	r31, Y+2	; 0x02
    2d48:	86 81       	ldd	r24, Z+6	; 0x06
    2d4a:	97 81       	ldd	r25, Z+7	; 0x07
    2d4c:	9c 83       	std	Y+4, r25	; 0x04
    2d4e:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2d50:	89 81       	ldd	r24, Y+1	; 0x01
    2d52:	9a 81       	ldd	r25, Y+2	; 0x02
    2d54:	29 85       	ldd	r18, Y+9	; 0x09
    2d56:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d58:	b9 01       	movw	r22, r18
    2d5a:	0e 94 d7 17 	call	0x2fae	; 0x2fae <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d60:	fa 81       	ldd	r31, Y+2	; 0x02
    2d62:	8b 81       	ldd	r24, Y+3	; 0x03
    2d64:	9c 81       	ldd	r25, Y+4	; 0x04
    2d66:	97 83       	std	Z+7, r25	; 0x07
    2d68:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2d6a:	81 e0       	ldi	r24, 0x01	; 1
    2d6c:	8e 83       	std	Y+6, r24	; 0x06
    2d6e:	01 c0       	rjmp	.+2      	; 0x2d72 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    2d70:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2d72:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2d74:	2a 96       	adiw	r28, 0x0a	; 10
    2d76:	0f b6       	in	r0, 0x3f	; 63
    2d78:	f8 94       	cli
    2d7a:	de bf       	out	0x3e, r29	; 62
    2d7c:	0f be       	out	0x3f, r0	; 63
    2d7e:	cd bf       	out	0x3d, r28	; 61
    2d80:	cf 91       	pop	r28
    2d82:	df 91       	pop	r29
    2d84:	08 95       	ret

00002d86 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2d86:	df 93       	push	r29
    2d88:	cf 93       	push	r28
    2d8a:	00 d0       	rcall	.+0      	; 0x2d8c <uxQueueMessagesWaiting+0x6>
    2d8c:	0f 92       	push	r0
    2d8e:	cd b7       	in	r28, 0x3d	; 61
    2d90:	de b7       	in	r29, 0x3e	; 62
    2d92:	9b 83       	std	Y+3, r25	; 0x03
    2d94:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    2d96:	0f b6       	in	r0, 0x3f	; 63
    2d98:	f8 94       	cli
    2d9a:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2d9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2d9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2da0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2da2:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2da4:	0f 90       	pop	r0
    2da6:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2da8:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2daa:	0f 90       	pop	r0
    2dac:	0f 90       	pop	r0
    2dae:	0f 90       	pop	r0
    2db0:	cf 91       	pop	r28
    2db2:	df 91       	pop	r29
    2db4:	08 95       	ret

00002db6 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2db6:	df 93       	push	r29
    2db8:	cf 93       	push	r28
    2dba:	00 d0       	rcall	.+0      	; 0x2dbc <uxQueueSpacesAvailable+0x6>
    2dbc:	00 d0       	rcall	.+0      	; 0x2dbe <uxQueueSpacesAvailable+0x8>
    2dbe:	0f 92       	push	r0
    2dc0:	cd b7       	in	r28, 0x3d	; 61
    2dc2:	de b7       	in	r29, 0x3e	; 62
    2dc4:	9d 83       	std	Y+5, r25	; 0x05
    2dc6:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2dc8:	8c 81       	ldd	r24, Y+4	; 0x04
    2dca:	9d 81       	ldd	r25, Y+5	; 0x05
    2dcc:	9a 83       	std	Y+2, r25	; 0x02
    2dce:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2dd0:	0f b6       	in	r0, 0x3f	; 63
    2dd2:	f8 94       	cli
    2dd4:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2dd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dda:	93 8d       	ldd	r25, Z+27	; 0x1b
    2ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dde:	fa 81       	ldd	r31, Y+2	; 0x02
    2de0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2de2:	29 2f       	mov	r18, r25
    2de4:	28 1b       	sub	r18, r24
    2de6:	82 2f       	mov	r24, r18
    2de8:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    2dea:	0f 90       	pop	r0
    2dec:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2dee:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2df0:	0f 90       	pop	r0
    2df2:	0f 90       	pop	r0
    2df4:	0f 90       	pop	r0
    2df6:	0f 90       	pop	r0
    2df8:	0f 90       	pop	r0
    2dfa:	cf 91       	pop	r28
    2dfc:	df 91       	pop	r29
    2dfe:	08 95       	ret

00002e00 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2e00:	df 93       	push	r29
    2e02:	cf 93       	push	r28
    2e04:	00 d0       	rcall	.+0      	; 0x2e06 <uxQueueMessagesWaitingFromISR+0x6>
    2e06:	00 d0       	rcall	.+0      	; 0x2e08 <uxQueueMessagesWaitingFromISR+0x8>
    2e08:	0f 92       	push	r0
    2e0a:	cd b7       	in	r28, 0x3d	; 61
    2e0c:	de b7       	in	r29, 0x3e	; 62
    2e0e:	9d 83       	std	Y+5, r25	; 0x05
    2e10:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2e12:	8c 81       	ldd	r24, Y+4	; 0x04
    2e14:	9d 81       	ldd	r25, Y+5	; 0x05
    2e16:	9a 83       	std	Y+2, r25	; 0x02
    2e18:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e20:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    2e22:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e24:	0f 90       	pop	r0
    2e26:	0f 90       	pop	r0
    2e28:	0f 90       	pop	r0
    2e2a:	0f 90       	pop	r0
    2e2c:	0f 90       	pop	r0
    2e2e:	cf 91       	pop	r28
    2e30:	df 91       	pop	r29
    2e32:	08 95       	ret

00002e34 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2e34:	df 93       	push	r29
    2e36:	cf 93       	push	r28
    2e38:	00 d0       	rcall	.+0      	; 0x2e3a <vQueueDelete+0x6>
    2e3a:	00 d0       	rcall	.+0      	; 0x2e3c <vQueueDelete+0x8>
    2e3c:	cd b7       	in	r28, 0x3d	; 61
    2e3e:	de b7       	in	r29, 0x3e	; 62
    2e40:	9c 83       	std	Y+4, r25	; 0x04
    2e42:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    2e44:	8b 81       	ldd	r24, Y+3	; 0x03
    2e46:	9c 81       	ldd	r25, Y+4	; 0x04
    2e48:	9a 83       	std	Y+2, r25	; 0x02
    2e4a:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2e4c:	89 81       	ldd	r24, Y+1	; 0x01
    2e4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e50:	0e 94 2d 07 	call	0xe5a	; 0xe5a <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2e54:	0f 90       	pop	r0
    2e56:	0f 90       	pop	r0
    2e58:	0f 90       	pop	r0
    2e5a:	0f 90       	pop	r0
    2e5c:	cf 91       	pop	r28
    2e5e:	df 91       	pop	r29
    2e60:	08 95       	ret

00002e62 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    2e62:	df 93       	push	r29
    2e64:	cf 93       	push	r28
    2e66:	cd b7       	in	r28, 0x3d	; 61
    2e68:	de b7       	in	r29, 0x3e	; 62
    2e6a:	27 97       	sbiw	r28, 0x07	; 7
    2e6c:	0f b6       	in	r0, 0x3f	; 63
    2e6e:	f8 94       	cli
    2e70:	de bf       	out	0x3e, r29	; 62
    2e72:	0f be       	out	0x3f, r0	; 63
    2e74:	cd bf       	out	0x3d, r28	; 61
    2e76:	9c 83       	std	Y+4, r25	; 0x04
    2e78:	8b 83       	std	Y+3, r24	; 0x03
    2e7a:	7e 83       	std	Y+6, r23	; 0x06
    2e7c:	6d 83       	std	Y+5, r22	; 0x05
    2e7e:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    2e80:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2e82:	eb 81       	ldd	r30, Y+3	; 0x03
    2e84:	fc 81       	ldd	r31, Y+4	; 0x04
    2e86:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e88:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2e8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e90:	88 23       	and	r24, r24
    2e92:	09 f4       	brne	.+2      	; 0x2e96 <prvCopyDataToQueue+0x34>
    2e94:	7d c0       	rjmp	.+250    	; 0x2f90 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    2e96:	8f 81       	ldd	r24, Y+7	; 0x07
    2e98:	88 23       	and	r24, r24
    2e9a:	99 f5       	brne	.+102    	; 0x2f02 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2e9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2ea0:	62 81       	ldd	r22, Z+2	; 0x02
    2ea2:	73 81       	ldd	r23, Z+3	; 0x03
    2ea4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ea6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ea8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2eaa:	48 2f       	mov	r20, r24
    2eac:	50 e0       	ldi	r21, 0x00	; 0
    2eae:	2d 81       	ldd	r18, Y+5	; 0x05
    2eb0:	3e 81       	ldd	r19, Y+6	; 0x06
    2eb2:	cb 01       	movw	r24, r22
    2eb4:	b9 01       	movw	r22, r18
    2eb6:	0e 94 3a 3e 	call	0x7c74	; 0x7c74 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2eba:	eb 81       	ldd	r30, Y+3	; 0x03
    2ebc:	fc 81       	ldd	r31, Y+4	; 0x04
    2ebe:	22 81       	ldd	r18, Z+2	; 0x02
    2ec0:	33 81       	ldd	r19, Z+3	; 0x03
    2ec2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ec4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ec6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ec8:	88 2f       	mov	r24, r24
    2eca:	90 e0       	ldi	r25, 0x00	; 0
    2ecc:	82 0f       	add	r24, r18
    2ece:	93 1f       	adc	r25, r19
    2ed0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ed2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ed4:	93 83       	std	Z+3, r25	; 0x03
    2ed6:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2ed8:	eb 81       	ldd	r30, Y+3	; 0x03
    2eda:	fc 81       	ldd	r31, Y+4	; 0x04
    2edc:	22 81       	ldd	r18, Z+2	; 0x02
    2ede:	33 81       	ldd	r19, Z+3	; 0x03
    2ee0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ee2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ee4:	84 81       	ldd	r24, Z+4	; 0x04
    2ee6:	95 81       	ldd	r25, Z+5	; 0x05
    2ee8:	28 17       	cp	r18, r24
    2eea:	39 07       	cpc	r19, r25
    2eec:	08 f4       	brcc	.+2      	; 0x2ef0 <prvCopyDataToQueue+0x8e>
    2eee:	50 c0       	rjmp	.+160    	; 0x2f90 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2ef0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ef2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ef4:	80 81       	ld	r24, Z
    2ef6:	91 81       	ldd	r25, Z+1	; 0x01
    2ef8:	eb 81       	ldd	r30, Y+3	; 0x03
    2efa:	fc 81       	ldd	r31, Y+4	; 0x04
    2efc:	93 83       	std	Z+3, r25	; 0x03
    2efe:	82 83       	std	Z+2, r24	; 0x02
    2f00:	47 c0       	rjmp	.+142    	; 0x2f90 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2f02:	eb 81       	ldd	r30, Y+3	; 0x03
    2f04:	fc 81       	ldd	r31, Y+4	; 0x04
    2f06:	66 81       	ldd	r22, Z+6	; 0x06
    2f08:	77 81       	ldd	r23, Z+7	; 0x07
    2f0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f0e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f10:	48 2f       	mov	r20, r24
    2f12:	50 e0       	ldi	r21, 0x00	; 0
    2f14:	2d 81       	ldd	r18, Y+5	; 0x05
    2f16:	3e 81       	ldd	r19, Y+6	; 0x06
    2f18:	cb 01       	movw	r24, r22
    2f1a:	b9 01       	movw	r22, r18
    2f1c:	0e 94 3a 3e 	call	0x7c74	; 0x7c74 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2f20:	eb 81       	ldd	r30, Y+3	; 0x03
    2f22:	fc 81       	ldd	r31, Y+4	; 0x04
    2f24:	26 81       	ldd	r18, Z+6	; 0x06
    2f26:	37 81       	ldd	r19, Z+7	; 0x07
    2f28:	eb 81       	ldd	r30, Y+3	; 0x03
    2f2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f2c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f2e:	88 2f       	mov	r24, r24
    2f30:	90 e0       	ldi	r25, 0x00	; 0
    2f32:	90 95       	com	r25
    2f34:	81 95       	neg	r24
    2f36:	9f 4f       	sbci	r25, 0xFF	; 255
    2f38:	82 0f       	add	r24, r18
    2f3a:	93 1f       	adc	r25, r19
    2f3c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f3e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f40:	97 83       	std	Z+7, r25	; 0x07
    2f42:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2f44:	eb 81       	ldd	r30, Y+3	; 0x03
    2f46:	fc 81       	ldd	r31, Y+4	; 0x04
    2f48:	26 81       	ldd	r18, Z+6	; 0x06
    2f4a:	37 81       	ldd	r19, Z+7	; 0x07
    2f4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f50:	80 81       	ld	r24, Z
    2f52:	91 81       	ldd	r25, Z+1	; 0x01
    2f54:	28 17       	cp	r18, r24
    2f56:	39 07       	cpc	r19, r25
    2f58:	90 f4       	brcc	.+36     	; 0x2f7e <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2f5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f5e:	24 81       	ldd	r18, Z+4	; 0x04
    2f60:	35 81       	ldd	r19, Z+5	; 0x05
    2f62:	eb 81       	ldd	r30, Y+3	; 0x03
    2f64:	fc 81       	ldd	r31, Y+4	; 0x04
    2f66:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f68:	88 2f       	mov	r24, r24
    2f6a:	90 e0       	ldi	r25, 0x00	; 0
    2f6c:	90 95       	com	r25
    2f6e:	81 95       	neg	r24
    2f70:	9f 4f       	sbci	r25, 0xFF	; 255
    2f72:	82 0f       	add	r24, r18
    2f74:	93 1f       	adc	r25, r19
    2f76:	eb 81       	ldd	r30, Y+3	; 0x03
    2f78:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7a:	97 83       	std	Z+7, r25	; 0x07
    2f7c:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    2f7e:	8f 81       	ldd	r24, Y+7	; 0x07
    2f80:	82 30       	cpi	r24, 0x02	; 2
    2f82:	31 f4       	brne	.+12     	; 0x2f90 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f84:	89 81       	ldd	r24, Y+1	; 0x01
    2f86:	88 23       	and	r24, r24
    2f88:	19 f0       	breq	.+6      	; 0x2f90 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    2f8a:	89 81       	ldd	r24, Y+1	; 0x01
    2f8c:	81 50       	subi	r24, 0x01	; 1
    2f8e:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2f90:	89 81       	ldd	r24, Y+1	; 0x01
    2f92:	8f 5f       	subi	r24, 0xFF	; 255
    2f94:	eb 81       	ldd	r30, Y+3	; 0x03
    2f96:	fc 81       	ldd	r31, Y+4	; 0x04
    2f98:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    2f9a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2f9c:	27 96       	adiw	r28, 0x07	; 7
    2f9e:	0f b6       	in	r0, 0x3f	; 63
    2fa0:	f8 94       	cli
    2fa2:	de bf       	out	0x3e, r29	; 62
    2fa4:	0f be       	out	0x3f, r0	; 63
    2fa6:	cd bf       	out	0x3d, r28	; 61
    2fa8:	cf 91       	pop	r28
    2faa:	df 91       	pop	r29
    2fac:	08 95       	ret

00002fae <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    2fae:	df 93       	push	r29
    2fb0:	cf 93       	push	r28
    2fb2:	00 d0       	rcall	.+0      	; 0x2fb4 <prvCopyDataFromQueue+0x6>
    2fb4:	00 d0       	rcall	.+0      	; 0x2fb6 <prvCopyDataFromQueue+0x8>
    2fb6:	cd b7       	in	r28, 0x3d	; 61
    2fb8:	de b7       	in	r29, 0x3e	; 62
    2fba:	9a 83       	std	Y+2, r25	; 0x02
    2fbc:	89 83       	std	Y+1, r24	; 0x01
    2fbe:	7c 83       	std	Y+4, r23	; 0x04
    2fc0:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fc6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fc8:	88 23       	and	r24, r24
    2fca:	89 f1       	breq	.+98     	; 0x302e <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    2fce:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd0:	26 81       	ldd	r18, Z+6	; 0x06
    2fd2:	37 81       	ldd	r19, Z+7	; 0x07
    2fd4:	e9 81       	ldd	r30, Y+1	; 0x01
    2fd6:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fda:	88 2f       	mov	r24, r24
    2fdc:	90 e0       	ldi	r25, 0x00	; 0
    2fde:	82 0f       	add	r24, r18
    2fe0:	93 1f       	adc	r25, r19
    2fe2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fe6:	97 83       	std	Z+7, r25	; 0x07
    2fe8:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2fea:	e9 81       	ldd	r30, Y+1	; 0x01
    2fec:	fa 81       	ldd	r31, Y+2	; 0x02
    2fee:	26 81       	ldd	r18, Z+6	; 0x06
    2ff0:	37 81       	ldd	r19, Z+7	; 0x07
    2ff2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff6:	84 81       	ldd	r24, Z+4	; 0x04
    2ff8:	95 81       	ldd	r25, Z+5	; 0x05
    2ffa:	28 17       	cp	r18, r24
    2ffc:	39 07       	cpc	r19, r25
    2ffe:	40 f0       	brcs	.+16     	; 0x3010 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3000:	e9 81       	ldd	r30, Y+1	; 0x01
    3002:	fa 81       	ldd	r31, Y+2	; 0x02
    3004:	80 81       	ld	r24, Z
    3006:	91 81       	ldd	r25, Z+1	; 0x01
    3008:	e9 81       	ldd	r30, Y+1	; 0x01
    300a:	fa 81       	ldd	r31, Y+2	; 0x02
    300c:	97 83       	std	Z+7, r25	; 0x07
    300e:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3010:	e9 81       	ldd	r30, Y+1	; 0x01
    3012:	fa 81       	ldd	r31, Y+2	; 0x02
    3014:	46 81       	ldd	r20, Z+6	; 0x06
    3016:	57 81       	ldd	r21, Z+7	; 0x07
    3018:	e9 81       	ldd	r30, Y+1	; 0x01
    301a:	fa 81       	ldd	r31, Y+2	; 0x02
    301c:	84 8d       	ldd	r24, Z+28	; 0x1c
    301e:	28 2f       	mov	r18, r24
    3020:	30 e0       	ldi	r19, 0x00	; 0
    3022:	8b 81       	ldd	r24, Y+3	; 0x03
    3024:	9c 81       	ldd	r25, Y+4	; 0x04
    3026:	ba 01       	movw	r22, r20
    3028:	a9 01       	movw	r20, r18
    302a:	0e 94 3a 3e 	call	0x7c74	; 0x7c74 <memcpy>
    }
}
    302e:	0f 90       	pop	r0
    3030:	0f 90       	pop	r0
    3032:	0f 90       	pop	r0
    3034:	0f 90       	pop	r0
    3036:	cf 91       	pop	r28
    3038:	df 91       	pop	r29
    303a:	08 95       	ret

0000303c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    303c:	df 93       	push	r29
    303e:	cf 93       	push	r28
    3040:	00 d0       	rcall	.+0      	; 0x3042 <prvUnlockQueue+0x6>
    3042:	00 d0       	rcall	.+0      	; 0x3044 <prvUnlockQueue+0x8>
    3044:	cd b7       	in	r28, 0x3d	; 61
    3046:	de b7       	in	r29, 0x3e	; 62
    3048:	9c 83       	std	Y+4, r25	; 0x04
    304a:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    304c:	0f b6       	in	r0, 0x3f	; 63
    304e:	f8 94       	cli
    3050:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3052:	eb 81       	ldd	r30, Y+3	; 0x03
    3054:	fc 81       	ldd	r31, Y+4	; 0x04
    3056:	86 8d       	ldd	r24, Z+30	; 0x1e
    3058:	8a 83       	std	Y+2, r24	; 0x02
    305a:	11 c0       	rjmp	.+34     	; 0x307e <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    305c:	eb 81       	ldd	r30, Y+3	; 0x03
    305e:	fc 81       	ldd	r31, Y+4	; 0x04
    3060:	81 89       	ldd	r24, Z+17	; 0x11
    3062:	88 23       	and	r24, r24
    3064:	79 f0       	breq	.+30     	; 0x3084 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3066:	8b 81       	ldd	r24, Y+3	; 0x03
    3068:	9c 81       	ldd	r25, Y+4	; 0x04
    306a:	41 96       	adiw	r24, 0x11	; 17
    306c:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    3070:	88 23       	and	r24, r24
    3072:	11 f0       	breq	.+4      	; 0x3078 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    3074:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3078:	8a 81       	ldd	r24, Y+2	; 0x02
    307a:	81 50       	subi	r24, 0x01	; 1
    307c:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    307e:	8a 81       	ldd	r24, Y+2	; 0x02
    3080:	18 16       	cp	r1, r24
    3082:	64 f3       	brlt	.-40     	; 0x305c <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3084:	eb 81       	ldd	r30, Y+3	; 0x03
    3086:	fc 81       	ldd	r31, Y+4	; 0x04
    3088:	8f ef       	ldi	r24, 0xFF	; 255
    308a:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    308c:	0f 90       	pop	r0
    308e:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3090:	0f b6       	in	r0, 0x3f	; 63
    3092:	f8 94       	cli
    3094:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3096:	eb 81       	ldd	r30, Y+3	; 0x03
    3098:	fc 81       	ldd	r31, Y+4	; 0x04
    309a:	85 8d       	ldd	r24, Z+29	; 0x1d
    309c:	89 83       	std	Y+1, r24	; 0x01
    309e:	11 c0       	rjmp	.+34     	; 0x30c2 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    30a0:	eb 81       	ldd	r30, Y+3	; 0x03
    30a2:	fc 81       	ldd	r31, Y+4	; 0x04
    30a4:	80 85       	ldd	r24, Z+8	; 0x08
    30a6:	88 23       	and	r24, r24
    30a8:	79 f0       	breq	.+30     	; 0x30c8 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    30aa:	8b 81       	ldd	r24, Y+3	; 0x03
    30ac:	9c 81       	ldd	r25, Y+4	; 0x04
    30ae:	08 96       	adiw	r24, 0x08	; 8
    30b0:	0e 94 ee 22 	call	0x45dc	; 0x45dc <xTaskRemoveFromEventList>
    30b4:	88 23       	and	r24, r24
    30b6:	11 f0       	breq	.+4      	; 0x30bc <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    30b8:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    30bc:	89 81       	ldd	r24, Y+1	; 0x01
    30be:	81 50       	subi	r24, 0x01	; 1
    30c0:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    30c2:	89 81       	ldd	r24, Y+1	; 0x01
    30c4:	18 16       	cp	r1, r24
    30c6:	64 f3       	brlt	.-40     	; 0x30a0 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    30c8:	eb 81       	ldd	r30, Y+3	; 0x03
    30ca:	fc 81       	ldd	r31, Y+4	; 0x04
    30cc:	8f ef       	ldi	r24, 0xFF	; 255
    30ce:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    30d0:	0f 90       	pop	r0
    30d2:	0f be       	out	0x3f, r0	; 63
}
    30d4:	0f 90       	pop	r0
    30d6:	0f 90       	pop	r0
    30d8:	0f 90       	pop	r0
    30da:	0f 90       	pop	r0
    30dc:	cf 91       	pop	r28
    30de:	df 91       	pop	r29
    30e0:	08 95       	ret

000030e2 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    30e2:	df 93       	push	r29
    30e4:	cf 93       	push	r28
    30e6:	00 d0       	rcall	.+0      	; 0x30e8 <prvIsQueueEmpty+0x6>
    30e8:	0f 92       	push	r0
    30ea:	cd b7       	in	r28, 0x3d	; 61
    30ec:	de b7       	in	r29, 0x3e	; 62
    30ee:	9b 83       	std	Y+3, r25	; 0x03
    30f0:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    30f2:	0f b6       	in	r0, 0x3f	; 63
    30f4:	f8 94       	cli
    30f6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    30f8:	ea 81       	ldd	r30, Y+2	; 0x02
    30fa:	fb 81       	ldd	r31, Y+3	; 0x03
    30fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    30fe:	88 23       	and	r24, r24
    3100:	19 f4       	brne	.+6      	; 0x3108 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    3102:	81 e0       	ldi	r24, 0x01	; 1
    3104:	89 83       	std	Y+1, r24	; 0x01
    3106:	01 c0       	rjmp	.+2      	; 0x310a <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    3108:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    310a:	0f 90       	pop	r0
    310c:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    310e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3110:	0f 90       	pop	r0
    3112:	0f 90       	pop	r0
    3114:	0f 90       	pop	r0
    3116:	cf 91       	pop	r28
    3118:	df 91       	pop	r29
    311a:	08 95       	ret

0000311c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    311c:	df 93       	push	r29
    311e:	cf 93       	push	r28
    3120:	00 d0       	rcall	.+0      	; 0x3122 <xQueueIsQueueEmptyFromISR+0x6>
    3122:	00 d0       	rcall	.+0      	; 0x3124 <xQueueIsQueueEmptyFromISR+0x8>
    3124:	0f 92       	push	r0
    3126:	cd b7       	in	r28, 0x3d	; 61
    3128:	de b7       	in	r29, 0x3e	; 62
    312a:	9d 83       	std	Y+5, r25	; 0x05
    312c:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    312e:	8c 81       	ldd	r24, Y+4	; 0x04
    3130:	9d 81       	ldd	r25, Y+5	; 0x05
    3132:	9a 83       	std	Y+2, r25	; 0x02
    3134:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3136:	e9 81       	ldd	r30, Y+1	; 0x01
    3138:	fa 81       	ldd	r31, Y+2	; 0x02
    313a:	82 8d       	ldd	r24, Z+26	; 0x1a
    313c:	88 23       	and	r24, r24
    313e:	19 f4       	brne	.+6      	; 0x3146 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    3140:	81 e0       	ldi	r24, 0x01	; 1
    3142:	8b 83       	std	Y+3, r24	; 0x03
    3144:	01 c0       	rjmp	.+2      	; 0x3148 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    3146:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    3148:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    314a:	0f 90       	pop	r0
    314c:	0f 90       	pop	r0
    314e:	0f 90       	pop	r0
    3150:	0f 90       	pop	r0
    3152:	0f 90       	pop	r0
    3154:	cf 91       	pop	r28
    3156:	df 91       	pop	r29
    3158:	08 95       	ret

0000315a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    315a:	df 93       	push	r29
    315c:	cf 93       	push	r28
    315e:	00 d0       	rcall	.+0      	; 0x3160 <prvIsQueueFull+0x6>
    3160:	0f 92       	push	r0
    3162:	cd b7       	in	r28, 0x3d	; 61
    3164:	de b7       	in	r29, 0x3e	; 62
    3166:	9b 83       	std	Y+3, r25	; 0x03
    3168:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    316a:	0f b6       	in	r0, 0x3f	; 63
    316c:	f8 94       	cli
    316e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3170:	ea 81       	ldd	r30, Y+2	; 0x02
    3172:	fb 81       	ldd	r31, Y+3	; 0x03
    3174:	92 8d       	ldd	r25, Z+26	; 0x1a
    3176:	ea 81       	ldd	r30, Y+2	; 0x02
    3178:	fb 81       	ldd	r31, Y+3	; 0x03
    317a:	83 8d       	ldd	r24, Z+27	; 0x1b
    317c:	98 17       	cp	r25, r24
    317e:	19 f4       	brne	.+6      	; 0x3186 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    3180:	81 e0       	ldi	r24, 0x01	; 1
    3182:	89 83       	std	Y+1, r24	; 0x01
    3184:	01 c0       	rjmp	.+2      	; 0x3188 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    3186:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    3188:	0f 90       	pop	r0
    318a:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    318c:	89 81       	ldd	r24, Y+1	; 0x01
}
    318e:	0f 90       	pop	r0
    3190:	0f 90       	pop	r0
    3192:	0f 90       	pop	r0
    3194:	cf 91       	pop	r28
    3196:	df 91       	pop	r29
    3198:	08 95       	ret

0000319a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    319a:	df 93       	push	r29
    319c:	cf 93       	push	r28
    319e:	00 d0       	rcall	.+0      	; 0x31a0 <xQueueIsQueueFullFromISR+0x6>
    31a0:	00 d0       	rcall	.+0      	; 0x31a2 <xQueueIsQueueFullFromISR+0x8>
    31a2:	0f 92       	push	r0
    31a4:	cd b7       	in	r28, 0x3d	; 61
    31a6:	de b7       	in	r29, 0x3e	; 62
    31a8:	9d 83       	std	Y+5, r25	; 0x05
    31aa:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    31ac:	8c 81       	ldd	r24, Y+4	; 0x04
    31ae:	9d 81       	ldd	r25, Y+5	; 0x05
    31b0:	9a 83       	std	Y+2, r25	; 0x02
    31b2:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    31b4:	e9 81       	ldd	r30, Y+1	; 0x01
    31b6:	fa 81       	ldd	r31, Y+2	; 0x02
    31b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    31ba:	e9 81       	ldd	r30, Y+1	; 0x01
    31bc:	fa 81       	ldd	r31, Y+2	; 0x02
    31be:	83 8d       	ldd	r24, Z+27	; 0x1b
    31c0:	98 17       	cp	r25, r24
    31c2:	19 f4       	brne	.+6      	; 0x31ca <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    31c4:	81 e0       	ldi	r24, 0x01	; 1
    31c6:	8b 83       	std	Y+3, r24	; 0x03
    31c8:	01 c0       	rjmp	.+2      	; 0x31cc <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    31ca:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    31cc:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    31ce:	0f 90       	pop	r0
    31d0:	0f 90       	pop	r0
    31d2:	0f 90       	pop	r0
    31d4:	0f 90       	pop	r0
    31d6:	0f 90       	pop	r0
    31d8:	cf 91       	pop	r28
    31da:	df 91       	pop	r29
    31dc:	08 95       	ret

000031de <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    31de:	df 93       	push	r29
    31e0:	cf 93       	push	r28
    31e2:	cd b7       	in	r28, 0x3d	; 61
    31e4:	de b7       	in	r29, 0x3e	; 62
    31e6:	2a 97       	sbiw	r28, 0x0a	; 10
    31e8:	0f b6       	in	r0, 0x3f	; 63
    31ea:	f8 94       	cli
    31ec:	de bf       	out	0x3e, r29	; 62
    31ee:	0f be       	out	0x3f, r0	; 63
    31f0:	cd bf       	out	0x3d, r28	; 61
    31f2:	9d 83       	std	Y+5, r25	; 0x05
    31f4:	8c 83       	std	Y+4, r24	; 0x04
    31f6:	7f 83       	std	Y+7, r23	; 0x07
    31f8:	6e 83       	std	Y+6, r22	; 0x06
    31fa:	59 87       	std	Y+9, r21	; 0x09
    31fc:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    31fe:	8c 81       	ldd	r24, Y+4	; 0x04
    3200:	9d 81       	ldd	r25, Y+5	; 0x05
    3202:	9a 83       	std	Y+2, r25	; 0x02
    3204:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    3206:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3208:	89 81       	ldd	r24, Y+1	; 0x01
    320a:	9a 81       	ldd	r25, Y+2	; 0x02
    320c:	0e 94 ad 18 	call	0x315a	; 0x315a <prvIsQueueFull>
    3210:	88 23       	and	r24, r24
    3212:	a9 f0       	breq	.+42     	; 0x323e <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    3214:	88 85       	ldd	r24, Y+8	; 0x08
    3216:	99 85       	ldd	r25, Y+9	; 0x09
    3218:	00 97       	sbiw	r24, 0x00	; 0
    321a:	71 f0       	breq	.+28     	; 0x3238 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    321c:	89 81       	ldd	r24, Y+1	; 0x01
    321e:	9a 81       	ldd	r25, Y+2	; 0x02
    3220:	9c 01       	movw	r18, r24
    3222:	28 5f       	subi	r18, 0xF8	; 248
    3224:	3f 4f       	sbci	r19, 0xFF	; 255
    3226:	88 85       	ldd	r24, Y+8	; 0x08
    3228:	99 85       	ldd	r25, Y+9	; 0x09
    322a:	b9 01       	movw	r22, r18
    322c:	0e 94 bb 0a 	call	0x1576	; 0x1576 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    3230:	78 94       	sei
                    return errQUEUE_BLOCKED;
    3232:	8c ef       	ldi	r24, 0xFC	; 252
    3234:	8a 87       	std	Y+10, r24	; 0x0a
    3236:	2a c0       	rjmp	.+84     	; 0x328c <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    3238:	78 94       	sei
                    return errQUEUE_FULL;
    323a:	1a 86       	std	Y+10, r1	; 0x0a
    323c:	27 c0       	rjmp	.+78     	; 0x328c <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    323e:	78 94       	sei

        portDISABLE_INTERRUPTS();
    3240:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3242:	e9 81       	ldd	r30, Y+1	; 0x01
    3244:	fa 81       	ldd	r31, Y+2	; 0x02
    3246:	92 8d       	ldd	r25, Z+26	; 0x1a
    3248:	e9 81       	ldd	r30, Y+1	; 0x01
    324a:	fa 81       	ldd	r31, Y+2	; 0x02
    324c:	83 8d       	ldd	r24, Z+27	; 0x1b
    324e:	98 17       	cp	r25, r24
    3250:	c8 f4       	brcc	.+50     	; 0x3284 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    3252:	89 81       	ldd	r24, Y+1	; 0x01
    3254:	9a 81       	ldd	r25, Y+2	; 0x02
    3256:	2e 81       	ldd	r18, Y+6	; 0x06
    3258:	3f 81       	ldd	r19, Y+7	; 0x07
    325a:	b9 01       	movw	r22, r18
    325c:	40 e0       	ldi	r20, 0x00	; 0
    325e:	0e 94 31 17 	call	0x2e62	; 0x2e62 <prvCopyDataToQueue>
                xReturn = pdPASS;
    3262:	81 e0       	ldi	r24, 0x01	; 1
    3264:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3266:	e9 81       	ldd	r30, Y+1	; 0x01
    3268:	fa 81       	ldd	r31, Y+2	; 0x02
    326a:	81 89       	ldd	r24, Z+17	; 0x11
    326c:	88 23       	and	r24, r24
    326e:	59 f0       	breq	.+22     	; 0x3286 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3270:	89 81       	ldd	r24, Y+1	; 0x01
    3272:	9a 81       	ldd	r25, Y+2	; 0x02
    3274:	41 96       	adiw	r24, 0x11	; 17
    3276:	0e 94 ce 0c 	call	0x199c	; 0x199c <xCoRoutineRemoveFromEventList>
    327a:	88 23       	and	r24, r24
    327c:	21 f0       	breq	.+8      	; 0x3286 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    327e:	8b ef       	ldi	r24, 0xFB	; 251
    3280:	8b 83       	std	Y+3, r24	; 0x03
    3282:	01 c0       	rjmp	.+2      	; 0x3286 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    3284:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    3286:	78 94       	sei

        return xReturn;
    3288:	8b 81       	ldd	r24, Y+3	; 0x03
    328a:	8a 87       	std	Y+10, r24	; 0x0a
    328c:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    328e:	2a 96       	adiw	r28, 0x0a	; 10
    3290:	0f b6       	in	r0, 0x3f	; 63
    3292:	f8 94       	cli
    3294:	de bf       	out	0x3e, r29	; 62
    3296:	0f be       	out	0x3f, r0	; 63
    3298:	cd bf       	out	0x3d, r28	; 61
    329a:	cf 91       	pop	r28
    329c:	df 91       	pop	r29
    329e:	08 95       	ret

000032a0 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    32a0:	df 93       	push	r29
    32a2:	cf 93       	push	r28
    32a4:	cd b7       	in	r28, 0x3d	; 61
    32a6:	de b7       	in	r29, 0x3e	; 62
    32a8:	2a 97       	sbiw	r28, 0x0a	; 10
    32aa:	0f b6       	in	r0, 0x3f	; 63
    32ac:	f8 94       	cli
    32ae:	de bf       	out	0x3e, r29	; 62
    32b0:	0f be       	out	0x3f, r0	; 63
    32b2:	cd bf       	out	0x3d, r28	; 61
    32b4:	9d 83       	std	Y+5, r25	; 0x05
    32b6:	8c 83       	std	Y+4, r24	; 0x04
    32b8:	7f 83       	std	Y+7, r23	; 0x07
    32ba:	6e 83       	std	Y+6, r22	; 0x06
    32bc:	59 87       	std	Y+9, r21	; 0x09
    32be:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    32c0:	8c 81       	ldd	r24, Y+4	; 0x04
    32c2:	9d 81       	ldd	r25, Y+5	; 0x05
    32c4:	9a 83       	std	Y+2, r25	; 0x02
    32c6:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    32c8:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    32ca:	e9 81       	ldd	r30, Y+1	; 0x01
    32cc:	fa 81       	ldd	r31, Y+2	; 0x02
    32ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    32d0:	88 23       	and	r24, r24
    32d2:	a9 f4       	brne	.+42     	; 0x32fe <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    32d4:	88 85       	ldd	r24, Y+8	; 0x08
    32d6:	99 85       	ldd	r25, Y+9	; 0x09
    32d8:	00 97       	sbiw	r24, 0x00	; 0
    32da:	71 f0       	breq	.+28     	; 0x32f8 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    32dc:	89 81       	ldd	r24, Y+1	; 0x01
    32de:	9a 81       	ldd	r25, Y+2	; 0x02
    32e0:	9c 01       	movw	r18, r24
    32e2:	2f 5e       	subi	r18, 0xEF	; 239
    32e4:	3f 4f       	sbci	r19, 0xFF	; 255
    32e6:	88 85       	ldd	r24, Y+8	; 0x08
    32e8:	99 85       	ldd	r25, Y+9	; 0x09
    32ea:	b9 01       	movw	r22, r18
    32ec:	0e 94 bb 0a 	call	0x1576	; 0x1576 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    32f0:	78 94       	sei
                    return errQUEUE_BLOCKED;
    32f2:	8c ef       	ldi	r24, 0xFC	; 252
    32f4:	8a 87       	std	Y+10, r24	; 0x0a
    32f6:	58 c0       	rjmp	.+176    	; 0x33a8 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    32f8:	78 94       	sei
                    return errQUEUE_FULL;
    32fa:	1a 86       	std	Y+10, r1	; 0x0a
    32fc:	55 c0       	rjmp	.+170    	; 0x33a8 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    32fe:	78 94       	sei

        portDISABLE_INTERRUPTS();
    3300:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3302:	e9 81       	ldd	r30, Y+1	; 0x01
    3304:	fa 81       	ldd	r31, Y+2	; 0x02
    3306:	82 8d       	ldd	r24, Z+26	; 0x1a
    3308:	88 23       	and	r24, r24
    330a:	09 f4       	brne	.+2      	; 0x330e <xQueueCRReceive+0x6e>
    330c:	49 c0       	rjmp	.+146    	; 0x33a0 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    330e:	e9 81       	ldd	r30, Y+1	; 0x01
    3310:	fa 81       	ldd	r31, Y+2	; 0x02
    3312:	26 81       	ldd	r18, Z+6	; 0x06
    3314:	37 81       	ldd	r19, Z+7	; 0x07
    3316:	e9 81       	ldd	r30, Y+1	; 0x01
    3318:	fa 81       	ldd	r31, Y+2	; 0x02
    331a:	84 8d       	ldd	r24, Z+28	; 0x1c
    331c:	88 2f       	mov	r24, r24
    331e:	90 e0       	ldi	r25, 0x00	; 0
    3320:	82 0f       	add	r24, r18
    3322:	93 1f       	adc	r25, r19
    3324:	e9 81       	ldd	r30, Y+1	; 0x01
    3326:	fa 81       	ldd	r31, Y+2	; 0x02
    3328:	97 83       	std	Z+7, r25	; 0x07
    332a:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    332c:	e9 81       	ldd	r30, Y+1	; 0x01
    332e:	fa 81       	ldd	r31, Y+2	; 0x02
    3330:	26 81       	ldd	r18, Z+6	; 0x06
    3332:	37 81       	ldd	r19, Z+7	; 0x07
    3334:	e9 81       	ldd	r30, Y+1	; 0x01
    3336:	fa 81       	ldd	r31, Y+2	; 0x02
    3338:	84 81       	ldd	r24, Z+4	; 0x04
    333a:	95 81       	ldd	r25, Z+5	; 0x05
    333c:	28 17       	cp	r18, r24
    333e:	39 07       	cpc	r19, r25
    3340:	40 f0       	brcs	.+16     	; 0x3352 <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3342:	e9 81       	ldd	r30, Y+1	; 0x01
    3344:	fa 81       	ldd	r31, Y+2	; 0x02
    3346:	80 81       	ld	r24, Z
    3348:	91 81       	ldd	r25, Z+1	; 0x01
    334a:	e9 81       	ldd	r30, Y+1	; 0x01
    334c:	fa 81       	ldd	r31, Y+2	; 0x02
    334e:	97 83       	std	Z+7, r25	; 0x07
    3350:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    3352:	e9 81       	ldd	r30, Y+1	; 0x01
    3354:	fa 81       	ldd	r31, Y+2	; 0x02
    3356:	82 8d       	ldd	r24, Z+26	; 0x1a
    3358:	81 50       	subi	r24, 0x01	; 1
    335a:	e9 81       	ldd	r30, Y+1	; 0x01
    335c:	fa 81       	ldd	r31, Y+2	; 0x02
    335e:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3360:	e9 81       	ldd	r30, Y+1	; 0x01
    3362:	fa 81       	ldd	r31, Y+2	; 0x02
    3364:	46 81       	ldd	r20, Z+6	; 0x06
    3366:	57 81       	ldd	r21, Z+7	; 0x07
    3368:	e9 81       	ldd	r30, Y+1	; 0x01
    336a:	fa 81       	ldd	r31, Y+2	; 0x02
    336c:	84 8d       	ldd	r24, Z+28	; 0x1c
    336e:	28 2f       	mov	r18, r24
    3370:	30 e0       	ldi	r19, 0x00	; 0
    3372:	8e 81       	ldd	r24, Y+6	; 0x06
    3374:	9f 81       	ldd	r25, Y+7	; 0x07
    3376:	ba 01       	movw	r22, r20
    3378:	a9 01       	movw	r20, r18
    337a:	0e 94 3a 3e 	call	0x7c74	; 0x7c74 <memcpy>

                xReturn = pdPASS;
    337e:	81 e0       	ldi	r24, 0x01	; 1
    3380:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3382:	e9 81       	ldd	r30, Y+1	; 0x01
    3384:	fa 81       	ldd	r31, Y+2	; 0x02
    3386:	80 85       	ldd	r24, Z+8	; 0x08
    3388:	88 23       	and	r24, r24
    338a:	59 f0       	breq	.+22     	; 0x33a2 <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    338c:	89 81       	ldd	r24, Y+1	; 0x01
    338e:	9a 81       	ldd	r25, Y+2	; 0x02
    3390:	08 96       	adiw	r24, 0x08	; 8
    3392:	0e 94 ce 0c 	call	0x199c	; 0x199c <xCoRoutineRemoveFromEventList>
    3396:	88 23       	and	r24, r24
    3398:	21 f0       	breq	.+8      	; 0x33a2 <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    339a:	8b ef       	ldi	r24, 0xFB	; 251
    339c:	8b 83       	std	Y+3, r24	; 0x03
    339e:	01 c0       	rjmp	.+2      	; 0x33a2 <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    33a0:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    33a2:	78 94       	sei

        return xReturn;
    33a4:	8b 81       	ldd	r24, Y+3	; 0x03
    33a6:	8a 87       	std	Y+10, r24	; 0x0a
    33a8:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    33aa:	2a 96       	adiw	r28, 0x0a	; 10
    33ac:	0f b6       	in	r0, 0x3f	; 63
    33ae:	f8 94       	cli
    33b0:	de bf       	out	0x3e, r29	; 62
    33b2:	0f be       	out	0x3f, r0	; 63
    33b4:	cd bf       	out	0x3d, r28	; 61
    33b6:	cf 91       	pop	r28
    33b8:	df 91       	pop	r29
    33ba:	08 95       	ret

000033bc <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    33bc:	df 93       	push	r29
    33be:	cf 93       	push	r28
    33c0:	cd b7       	in	r28, 0x3d	; 61
    33c2:	de b7       	in	r29, 0x3e	; 62
    33c4:	28 97       	sbiw	r28, 0x08	; 8
    33c6:	0f b6       	in	r0, 0x3f	; 63
    33c8:	f8 94       	cli
    33ca:	de bf       	out	0x3e, r29	; 62
    33cc:	0f be       	out	0x3f, r0	; 63
    33ce:	cd bf       	out	0x3d, r28	; 61
    33d0:	9c 83       	std	Y+4, r25	; 0x04
    33d2:	8b 83       	std	Y+3, r24	; 0x03
    33d4:	7e 83       	std	Y+6, r23	; 0x06
    33d6:	6d 83       	std	Y+5, r22	; 0x05
    33d8:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    33da:	8b 81       	ldd	r24, Y+3	; 0x03
    33dc:	9c 81       	ldd	r25, Y+4	; 0x04
    33de:	9a 83       	std	Y+2, r25	; 0x02
    33e0:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    33e2:	e9 81       	ldd	r30, Y+1	; 0x01
    33e4:	fa 81       	ldd	r31, Y+2	; 0x02
    33e6:	92 8d       	ldd	r25, Z+26	; 0x1a
    33e8:	e9 81       	ldd	r30, Y+1	; 0x01
    33ea:	fa 81       	ldd	r31, Y+2	; 0x02
    33ec:	83 8d       	ldd	r24, Z+27	; 0x1b
    33ee:	98 17       	cp	r25, r24
    33f0:	d0 f4       	brcc	.+52     	; 0x3426 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    33f2:	89 81       	ldd	r24, Y+1	; 0x01
    33f4:	9a 81       	ldd	r25, Y+2	; 0x02
    33f6:	2d 81       	ldd	r18, Y+5	; 0x05
    33f8:	3e 81       	ldd	r19, Y+6	; 0x06
    33fa:	b9 01       	movw	r22, r18
    33fc:	40 e0       	ldi	r20, 0x00	; 0
    33fe:	0e 94 31 17 	call	0x2e62	; 0x2e62 <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    3402:	8f 81       	ldd	r24, Y+7	; 0x07
    3404:	88 23       	and	r24, r24
    3406:	79 f4       	brne	.+30     	; 0x3426 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3408:	e9 81       	ldd	r30, Y+1	; 0x01
    340a:	fa 81       	ldd	r31, Y+2	; 0x02
    340c:	81 89       	ldd	r24, Z+17	; 0x11
    340e:	88 23       	and	r24, r24
    3410:	51 f0       	breq	.+20     	; 0x3426 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3412:	89 81       	ldd	r24, Y+1	; 0x01
    3414:	9a 81       	ldd	r25, Y+2	; 0x02
    3416:	41 96       	adiw	r24, 0x11	; 17
    3418:	0e 94 ce 0c 	call	0x199c	; 0x199c <xCoRoutineRemoveFromEventList>
    341c:	88 23       	and	r24, r24
    341e:	19 f0       	breq	.+6      	; 0x3426 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    3420:	81 e0       	ldi	r24, 0x01	; 1
    3422:	88 87       	std	Y+8, r24	; 0x08
    3424:	02 c0       	rjmp	.+4      	; 0x342a <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    3426:	8f 81       	ldd	r24, Y+7	; 0x07
    3428:	88 87       	std	Y+8, r24	; 0x08
    342a:	88 85       	ldd	r24, Y+8	; 0x08
    }
    342c:	28 96       	adiw	r28, 0x08	; 8
    342e:	0f b6       	in	r0, 0x3f	; 63
    3430:	f8 94       	cli
    3432:	de bf       	out	0x3e, r29	; 62
    3434:	0f be       	out	0x3f, r0	; 63
    3436:	cd bf       	out	0x3d, r28	; 61
    3438:	cf 91       	pop	r28
    343a:	df 91       	pop	r29
    343c:	08 95       	ret

0000343e <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    343e:	df 93       	push	r29
    3440:	cf 93       	push	r28
    3442:	cd b7       	in	r28, 0x3d	; 61
    3444:	de b7       	in	r29, 0x3e	; 62
    3446:	29 97       	sbiw	r28, 0x09	; 9
    3448:	0f b6       	in	r0, 0x3f	; 63
    344a:	f8 94       	cli
    344c:	de bf       	out	0x3e, r29	; 62
    344e:	0f be       	out	0x3f, r0	; 63
    3450:	cd bf       	out	0x3d, r28	; 61
    3452:	9d 83       	std	Y+5, r25	; 0x05
    3454:	8c 83       	std	Y+4, r24	; 0x04
    3456:	7f 83       	std	Y+7, r23	; 0x07
    3458:	6e 83       	std	Y+6, r22	; 0x06
    345a:	59 87       	std	Y+9, r21	; 0x09
    345c:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    345e:	8c 81       	ldd	r24, Y+4	; 0x04
    3460:	9d 81       	ldd	r25, Y+5	; 0x05
    3462:	9a 83       	std	Y+2, r25	; 0x02
    3464:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3466:	e9 81       	ldd	r30, Y+1	; 0x01
    3468:	fa 81       	ldd	r31, Y+2	; 0x02
    346a:	82 8d       	ldd	r24, Z+26	; 0x1a
    346c:	88 23       	and	r24, r24
    346e:	09 f4       	brne	.+2      	; 0x3472 <xQueueCRReceiveFromISR+0x34>
    3470:	50 c0       	rjmp	.+160    	; 0x3512 <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    3472:	e9 81       	ldd	r30, Y+1	; 0x01
    3474:	fa 81       	ldd	r31, Y+2	; 0x02
    3476:	26 81       	ldd	r18, Z+6	; 0x06
    3478:	37 81       	ldd	r19, Z+7	; 0x07
    347a:	e9 81       	ldd	r30, Y+1	; 0x01
    347c:	fa 81       	ldd	r31, Y+2	; 0x02
    347e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3480:	88 2f       	mov	r24, r24
    3482:	90 e0       	ldi	r25, 0x00	; 0
    3484:	82 0f       	add	r24, r18
    3486:	93 1f       	adc	r25, r19
    3488:	e9 81       	ldd	r30, Y+1	; 0x01
    348a:	fa 81       	ldd	r31, Y+2	; 0x02
    348c:	97 83       	std	Z+7, r25	; 0x07
    348e:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    3490:	e9 81       	ldd	r30, Y+1	; 0x01
    3492:	fa 81       	ldd	r31, Y+2	; 0x02
    3494:	26 81       	ldd	r18, Z+6	; 0x06
    3496:	37 81       	ldd	r19, Z+7	; 0x07
    3498:	e9 81       	ldd	r30, Y+1	; 0x01
    349a:	fa 81       	ldd	r31, Y+2	; 0x02
    349c:	84 81       	ldd	r24, Z+4	; 0x04
    349e:	95 81       	ldd	r25, Z+5	; 0x05
    34a0:	28 17       	cp	r18, r24
    34a2:	39 07       	cpc	r19, r25
    34a4:	40 f0       	brcs	.+16     	; 0x34b6 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    34a6:	e9 81       	ldd	r30, Y+1	; 0x01
    34a8:	fa 81       	ldd	r31, Y+2	; 0x02
    34aa:	80 81       	ld	r24, Z
    34ac:	91 81       	ldd	r25, Z+1	; 0x01
    34ae:	e9 81       	ldd	r30, Y+1	; 0x01
    34b0:	fa 81       	ldd	r31, Y+2	; 0x02
    34b2:	97 83       	std	Z+7, r25	; 0x07
    34b4:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    34b6:	e9 81       	ldd	r30, Y+1	; 0x01
    34b8:	fa 81       	ldd	r31, Y+2	; 0x02
    34ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    34bc:	81 50       	subi	r24, 0x01	; 1
    34be:	e9 81       	ldd	r30, Y+1	; 0x01
    34c0:	fa 81       	ldd	r31, Y+2	; 0x02
    34c2:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    34c4:	e9 81       	ldd	r30, Y+1	; 0x01
    34c6:	fa 81       	ldd	r31, Y+2	; 0x02
    34c8:	46 81       	ldd	r20, Z+6	; 0x06
    34ca:	57 81       	ldd	r21, Z+7	; 0x07
    34cc:	e9 81       	ldd	r30, Y+1	; 0x01
    34ce:	fa 81       	ldd	r31, Y+2	; 0x02
    34d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    34d2:	28 2f       	mov	r18, r24
    34d4:	30 e0       	ldi	r19, 0x00	; 0
    34d6:	8e 81       	ldd	r24, Y+6	; 0x06
    34d8:	9f 81       	ldd	r25, Y+7	; 0x07
    34da:	ba 01       	movw	r22, r20
    34dc:	a9 01       	movw	r20, r18
    34de:	0e 94 3a 3e 	call	0x7c74	; 0x7c74 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    34e2:	e8 85       	ldd	r30, Y+8	; 0x08
    34e4:	f9 85       	ldd	r31, Y+9	; 0x09
    34e6:	80 81       	ld	r24, Z
    34e8:	88 23       	and	r24, r24
    34ea:	81 f4       	brne	.+32     	; 0x350c <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    34ec:	e9 81       	ldd	r30, Y+1	; 0x01
    34ee:	fa 81       	ldd	r31, Y+2	; 0x02
    34f0:	80 85       	ldd	r24, Z+8	; 0x08
    34f2:	88 23       	and	r24, r24
    34f4:	59 f0       	breq	.+22     	; 0x350c <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    34f6:	89 81       	ldd	r24, Y+1	; 0x01
    34f8:	9a 81       	ldd	r25, Y+2	; 0x02
    34fa:	08 96       	adiw	r24, 0x08	; 8
    34fc:	0e 94 ce 0c 	call	0x199c	; 0x199c <xCoRoutineRemoveFromEventList>
    3500:	88 23       	and	r24, r24
    3502:	21 f0       	breq	.+8      	; 0x350c <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    3504:	e8 85       	ldd	r30, Y+8	; 0x08
    3506:	f9 85       	ldd	r31, Y+9	; 0x09
    3508:	81 e0       	ldi	r24, 0x01	; 1
    350a:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    350c:	81 e0       	ldi	r24, 0x01	; 1
    350e:	8b 83       	std	Y+3, r24	; 0x03
    3510:	01 c0       	rjmp	.+2      	; 0x3514 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    3512:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    3514:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3516:	29 96       	adiw	r28, 0x09	; 9
    3518:	0f b6       	in	r0, 0x3f	; 63
    351a:	f8 94       	cli
    351c:	de bf       	out	0x3e, r29	; 62
    351e:	0f be       	out	0x3f, r0	; 63
    3520:	cd bf       	out	0x3d, r28	; 61
    3522:	cf 91       	pop	r28
    3524:	df 91       	pop	r29
    3526:	08 95       	ret

00003528 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    3528:	df 93       	push	r29
    352a:	cf 93       	push	r28
    352c:	cd b7       	in	r28, 0x3d	; 61
    352e:	de b7       	in	r29, 0x3e	; 62
    3530:	27 97       	sbiw	r28, 0x07	; 7
    3532:	0f b6       	in	r0, 0x3f	; 63
    3534:	f8 94       	cli
    3536:	de bf       	out	0x3e, r29	; 62
    3538:	0f be       	out	0x3f, r0	; 63
    353a:	cd bf       	out	0x3d, r28	; 61
    353c:	9c 83       	std	Y+4, r25	; 0x04
    353e:	8b 83       	std	Y+3, r24	; 0x03
    3540:	7e 83       	std	Y+6, r23	; 0x06
    3542:	6d 83       	std	Y+5, r22	; 0x05
    3544:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    3546:	8b 81       	ldd	r24, Y+3	; 0x03
    3548:	9c 81       	ldd	r25, Y+4	; 0x04
    354a:	9a 83       	std	Y+2, r25	; 0x02
    354c:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    354e:	0f b6       	in	r0, 0x3f	; 63
    3550:	f8 94       	cli
    3552:	0f 92       	push	r0
    3554:	e9 81       	ldd	r30, Y+1	; 0x01
    3556:	fa 81       	ldd	r31, Y+2	; 0x02
    3558:	85 8d       	ldd	r24, Z+29	; 0x1d
    355a:	8f 3f       	cpi	r24, 0xFF	; 255
    355c:	19 f4       	brne	.+6      	; 0x3564 <vQueueWaitForMessageRestricted+0x3c>
    355e:	e9 81       	ldd	r30, Y+1	; 0x01
    3560:	fa 81       	ldd	r31, Y+2	; 0x02
    3562:	15 8e       	std	Z+29, r1	; 0x1d
    3564:	e9 81       	ldd	r30, Y+1	; 0x01
    3566:	fa 81       	ldd	r31, Y+2	; 0x02
    3568:	86 8d       	ldd	r24, Z+30	; 0x1e
    356a:	8f 3f       	cpi	r24, 0xFF	; 255
    356c:	19 f4       	brne	.+6      	; 0x3574 <vQueueWaitForMessageRestricted+0x4c>
    356e:	e9 81       	ldd	r30, Y+1	; 0x01
    3570:	fa 81       	ldd	r31, Y+2	; 0x02
    3572:	16 8e       	std	Z+30, r1	; 0x1e
    3574:	0f 90       	pop	r0
    3576:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3578:	e9 81       	ldd	r30, Y+1	; 0x01
    357a:	fa 81       	ldd	r31, Y+2	; 0x02
    357c:	82 8d       	ldd	r24, Z+26	; 0x1a
    357e:	88 23       	and	r24, r24
    3580:	49 f4       	brne	.+18     	; 0x3594 <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3582:	89 81       	ldd	r24, Y+1	; 0x01
    3584:	9a 81       	ldd	r25, Y+2	; 0x02
    3586:	41 96       	adiw	r24, 0x11	; 17
    3588:	2d 81       	ldd	r18, Y+5	; 0x05
    358a:	3e 81       	ldd	r19, Y+6	; 0x06
    358c:	b9 01       	movw	r22, r18
    358e:	4f 81       	ldd	r20, Y+7	; 0x07
    3590:	0e 94 8c 22 	call	0x4518	; 0x4518 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    3594:	89 81       	ldd	r24, Y+1	; 0x01
    3596:	9a 81       	ldd	r25, Y+2	; 0x02
    3598:	0e 94 1e 18 	call	0x303c	; 0x303c <prvUnlockQueue>
    }
    359c:	27 96       	adiw	r28, 0x07	; 7
    359e:	0f b6       	in	r0, 0x3f	; 63
    35a0:	f8 94       	cli
    35a2:	de bf       	out	0x3e, r29	; 62
    35a4:	0f be       	out	0x3f, r0	; 63
    35a6:	cd bf       	out	0x3d, r28	; 61
    35a8:	cf 91       	pop	r28
    35aa:	df 91       	pop	r29
    35ac:	08 95       	ret

000035ae <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    35ae:	8f 92       	push	r8
    35b0:	9f 92       	push	r9
    35b2:	af 92       	push	r10
    35b4:	bf 92       	push	r11
    35b6:	cf 92       	push	r12
    35b8:	df 92       	push	r13
    35ba:	ef 92       	push	r14
    35bc:	ff 92       	push	r15
    35be:	0f 93       	push	r16
    35c0:	1f 93       	push	r17
    35c2:	df 93       	push	r29
    35c4:	cf 93       	push	r28
    35c6:	cd b7       	in	r28, 0x3d	; 61
    35c8:	de b7       	in	r29, 0x3e	; 62
    35ca:	60 97       	sbiw	r28, 0x10	; 16
    35cc:	0f b6       	in	r0, 0x3f	; 63
    35ce:	f8 94       	cli
    35d0:	de bf       	out	0x3e, r29	; 62
    35d2:	0f be       	out	0x3f, r0	; 63
    35d4:	cd bf       	out	0x3d, r28	; 61
    35d6:	9f 83       	std	Y+7, r25	; 0x07
    35d8:	8e 83       	std	Y+6, r24	; 0x06
    35da:	79 87       	std	Y+9, r23	; 0x09
    35dc:	68 87       	std	Y+8, r22	; 0x08
    35de:	5b 87       	std	Y+11, r21	; 0x0b
    35e0:	4a 87       	std	Y+10, r20	; 0x0a
    35e2:	3d 87       	std	Y+13, r19	; 0x0d
    35e4:	2c 87       	std	Y+12, r18	; 0x0c
    35e6:	0e 87       	std	Y+14, r16	; 0x0e
    35e8:	f8 8a       	std	Y+16, r15	; 0x10
    35ea:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    35ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    35ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    35f0:	0e 94 d3 06 	call	0xda6	; 0xda6 <pvPortMalloc>
    35f4:	9a 83       	std	Y+2, r25	; 0x02
    35f6:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    35f8:	89 81       	ldd	r24, Y+1	; 0x01
    35fa:	9a 81       	ldd	r25, Y+2	; 0x02
    35fc:	00 97       	sbiw	r24, 0x00	; 0
    35fe:	b1 f0       	breq	.+44     	; 0x362c <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3600:	86 e2       	ldi	r24, 0x26	; 38
    3602:	90 e0       	ldi	r25, 0x00	; 0
    3604:	0e 94 d3 06 	call	0xda6	; 0xda6 <pvPortMalloc>
    3608:	9d 83       	std	Y+5, r25	; 0x05
    360a:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    360c:	8c 81       	ldd	r24, Y+4	; 0x04
    360e:	9d 81       	ldd	r25, Y+5	; 0x05
    3610:	00 97       	sbiw	r24, 0x00	; 0
    3612:	39 f0       	breq	.+14     	; 0x3622 <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    3614:	ec 81       	ldd	r30, Y+4	; 0x04
    3616:	fd 81       	ldd	r31, Y+5	; 0x05
    3618:	89 81       	ldd	r24, Y+1	; 0x01
    361a:	9a 81       	ldd	r25, Y+2	; 0x02
    361c:	90 8f       	std	Z+24, r25	; 0x18
    361e:	87 8b       	std	Z+23, r24	; 0x17
    3620:	07 c0       	rjmp	.+14     	; 0x3630 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    3622:	89 81       	ldd	r24, Y+1	; 0x01
    3624:	9a 81       	ldd	r25, Y+2	; 0x02
    3626:	0e 94 2d 07 	call	0xe5a	; 0xe5a <vPortFree>
    362a:	02 c0       	rjmp	.+4      	; 0x3630 <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    362c:	1d 82       	std	Y+5, r1	; 0x05
    362e:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    3630:	8c 81       	ldd	r24, Y+4	; 0x04
    3632:	9d 81       	ldd	r25, Y+5	; 0x05
    3634:	00 97       	sbiw	r24, 0x00	; 0
    3636:	e9 f0       	breq	.+58     	; 0x3672 <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3638:	8a 85       	ldd	r24, Y+10	; 0x0a
    363a:	9b 85       	ldd	r25, Y+11	; 0x0b
    363c:	9c 01       	movw	r18, r24
    363e:	40 e0       	ldi	r20, 0x00	; 0
    3640:	50 e0       	ldi	r21, 0x00	; 0
    3642:	8e 81       	ldd	r24, Y+6	; 0x06
    3644:	9f 81       	ldd	r25, Y+7	; 0x07
    3646:	68 85       	ldd	r22, Y+8	; 0x08
    3648:	79 85       	ldd	r23, Y+9	; 0x09
    364a:	ec 85       	ldd	r30, Y+12	; 0x0c
    364c:	fd 85       	ldd	r31, Y+13	; 0x0d
    364e:	af 85       	ldd	r26, Y+15	; 0x0f
    3650:	b8 89       	ldd	r27, Y+16	; 0x10
    3652:	ac 80       	ldd	r10, Y+4	; 0x04
    3654:	bd 80       	ldd	r11, Y+5	; 0x05
    3656:	8f 01       	movw	r16, r30
    3658:	ee 84       	ldd	r14, Y+14	; 0x0e
    365a:	6d 01       	movw	r12, r26
    365c:	88 24       	eor	r8, r8
    365e:	99 24       	eor	r9, r9
    3660:	0e 94 4f 1b 	call	0x369e	; 0x369e <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    3664:	8c 81       	ldd	r24, Y+4	; 0x04
    3666:	9d 81       	ldd	r25, Y+5	; 0x05
    3668:	0e 94 14 1c 	call	0x3828	; 0x3828 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    366c:	81 e0       	ldi	r24, 0x01	; 1
    366e:	8b 83       	std	Y+3, r24	; 0x03
    3670:	02 c0       	rjmp	.+4      	; 0x3676 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3672:	8f ef       	ldi	r24, 0xFF	; 255
    3674:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    3676:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3678:	60 96       	adiw	r28, 0x10	; 16
    367a:	0f b6       	in	r0, 0x3f	; 63
    367c:	f8 94       	cli
    367e:	de bf       	out	0x3e, r29	; 62
    3680:	0f be       	out	0x3f, r0	; 63
    3682:	cd bf       	out	0x3d, r28	; 61
    3684:	cf 91       	pop	r28
    3686:	df 91       	pop	r29
    3688:	1f 91       	pop	r17
    368a:	0f 91       	pop	r16
    368c:	ff 90       	pop	r15
    368e:	ef 90       	pop	r14
    3690:	df 90       	pop	r13
    3692:	cf 90       	pop	r12
    3694:	bf 90       	pop	r11
    3696:	af 90       	pop	r10
    3698:	9f 90       	pop	r9
    369a:	8f 90       	pop	r8
    369c:	08 95       	ret

0000369e <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    369e:	8f 92       	push	r8
    36a0:	9f 92       	push	r9
    36a2:	af 92       	push	r10
    36a4:	bf 92       	push	r11
    36a6:	cf 92       	push	r12
    36a8:	df 92       	push	r13
    36aa:	ef 92       	push	r14
    36ac:	0f 93       	push	r16
    36ae:	1f 93       	push	r17
    36b0:	df 93       	push	r29
    36b2:	cf 93       	push	r28
    36b4:	cd b7       	in	r28, 0x3d	; 61
    36b6:	de b7       	in	r29, 0x3e	; 62
    36b8:	64 97       	sbiw	r28, 0x14	; 20
    36ba:	0f b6       	in	r0, 0x3f	; 63
    36bc:	f8 94       	cli
    36be:	de bf       	out	0x3e, r29	; 62
    36c0:	0f be       	out	0x3f, r0	; 63
    36c2:	cd bf       	out	0x3d, r28	; 61
    36c4:	9d 83       	std	Y+5, r25	; 0x05
    36c6:	8c 83       	std	Y+4, r24	; 0x04
    36c8:	7f 83       	std	Y+7, r23	; 0x07
    36ca:	6e 83       	std	Y+6, r22	; 0x06
    36cc:	28 87       	std	Y+8, r18	; 0x08
    36ce:	39 87       	std	Y+9, r19	; 0x09
    36d0:	4a 87       	std	Y+10, r20	; 0x0a
    36d2:	5b 87       	std	Y+11, r21	; 0x0b
    36d4:	1d 87       	std	Y+13, r17	; 0x0d
    36d6:	0c 87       	std	Y+12, r16	; 0x0c
    36d8:	ee 86       	std	Y+14, r14	; 0x0e
    36da:	d8 8a       	std	Y+16, r13	; 0x10
    36dc:	cf 86       	std	Y+15, r12	; 0x0f
    36de:	ba 8a       	std	Y+18, r11	; 0x12
    36e0:	a9 8a       	std	Y+17, r10	; 0x11
    36e2:	9c 8a       	std	Y+20, r9	; 0x14
    36e4:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    36e6:	e9 89       	ldd	r30, Y+17	; 0x11
    36e8:	fa 89       	ldd	r31, Y+18	; 0x12
    36ea:	27 89       	ldd	r18, Z+23	; 0x17
    36ec:	30 8d       	ldd	r19, Z+24	; 0x18
    36ee:	88 85       	ldd	r24, Y+8	; 0x08
    36f0:	99 85       	ldd	r25, Y+9	; 0x09
    36f2:	01 97       	sbiw	r24, 0x01	; 1
    36f4:	82 0f       	add	r24, r18
    36f6:	93 1f       	adc	r25, r19
    36f8:	9b 83       	std	Y+3, r25	; 0x03
    36fa:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    36fc:	8e 81       	ldd	r24, Y+6	; 0x06
    36fe:	9f 81       	ldd	r25, Y+7	; 0x07
    3700:	00 97       	sbiw	r24, 0x00	; 0
    3702:	51 f1       	breq	.+84     	; 0x3758 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3704:	19 82       	std	Y+1, r1	; 0x01
    3706:	21 c0       	rjmp	.+66     	; 0x374a <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3708:	89 81       	ldd	r24, Y+1	; 0x01
    370a:	48 2f       	mov	r20, r24
    370c:	50 e0       	ldi	r21, 0x00	; 0
    370e:	89 81       	ldd	r24, Y+1	; 0x01
    3710:	28 2f       	mov	r18, r24
    3712:	30 e0       	ldi	r19, 0x00	; 0
    3714:	8e 81       	ldd	r24, Y+6	; 0x06
    3716:	9f 81       	ldd	r25, Y+7	; 0x07
    3718:	fc 01       	movw	r30, r24
    371a:	e2 0f       	add	r30, r18
    371c:	f3 1f       	adc	r31, r19
    371e:	20 81       	ld	r18, Z
    3720:	89 89       	ldd	r24, Y+17	; 0x11
    3722:	9a 89       	ldd	r25, Y+18	; 0x12
    3724:	84 0f       	add	r24, r20
    3726:	95 1f       	adc	r25, r21
    3728:	fc 01       	movw	r30, r24
    372a:	79 96       	adiw	r30, 0x19	; 25
    372c:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    372e:	89 81       	ldd	r24, Y+1	; 0x01
    3730:	28 2f       	mov	r18, r24
    3732:	30 e0       	ldi	r19, 0x00	; 0
    3734:	8e 81       	ldd	r24, Y+6	; 0x06
    3736:	9f 81       	ldd	r25, Y+7	; 0x07
    3738:	fc 01       	movw	r30, r24
    373a:	e2 0f       	add	r30, r18
    373c:	f3 1f       	adc	r31, r19
    373e:	80 81       	ld	r24, Z
    3740:	88 23       	and	r24, r24
    3742:	31 f0       	breq	.+12     	; 0x3750 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3744:	89 81       	ldd	r24, Y+1	; 0x01
    3746:	8f 5f       	subi	r24, 0xFF	; 255
    3748:	89 83       	std	Y+1, r24	; 0x01
    374a:	89 81       	ldd	r24, Y+1	; 0x01
    374c:	88 30       	cpi	r24, 0x08	; 8
    374e:	e0 f2       	brcs	.-72     	; 0x3708 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3750:	e9 89       	ldd	r30, Y+17	; 0x11
    3752:	fa 89       	ldd	r31, Y+18	; 0x12
    3754:	10 a2       	std	Z+32, r1	; 0x20
    3756:	03 c0       	rjmp	.+6      	; 0x375e <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3758:	e9 89       	ldd	r30, Y+17	; 0x11
    375a:	fa 89       	ldd	r31, Y+18	; 0x12
    375c:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    375e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3760:	84 30       	cpi	r24, 0x04	; 4
    3762:	10 f0       	brcs	.+4      	; 0x3768 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3764:	83 e0       	ldi	r24, 0x03	; 3
    3766:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    3768:	e9 89       	ldd	r30, Y+17	; 0x11
    376a:	fa 89       	ldd	r31, Y+18	; 0x12
    376c:	8e 85       	ldd	r24, Y+14	; 0x0e
    376e:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3770:	89 89       	ldd	r24, Y+17	; 0x11
    3772:	9a 89       	ldd	r25, Y+18	; 0x12
    3774:	02 96       	adiw	r24, 0x02	; 2
    3776:	0e 94 75 10 	call	0x20ea	; 0x20ea <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    377a:	89 89       	ldd	r24, Y+17	; 0x11
    377c:	9a 89       	ldd	r25, Y+18	; 0x12
    377e:	0c 96       	adiw	r24, 0x0c	; 12
    3780:	0e 94 75 10 	call	0x20ea	; 0x20ea <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3784:	e9 89       	ldd	r30, Y+17	; 0x11
    3786:	fa 89       	ldd	r31, Y+18	; 0x12
    3788:	89 89       	ldd	r24, Y+17	; 0x11
    378a:	9a 89       	ldd	r25, Y+18	; 0x12
    378c:	91 87       	std	Z+9, r25	; 0x09
    378e:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3790:	8e 85       	ldd	r24, Y+14	; 0x0e
    3792:	28 2f       	mov	r18, r24
    3794:	30 e0       	ldi	r19, 0x00	; 0
    3796:	84 e0       	ldi	r24, 0x04	; 4
    3798:	90 e0       	ldi	r25, 0x00	; 0
    379a:	82 1b       	sub	r24, r18
    379c:	93 0b       	sbc	r25, r19
    379e:	e9 89       	ldd	r30, Y+17	; 0x11
    37a0:	fa 89       	ldd	r31, Y+18	; 0x12
    37a2:	95 87       	std	Z+13, r25	; 0x0d
    37a4:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    37a6:	e9 89       	ldd	r30, Y+17	; 0x11
    37a8:	fa 89       	ldd	r31, Y+18	; 0x12
    37aa:	89 89       	ldd	r24, Y+17	; 0x11
    37ac:	9a 89       	ldd	r25, Y+18	; 0x12
    37ae:	93 8b       	std	Z+19, r25	; 0x13
    37b0:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    37b2:	89 89       	ldd	r24, Y+17	; 0x11
    37b4:	9a 89       	ldd	r25, Y+18	; 0x12
    37b6:	81 96       	adiw	r24, 0x21	; 33
    37b8:	60 e0       	ldi	r22, 0x00	; 0
    37ba:	70 e0       	ldi	r23, 0x00	; 0
    37bc:	44 e0       	ldi	r20, 0x04	; 4
    37be:	50 e0       	ldi	r21, 0x00	; 0
    37c0:	0e 94 43 3e 	call	0x7c86	; 0x7c86 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    37c4:	89 89       	ldd	r24, Y+17	; 0x11
    37c6:	9a 89       	ldd	r25, Y+18	; 0x12
    37c8:	85 96       	adiw	r24, 0x25	; 37
    37ca:	60 e0       	ldi	r22, 0x00	; 0
    37cc:	70 e0       	ldi	r23, 0x00	; 0
    37ce:	41 e0       	ldi	r20, 0x01	; 1
    37d0:	50 e0       	ldi	r21, 0x00	; 0
    37d2:	0e 94 43 3e 	call	0x7c86	; 0x7c86 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    37d6:	8a 81       	ldd	r24, Y+2	; 0x02
    37d8:	9b 81       	ldd	r25, Y+3	; 0x03
    37da:	2c 81       	ldd	r18, Y+4	; 0x04
    37dc:	3d 81       	ldd	r19, Y+5	; 0x05
    37de:	4c 85       	ldd	r20, Y+12	; 0x0c
    37e0:	5d 85       	ldd	r21, Y+13	; 0x0d
    37e2:	b9 01       	movw	r22, r18
    37e4:	0e 94 53 07 	call	0xea6	; 0xea6 <pxPortInitialiseStack>
    37e8:	e9 89       	ldd	r30, Y+17	; 0x11
    37ea:	fa 89       	ldd	r31, Y+18	; 0x12
    37ec:	91 83       	std	Z+1, r25	; 0x01
    37ee:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    37f0:	8f 85       	ldd	r24, Y+15	; 0x0f
    37f2:	98 89       	ldd	r25, Y+16	; 0x10
    37f4:	00 97       	sbiw	r24, 0x00	; 0
    37f6:	31 f0       	breq	.+12     	; 0x3804 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    37f8:	ef 85       	ldd	r30, Y+15	; 0x0f
    37fa:	f8 89       	ldd	r31, Y+16	; 0x10
    37fc:	89 89       	ldd	r24, Y+17	; 0x11
    37fe:	9a 89       	ldd	r25, Y+18	; 0x12
    3800:	91 83       	std	Z+1, r25	; 0x01
    3802:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3804:	64 96       	adiw	r28, 0x14	; 20
    3806:	0f b6       	in	r0, 0x3f	; 63
    3808:	f8 94       	cli
    380a:	de bf       	out	0x3e, r29	; 62
    380c:	0f be       	out	0x3f, r0	; 63
    380e:	cd bf       	out	0x3d, r28	; 61
    3810:	cf 91       	pop	r28
    3812:	df 91       	pop	r29
    3814:	1f 91       	pop	r17
    3816:	0f 91       	pop	r16
    3818:	ef 90       	pop	r14
    381a:	df 90       	pop	r13
    381c:	cf 90       	pop	r12
    381e:	bf 90       	pop	r11
    3820:	af 90       	pop	r10
    3822:	9f 90       	pop	r9
    3824:	8f 90       	pop	r8
    3826:	08 95       	ret

00003828 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    3828:	df 93       	push	r29
    382a:	cf 93       	push	r28
    382c:	00 d0       	rcall	.+0      	; 0x382e <prvAddNewTaskToReadyList+0x6>
    382e:	00 d0       	rcall	.+0      	; 0x3830 <prvAddNewTaskToReadyList+0x8>
    3830:	cd b7       	in	r28, 0x3d	; 61
    3832:	de b7       	in	r29, 0x3e	; 62
    3834:	9c 83       	std	Y+4, r25	; 0x04
    3836:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    3838:	0f b6       	in	r0, 0x3f	; 63
    383a:	f8 94       	cli
    383c:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    383e:	80 91 63 08 	lds	r24, 0x0863
    3842:	8f 5f       	subi	r24, 0xFF	; 255
    3844:	80 93 63 08 	sts	0x0863, r24

        if( pxCurrentTCB == NULL )
    3848:	80 91 60 08 	lds	r24, 0x0860
    384c:	90 91 61 08 	lds	r25, 0x0861
    3850:	00 97       	sbiw	r24, 0x00	; 0
    3852:	69 f4       	brne	.+26     	; 0x386e <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3854:	8b 81       	ldd	r24, Y+3	; 0x03
    3856:	9c 81       	ldd	r25, Y+4	; 0x04
    3858:	90 93 61 08 	sts	0x0861, r25
    385c:	80 93 60 08 	sts	0x0860, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3860:	80 91 63 08 	lds	r24, 0x0863
    3864:	81 30       	cpi	r24, 0x01	; 1
    3866:	b9 f4       	brne	.+46     	; 0x3896 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    3868:	0e 94 f8 25 	call	0x4bf0	; 0x4bf0 <prvInitialiseTaskLists>
    386c:	14 c0       	rjmp	.+40     	; 0x3896 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    386e:	80 91 67 08 	lds	r24, 0x0867
    3872:	88 23       	and	r24, r24
    3874:	81 f4       	brne	.+32     	; 0x3896 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3876:	e0 91 60 08 	lds	r30, 0x0860
    387a:	f0 91 61 08 	lds	r31, 0x0861
    387e:	96 89       	ldd	r25, Z+22	; 0x16
    3880:	eb 81       	ldd	r30, Y+3	; 0x03
    3882:	fc 81       	ldd	r31, Y+4	; 0x04
    3884:	86 89       	ldd	r24, Z+22	; 0x16
    3886:	89 17       	cp	r24, r25
    3888:	30 f0       	brcs	.+12     	; 0x3896 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    388a:	8b 81       	ldd	r24, Y+3	; 0x03
    388c:	9c 81       	ldd	r25, Y+4	; 0x04
    388e:	90 93 61 08 	sts	0x0861, r25
    3892:	80 93 60 08 	sts	0x0860, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    3896:	80 91 6c 08 	lds	r24, 0x086C
    389a:	8f 5f       	subi	r24, 0xFF	; 255
    389c:	80 93 6c 08 	sts	0x086C, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    38a0:	eb 81       	ldd	r30, Y+3	; 0x03
    38a2:	fc 81       	ldd	r31, Y+4	; 0x04
    38a4:	96 89       	ldd	r25, Z+22	; 0x16
    38a6:	80 91 66 08 	lds	r24, 0x0866
    38aa:	89 17       	cp	r24, r25
    38ac:	28 f4       	brcc	.+10     	; 0x38b8 <prvAddNewTaskToReadyList+0x90>
    38ae:	eb 81       	ldd	r30, Y+3	; 0x03
    38b0:	fc 81       	ldd	r31, Y+4	; 0x04
    38b2:	86 89       	ldd	r24, Z+22	; 0x16
    38b4:	80 93 66 08 	sts	0x0866, r24
    38b8:	eb 81       	ldd	r30, Y+3	; 0x03
    38ba:	fc 81       	ldd	r31, Y+4	; 0x04
    38bc:	86 89       	ldd	r24, Z+22	; 0x16
    38be:	28 2f       	mov	r18, r24
    38c0:	30 e0       	ldi	r19, 0x00	; 0
    38c2:	c9 01       	movw	r24, r18
    38c4:	88 0f       	add	r24, r24
    38c6:	99 1f       	adc	r25, r25
    38c8:	88 0f       	add	r24, r24
    38ca:	99 1f       	adc	r25, r25
    38cc:	88 0f       	add	r24, r24
    38ce:	99 1f       	adc	r25, r25
    38d0:	82 0f       	add	r24, r18
    38d2:	93 1f       	adc	r25, r19
    38d4:	fc 01       	movw	r30, r24
    38d6:	ee 58       	subi	r30, 0x8E	; 142
    38d8:	f7 4f       	sbci	r31, 0xF7	; 247
    38da:	81 81       	ldd	r24, Z+1	; 0x01
    38dc:	92 81       	ldd	r25, Z+2	; 0x02
    38de:	9a 83       	std	Y+2, r25	; 0x02
    38e0:	89 83       	std	Y+1, r24	; 0x01
    38e2:	eb 81       	ldd	r30, Y+3	; 0x03
    38e4:	fc 81       	ldd	r31, Y+4	; 0x04
    38e6:	89 81       	ldd	r24, Y+1	; 0x01
    38e8:	9a 81       	ldd	r25, Y+2	; 0x02
    38ea:	95 83       	std	Z+5, r25	; 0x05
    38ec:	84 83       	std	Z+4, r24	; 0x04
    38ee:	e9 81       	ldd	r30, Y+1	; 0x01
    38f0:	fa 81       	ldd	r31, Y+2	; 0x02
    38f2:	84 81       	ldd	r24, Z+4	; 0x04
    38f4:	95 81       	ldd	r25, Z+5	; 0x05
    38f6:	eb 81       	ldd	r30, Y+3	; 0x03
    38f8:	fc 81       	ldd	r31, Y+4	; 0x04
    38fa:	97 83       	std	Z+7, r25	; 0x07
    38fc:	86 83       	std	Z+6, r24	; 0x06
    38fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3900:	fa 81       	ldd	r31, Y+2	; 0x02
    3902:	04 80       	ldd	r0, Z+4	; 0x04
    3904:	f5 81       	ldd	r31, Z+5	; 0x05
    3906:	e0 2d       	mov	r30, r0
    3908:	8b 81       	ldd	r24, Y+3	; 0x03
    390a:	9c 81       	ldd	r25, Y+4	; 0x04
    390c:	02 96       	adiw	r24, 0x02	; 2
    390e:	93 83       	std	Z+3, r25	; 0x03
    3910:	82 83       	std	Z+2, r24	; 0x02
    3912:	8b 81       	ldd	r24, Y+3	; 0x03
    3914:	9c 81       	ldd	r25, Y+4	; 0x04
    3916:	02 96       	adiw	r24, 0x02	; 2
    3918:	e9 81       	ldd	r30, Y+1	; 0x01
    391a:	fa 81       	ldd	r31, Y+2	; 0x02
    391c:	95 83       	std	Z+5, r25	; 0x05
    391e:	84 83       	std	Z+4, r24	; 0x04
    3920:	eb 81       	ldd	r30, Y+3	; 0x03
    3922:	fc 81       	ldd	r31, Y+4	; 0x04
    3924:	86 89       	ldd	r24, Z+22	; 0x16
    3926:	28 2f       	mov	r18, r24
    3928:	30 e0       	ldi	r19, 0x00	; 0
    392a:	c9 01       	movw	r24, r18
    392c:	88 0f       	add	r24, r24
    392e:	99 1f       	adc	r25, r25
    3930:	88 0f       	add	r24, r24
    3932:	99 1f       	adc	r25, r25
    3934:	88 0f       	add	r24, r24
    3936:	99 1f       	adc	r25, r25
    3938:	82 0f       	add	r24, r18
    393a:	93 1f       	adc	r25, r19
    393c:	8e 58       	subi	r24, 0x8E	; 142
    393e:	97 4f       	sbci	r25, 0xF7	; 247
    3940:	eb 81       	ldd	r30, Y+3	; 0x03
    3942:	fc 81       	ldd	r31, Y+4	; 0x04
    3944:	93 87       	std	Z+11, r25	; 0x0b
    3946:	82 87       	std	Z+10, r24	; 0x0a
    3948:	eb 81       	ldd	r30, Y+3	; 0x03
    394a:	fc 81       	ldd	r31, Y+4	; 0x04
    394c:	86 89       	ldd	r24, Z+22	; 0x16
    394e:	28 2f       	mov	r18, r24
    3950:	30 e0       	ldi	r19, 0x00	; 0
    3952:	c9 01       	movw	r24, r18
    3954:	88 0f       	add	r24, r24
    3956:	99 1f       	adc	r25, r25
    3958:	88 0f       	add	r24, r24
    395a:	99 1f       	adc	r25, r25
    395c:	88 0f       	add	r24, r24
    395e:	99 1f       	adc	r25, r25
    3960:	82 0f       	add	r24, r18
    3962:	93 1f       	adc	r25, r19
    3964:	fc 01       	movw	r30, r24
    3966:	ee 58       	subi	r30, 0x8E	; 142
    3968:	f7 4f       	sbci	r31, 0xF7	; 247
    396a:	80 81       	ld	r24, Z
    396c:	8f 5f       	subi	r24, 0xFF	; 255
    396e:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    3970:	0f 90       	pop	r0
    3972:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    3974:	80 91 67 08 	lds	r24, 0x0867
    3978:	88 23       	and	r24, r24
    397a:	61 f0       	breq	.+24     	; 0x3994 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    397c:	e0 91 60 08 	lds	r30, 0x0860
    3980:	f0 91 61 08 	lds	r31, 0x0861
    3984:	96 89       	ldd	r25, Z+22	; 0x16
    3986:	eb 81       	ldd	r30, Y+3	; 0x03
    3988:	fc 81       	ldd	r31, Y+4	; 0x04
    398a:	86 89       	ldd	r24, Z+22	; 0x16
    398c:	98 17       	cp	r25, r24
    398e:	10 f4       	brcc	.+4      	; 0x3994 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    3990:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3994:	0f 90       	pop	r0
    3996:	0f 90       	pop	r0
    3998:	0f 90       	pop	r0
    399a:	0f 90       	pop	r0
    399c:	cf 91       	pop	r28
    399e:	df 91       	pop	r29
    39a0:	08 95       	ret

000039a2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    39a2:	df 93       	push	r29
    39a4:	cf 93       	push	r28
    39a6:	00 d0       	rcall	.+0      	; 0x39a8 <vTaskDelete+0x6>
    39a8:	00 d0       	rcall	.+0      	; 0x39aa <vTaskDelete+0x8>
    39aa:	00 d0       	rcall	.+0      	; 0x39ac <vTaskDelete+0xa>
    39ac:	cd b7       	in	r28, 0x3d	; 61
    39ae:	de b7       	in	r29, 0x3e	; 62
    39b0:	9c 83       	std	Y+4, r25	; 0x04
    39b2:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    39b4:	0f b6       	in	r0, 0x3f	; 63
    39b6:	f8 94       	cli
    39b8:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    39ba:	8b 81       	ldd	r24, Y+3	; 0x03
    39bc:	9c 81       	ldd	r25, Y+4	; 0x04
    39be:	00 97       	sbiw	r24, 0x00	; 0
    39c0:	39 f4       	brne	.+14     	; 0x39d0 <vTaskDelete+0x2e>
    39c2:	80 91 60 08 	lds	r24, 0x0860
    39c6:	90 91 61 08 	lds	r25, 0x0861
    39ca:	9e 83       	std	Y+6, r25	; 0x06
    39cc:	8d 83       	std	Y+5, r24	; 0x05
    39ce:	04 c0       	rjmp	.+8      	; 0x39d8 <vTaskDelete+0x36>
    39d0:	8b 81       	ldd	r24, Y+3	; 0x03
    39d2:	9c 81       	ldd	r25, Y+4	; 0x04
    39d4:	9e 83       	std	Y+6, r25	; 0x06
    39d6:	8d 83       	std	Y+5, r24	; 0x05
    39d8:	8d 81       	ldd	r24, Y+5	; 0x05
    39da:	9e 81       	ldd	r25, Y+6	; 0x06
    39dc:	9a 83       	std	Y+2, r25	; 0x02
    39de:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    39e0:	89 81       	ldd	r24, Y+1	; 0x01
    39e2:	9a 81       	ldd	r25, Y+2	; 0x02
    39e4:	02 96       	adiw	r24, 0x02	; 2
    39e6:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    39ea:	e9 81       	ldd	r30, Y+1	; 0x01
    39ec:	fa 81       	ldd	r31, Y+2	; 0x02
    39ee:	84 89       	ldd	r24, Z+20	; 0x14
    39f0:	95 89       	ldd	r25, Z+21	; 0x15
    39f2:	00 97       	sbiw	r24, 0x00	; 0
    39f4:	29 f0       	breq	.+10     	; 0x3a00 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    39f6:	89 81       	ldd	r24, Y+1	; 0x01
    39f8:	9a 81       	ldd	r25, Y+2	; 0x02
    39fa:	0c 96       	adiw	r24, 0x0c	; 12
    39fc:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    3a00:	80 91 6c 08 	lds	r24, 0x086C
    3a04:	8f 5f       	subi	r24, 0xFF	; 255
    3a06:	80 93 6c 08 	sts	0x086C, r24

            if( pxTCB == pxCurrentTCB )
    3a0a:	20 91 60 08 	lds	r18, 0x0860
    3a0e:	30 91 61 08 	lds	r19, 0x0861
    3a12:	89 81       	ldd	r24, Y+1	; 0x01
    3a14:	9a 81       	ldd	r25, Y+2	; 0x02
    3a16:	82 17       	cp	r24, r18
    3a18:	93 07       	cpc	r25, r19
    3a1a:	81 f4       	brne	.+32     	; 0x3a3c <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3a1c:	89 81       	ldd	r24, Y+1	; 0x01
    3a1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a20:	9c 01       	movw	r18, r24
    3a22:	2e 5f       	subi	r18, 0xFE	; 254
    3a24:	3f 4f       	sbci	r19, 0xFF	; 255
    3a26:	85 eb       	ldi	r24, 0xB5	; 181
    3a28:	98 e0       	ldi	r25, 0x08	; 8
    3a2a:	b9 01       	movw	r22, r18
    3a2c:	0e 94 85 10 	call	0x210a	; 0x210a <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3a30:	80 91 62 08 	lds	r24, 0x0862
    3a34:	8f 5f       	subi	r24, 0xFF	; 255
    3a36:	80 93 62 08 	sts	0x0862, r24
    3a3a:	07 c0       	rjmp	.+14     	; 0x3a4a <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3a3c:	80 91 63 08 	lds	r24, 0x0863
    3a40:	81 50       	subi	r24, 0x01	; 1
    3a42:	80 93 63 08 	sts	0x0863, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    3a46:	0e 94 7a 26 	call	0x4cf4	; 0x4cf4 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    3a4a:	0f 90       	pop	r0
    3a4c:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3a4e:	20 91 60 08 	lds	r18, 0x0860
    3a52:	30 91 61 08 	lds	r19, 0x0861
    3a56:	89 81       	ldd	r24, Y+1	; 0x01
    3a58:	9a 81       	ldd	r25, Y+2	; 0x02
    3a5a:	82 17       	cp	r24, r18
    3a5c:	93 07       	cpc	r25, r19
    3a5e:	21 f0       	breq	.+8      	; 0x3a68 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    3a60:	89 81       	ldd	r24, Y+1	; 0x01
    3a62:	9a 81       	ldd	r25, Y+2	; 0x02
    3a64:	0e 94 64 26 	call	0x4cc8	; 0x4cc8 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    3a68:	80 91 67 08 	lds	r24, 0x0867
    3a6c:	88 23       	and	r24, r24
    3a6e:	59 f0       	breq	.+22     	; 0x3a86 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    3a70:	20 91 60 08 	lds	r18, 0x0860
    3a74:	30 91 61 08 	lds	r19, 0x0861
    3a78:	89 81       	ldd	r24, Y+1	; 0x01
    3a7a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a7c:	82 17       	cp	r24, r18
    3a7e:	93 07       	cpc	r25, r19
    3a80:	11 f4       	brne	.+4      	; 0x3a86 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    3a82:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    3a86:	26 96       	adiw	r28, 0x06	; 6
    3a88:	0f b6       	in	r0, 0x3f	; 63
    3a8a:	f8 94       	cli
    3a8c:	de bf       	out	0x3e, r29	; 62
    3a8e:	0f be       	out	0x3f, r0	; 63
    3a90:	cd bf       	out	0x3d, r28	; 61
    3a92:	cf 91       	pop	r28
    3a94:	df 91       	pop	r29
    3a96:	08 95       	ret

00003a98 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    3a98:	df 93       	push	r29
    3a9a:	cf 93       	push	r28
    3a9c:	cd b7       	in	r28, 0x3d	; 61
    3a9e:	de b7       	in	r29, 0x3e	; 62
    3aa0:	2a 97       	sbiw	r28, 0x0a	; 10
    3aa2:	0f b6       	in	r0, 0x3f	; 63
    3aa4:	f8 94       	cli
    3aa6:	de bf       	out	0x3e, r29	; 62
    3aa8:	0f be       	out	0x3f, r0	; 63
    3aaa:	cd bf       	out	0x3d, r28	; 61
    3aac:	98 87       	std	Y+8, r25	; 0x08
    3aae:	8f 83       	std	Y+7, r24	; 0x07
    3ab0:	7a 87       	std	Y+10, r23	; 0x0a
    3ab2:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3ab4:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    3ab6:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3aba:	80 91 64 08 	lds	r24, 0x0864
    3abe:	90 91 65 08 	lds	r25, 0x0865
    3ac2:	9a 83       	std	Y+2, r25	; 0x02
    3ac4:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3ac6:	ef 81       	ldd	r30, Y+7	; 0x07
    3ac8:	f8 85       	ldd	r31, Y+8	; 0x08
    3aca:	20 81       	ld	r18, Z
    3acc:	31 81       	ldd	r19, Z+1	; 0x01
    3ace:	89 85       	ldd	r24, Y+9	; 0x09
    3ad0:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ad2:	82 0f       	add	r24, r18
    3ad4:	93 1f       	adc	r25, r19
    3ad6:	9e 83       	std	Y+6, r25	; 0x06
    3ad8:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    3ada:	ef 81       	ldd	r30, Y+7	; 0x07
    3adc:	f8 85       	ldd	r31, Y+8	; 0x08
    3ade:	20 81       	ld	r18, Z
    3ae0:	31 81       	ldd	r19, Z+1	; 0x01
    3ae2:	89 81       	ldd	r24, Y+1	; 0x01
    3ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae6:	82 17       	cp	r24, r18
    3ae8:	93 07       	cpc	r25, r19
    3aea:	98 f4       	brcc	.+38     	; 0x3b12 <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3aec:	ef 81       	ldd	r30, Y+7	; 0x07
    3aee:	f8 85       	ldd	r31, Y+8	; 0x08
    3af0:	20 81       	ld	r18, Z
    3af2:	31 81       	ldd	r19, Z+1	; 0x01
    3af4:	8d 81       	ldd	r24, Y+5	; 0x05
    3af6:	9e 81       	ldd	r25, Y+6	; 0x06
    3af8:	82 17       	cp	r24, r18
    3afa:	93 07       	cpc	r25, r19
    3afc:	e0 f4       	brcc	.+56     	; 0x3b36 <xTaskDelayUntil+0x9e>
    3afe:	2d 81       	ldd	r18, Y+5	; 0x05
    3b00:	3e 81       	ldd	r19, Y+6	; 0x06
    3b02:	89 81       	ldd	r24, Y+1	; 0x01
    3b04:	9a 81       	ldd	r25, Y+2	; 0x02
    3b06:	82 17       	cp	r24, r18
    3b08:	93 07       	cpc	r25, r19
    3b0a:	a8 f4       	brcc	.+42     	; 0x3b36 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3b0c:	81 e0       	ldi	r24, 0x01	; 1
    3b0e:	8b 83       	std	Y+3, r24	; 0x03
    3b10:	12 c0       	rjmp	.+36     	; 0x3b36 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3b12:	ef 81       	ldd	r30, Y+7	; 0x07
    3b14:	f8 85       	ldd	r31, Y+8	; 0x08
    3b16:	20 81       	ld	r18, Z
    3b18:	31 81       	ldd	r19, Z+1	; 0x01
    3b1a:	8d 81       	ldd	r24, Y+5	; 0x05
    3b1c:	9e 81       	ldd	r25, Y+6	; 0x06
    3b1e:	82 17       	cp	r24, r18
    3b20:	93 07       	cpc	r25, r19
    3b22:	38 f0       	brcs	.+14     	; 0x3b32 <xTaskDelayUntil+0x9a>
    3b24:	2d 81       	ldd	r18, Y+5	; 0x05
    3b26:	3e 81       	ldd	r19, Y+6	; 0x06
    3b28:	89 81       	ldd	r24, Y+1	; 0x01
    3b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b2c:	82 17       	cp	r24, r18
    3b2e:	93 07       	cpc	r25, r19
    3b30:	10 f4       	brcc	.+4      	; 0x3b36 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3b32:	81 e0       	ldi	r24, 0x01	; 1
    3b34:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    3b36:	ef 81       	ldd	r30, Y+7	; 0x07
    3b38:	f8 85       	ldd	r31, Y+8	; 0x08
    3b3a:	8d 81       	ldd	r24, Y+5	; 0x05
    3b3c:	9e 81       	ldd	r25, Y+6	; 0x06
    3b3e:	91 83       	std	Z+1, r25	; 0x01
    3b40:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    3b42:	8b 81       	ldd	r24, Y+3	; 0x03
    3b44:	88 23       	and	r24, r24
    3b46:	49 f0       	breq	.+18     	; 0x3b5a <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3b48:	8d 81       	ldd	r24, Y+5	; 0x05
    3b4a:	9e 81       	ldd	r25, Y+6	; 0x06
    3b4c:	29 81       	ldd	r18, Y+1	; 0x01
    3b4e:	3a 81       	ldd	r19, Y+2	; 0x02
    3b50:	82 1b       	sub	r24, r18
    3b52:	93 0b       	sbc	r25, r19
    3b54:	60 e0       	ldi	r22, 0x00	; 0
    3b56:	0e 94 61 2e 	call	0x5cc2	; 0x5cc2 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    3b5a:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    3b5e:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3b60:	8c 81       	ldd	r24, Y+4	; 0x04
    3b62:	88 23       	and	r24, r24
    3b64:	11 f4       	brne	.+4      	; 0x3b6a <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    3b66:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    3b6a:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3b6c:	2a 96       	adiw	r28, 0x0a	; 10
    3b6e:	0f b6       	in	r0, 0x3f	; 63
    3b70:	f8 94       	cli
    3b72:	de bf       	out	0x3e, r29	; 62
    3b74:	0f be       	out	0x3f, r0	; 63
    3b76:	cd bf       	out	0x3d, r28	; 61
    3b78:	cf 91       	pop	r28
    3b7a:	df 91       	pop	r29
    3b7c:	08 95       	ret

00003b7e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    3b7e:	df 93       	push	r29
    3b80:	cf 93       	push	r28
    3b82:	00 d0       	rcall	.+0      	; 0x3b84 <vTaskDelay+0x6>
    3b84:	0f 92       	push	r0
    3b86:	cd b7       	in	r28, 0x3d	; 61
    3b88:	de b7       	in	r29, 0x3e	; 62
    3b8a:	9b 83       	std	Y+3, r25	; 0x03
    3b8c:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    3b8e:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3b90:	8a 81       	ldd	r24, Y+2	; 0x02
    3b92:	9b 81       	ldd	r25, Y+3	; 0x03
    3b94:	00 97       	sbiw	r24, 0x00	; 0
    3b96:	51 f0       	breq	.+20     	; 0x3bac <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    3b98:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b9e:	9b 81       	ldd	r25, Y+3	; 0x03
    3ba0:	60 e0       	ldi	r22, 0x00	; 0
    3ba2:	0e 94 61 2e 	call	0x5cc2	; 0x5cc2 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3ba6:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    3baa:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3bac:	89 81       	ldd	r24, Y+1	; 0x01
    3bae:	88 23       	and	r24, r24
    3bb0:	11 f4       	brne	.+4      	; 0x3bb6 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    3bb2:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3bb6:	0f 90       	pop	r0
    3bb8:	0f 90       	pop	r0
    3bba:	0f 90       	pop	r0
    3bbc:	cf 91       	pop	r28
    3bbe:	df 91       	pop	r29
    3bc0:	08 95       	ret

00003bc2 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3bc2:	ef 92       	push	r14
    3bc4:	ff 92       	push	r15
    3bc6:	0f 93       	push	r16
    3bc8:	df 93       	push	r29
    3bca:	cf 93       	push	r28
    3bcc:	00 d0       	rcall	.+0      	; 0x3bce <vTaskStartScheduler+0xc>
    3bce:	cd b7       	in	r28, 0x3d	; 61
    3bd0:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    3bd2:	88 ee       	ldi	r24, 0xE8	; 232
    3bd4:	95 e2       	ldi	r25, 0x25	; 37
    3bd6:	20 e0       	ldi	r18, 0x00	; 0
    3bd8:	31 e0       	ldi	r19, 0x01	; 1
    3bda:	ef e6       	ldi	r30, 0x6F	; 111
    3bdc:	f8 e0       	ldi	r31, 0x08	; 8
    3bde:	b9 01       	movw	r22, r18
    3be0:	45 e5       	ldi	r20, 0x55	; 85
    3be2:	50 e0       	ldi	r21, 0x00	; 0
    3be4:	20 e0       	ldi	r18, 0x00	; 0
    3be6:	30 e0       	ldi	r19, 0x00	; 0
    3be8:	00 e0       	ldi	r16, 0x00	; 0
    3bea:	7f 01       	movw	r14, r30
    3bec:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <xTaskCreate>
    3bf0:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    3bf2:	89 81       	ldd	r24, Y+1	; 0x01
    3bf4:	81 30       	cpi	r24, 0x01	; 1
    3bf6:	19 f4       	brne	.+6      	; 0x3bfe <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    3bf8:	0e 94 c7 2e 	call	0x5d8e	; 0x5d8e <xTimerCreateTimerTask>
    3bfc:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    3bfe:	89 81       	ldd	r24, Y+1	; 0x01
    3c00:	81 30       	cpi	r24, 0x01	; 1
    3c02:	81 f4       	brne	.+32     	; 0x3c24 <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3c04:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    3c06:	8f ef       	ldi	r24, 0xFF	; 255
    3c08:	9f ef       	ldi	r25, 0xFF	; 255
    3c0a:	90 93 6e 08 	sts	0x086E, r25
    3c0e:	80 93 6d 08 	sts	0x086D, r24
        xSchedulerRunning = pdTRUE;
    3c12:	81 e0       	ldi	r24, 0x01	; 1
    3c14:	80 93 67 08 	sts	0x0867, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3c18:	10 92 65 08 	sts	0x0865, r1
    3c1c:	10 92 64 08 	sts	0x0864, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    3c20:	0e 94 d6 08 	call	0x11ac	; 0x11ac <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3c24:	80 91 30 02 	lds	r24, 0x0230
}
    3c28:	0f 90       	pop	r0
    3c2a:	0f 90       	pop	r0
    3c2c:	cf 91       	pop	r28
    3c2e:	df 91       	pop	r29
    3c30:	0f 91       	pop	r16
    3c32:	ff 90       	pop	r15
    3c34:	ef 90       	pop	r14
    3c36:	08 95       	ret

00003c38 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3c38:	df 93       	push	r29
    3c3a:	cf 93       	push	r28
    3c3c:	cd b7       	in	r28, 0x3d	; 61
    3c3e:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3c40:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3c42:	10 92 67 08 	sts	0x0867, r1
    vPortEndScheduler();
    3c46:	0e 94 0b 09 	call	0x1216	; 0x1216 <vPortEndScheduler>
}
    3c4a:	cf 91       	pop	r28
    3c4c:	df 91       	pop	r29
    3c4e:	08 95       	ret

00003c50 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3c50:	df 93       	push	r29
    3c52:	cf 93       	push	r28
    3c54:	cd b7       	in	r28, 0x3d	; 61
    3c56:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3c58:	80 91 71 08 	lds	r24, 0x0871
    3c5c:	8f 5f       	subi	r24, 0xFF	; 255
    3c5e:	80 93 71 08 	sts	0x0871, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3c62:	cf 91       	pop	r28
    3c64:	df 91       	pop	r29
    3c66:	08 95       	ret

00003c68 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3c68:	df 93       	push	r29
    3c6a:	cf 93       	push	r28
    3c6c:	cd b7       	in	r28, 0x3d	; 61
    3c6e:	de b7       	in	r29, 0x3e	; 62
    3c70:	2b 97       	sbiw	r28, 0x0b	; 11
    3c72:	0f b6       	in	r0, 0x3f	; 63
    3c74:	f8 94       	cli
    3c76:	de bf       	out	0x3e, r29	; 62
    3c78:	0f be       	out	0x3f, r0	; 63
    3c7a:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    3c7c:	1b 86       	std	Y+11, r1	; 0x0b
    3c7e:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    3c80:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3c82:	0f b6       	in	r0, 0x3f	; 63
    3c84:	f8 94       	cli
    3c86:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3c88:	80 91 71 08 	lds	r24, 0x0871
    3c8c:	81 50       	subi	r24, 0x01	; 1
    3c8e:	80 93 71 08 	sts	0x0871, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3c92:	80 91 71 08 	lds	r24, 0x0871
    3c96:	88 23       	and	r24, r24
    3c98:	09 f0       	breq	.+2      	; 0x3c9c <xTaskResumeAll+0x34>
    3c9a:	2a c1       	rjmp	.+596    	; 0x3ef0 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3c9c:	80 91 63 08 	lds	r24, 0x0863
    3ca0:	88 23       	and	r24, r24
    3ca2:	09 f4       	brne	.+2      	; 0x3ca6 <xTaskResumeAll+0x3e>
    3ca4:	25 c1       	rjmp	.+586    	; 0x3ef0 <xTaskResumeAll+0x288>
    3ca6:	f3 c0       	rjmp	.+486    	; 0x3e8e <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ca8:	e0 91 b1 08 	lds	r30, 0x08B1
    3cac:	f0 91 b2 08 	lds	r31, 0x08B2
    3cb0:	86 81       	ldd	r24, Z+6	; 0x06
    3cb2:	97 81       	ldd	r25, Z+7	; 0x07
    3cb4:	9b 87       	std	Y+11, r25	; 0x0b
    3cb6:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3cb8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3cba:	fb 85       	ldd	r31, Y+11	; 0x0b
    3cbc:	84 89       	ldd	r24, Z+20	; 0x14
    3cbe:	95 89       	ldd	r25, Z+21	; 0x15
    3cc0:	98 87       	std	Y+8, r25	; 0x08
    3cc2:	8f 83       	std	Y+7, r24	; 0x07
    3cc4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3cc6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3cc8:	a6 85       	ldd	r26, Z+14	; 0x0e
    3cca:	b7 85       	ldd	r27, Z+15	; 0x0f
    3ccc:	ea 85       	ldd	r30, Y+10	; 0x0a
    3cce:	fb 85       	ldd	r31, Y+11	; 0x0b
    3cd0:	80 89       	ldd	r24, Z+16	; 0x10
    3cd2:	91 89       	ldd	r25, Z+17	; 0x11
    3cd4:	15 96       	adiw	r26, 0x05	; 5
    3cd6:	9c 93       	st	X, r25
    3cd8:	8e 93       	st	-X, r24
    3cda:	14 97       	sbiw	r26, 0x04	; 4
    3cdc:	ea 85       	ldd	r30, Y+10	; 0x0a
    3cde:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ce0:	a0 89       	ldd	r26, Z+16	; 0x10
    3ce2:	b1 89       	ldd	r27, Z+17	; 0x11
    3ce4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ce6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ce8:	86 85       	ldd	r24, Z+14	; 0x0e
    3cea:	97 85       	ldd	r25, Z+15	; 0x0f
    3cec:	13 96       	adiw	r26, 0x03	; 3
    3cee:	9c 93       	st	X, r25
    3cf0:	8e 93       	st	-X, r24
    3cf2:	12 97       	sbiw	r26, 0x02	; 2
    3cf4:	ef 81       	ldd	r30, Y+7	; 0x07
    3cf6:	f8 85       	ldd	r31, Y+8	; 0x08
    3cf8:	21 81       	ldd	r18, Z+1	; 0x01
    3cfa:	32 81       	ldd	r19, Z+2	; 0x02
    3cfc:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cfe:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d00:	0c 96       	adiw	r24, 0x0c	; 12
    3d02:	28 17       	cp	r18, r24
    3d04:	39 07       	cpc	r19, r25
    3d06:	41 f4       	brne	.+16     	; 0x3d18 <xTaskResumeAll+0xb0>
    3d08:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d0a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d0c:	80 89       	ldd	r24, Z+16	; 0x10
    3d0e:	91 89       	ldd	r25, Z+17	; 0x11
    3d10:	ef 81       	ldd	r30, Y+7	; 0x07
    3d12:	f8 85       	ldd	r31, Y+8	; 0x08
    3d14:	92 83       	std	Z+2, r25	; 0x02
    3d16:	81 83       	std	Z+1, r24	; 0x01
    3d18:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d1a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d1c:	15 8a       	std	Z+21, r1	; 0x15
    3d1e:	14 8a       	std	Z+20, r1	; 0x14
    3d20:	ef 81       	ldd	r30, Y+7	; 0x07
    3d22:	f8 85       	ldd	r31, Y+8	; 0x08
    3d24:	80 81       	ld	r24, Z
    3d26:	81 50       	subi	r24, 0x01	; 1
    3d28:	ef 81       	ldd	r30, Y+7	; 0x07
    3d2a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d2c:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3d2e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d30:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d32:	82 85       	ldd	r24, Z+10	; 0x0a
    3d34:	93 85       	ldd	r25, Z+11	; 0x0b
    3d36:	9e 83       	std	Y+6, r25	; 0x06
    3d38:	8d 83       	std	Y+5, r24	; 0x05
    3d3a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d3c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d3e:	a4 81       	ldd	r26, Z+4	; 0x04
    3d40:	b5 81       	ldd	r27, Z+5	; 0x05
    3d42:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d44:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d46:	86 81       	ldd	r24, Z+6	; 0x06
    3d48:	97 81       	ldd	r25, Z+7	; 0x07
    3d4a:	15 96       	adiw	r26, 0x05	; 5
    3d4c:	9c 93       	st	X, r25
    3d4e:	8e 93       	st	-X, r24
    3d50:	14 97       	sbiw	r26, 0x04	; 4
    3d52:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d54:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d56:	a6 81       	ldd	r26, Z+6	; 0x06
    3d58:	b7 81       	ldd	r27, Z+7	; 0x07
    3d5a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d5c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d5e:	84 81       	ldd	r24, Z+4	; 0x04
    3d60:	95 81       	ldd	r25, Z+5	; 0x05
    3d62:	13 96       	adiw	r26, 0x03	; 3
    3d64:	9c 93       	st	X, r25
    3d66:	8e 93       	st	-X, r24
    3d68:	12 97       	sbiw	r26, 0x02	; 2
    3d6a:	ed 81       	ldd	r30, Y+5	; 0x05
    3d6c:	fe 81       	ldd	r31, Y+6	; 0x06
    3d6e:	21 81       	ldd	r18, Z+1	; 0x01
    3d70:	32 81       	ldd	r19, Z+2	; 0x02
    3d72:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d74:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d76:	02 96       	adiw	r24, 0x02	; 2
    3d78:	28 17       	cp	r18, r24
    3d7a:	39 07       	cpc	r19, r25
    3d7c:	41 f4       	brne	.+16     	; 0x3d8e <xTaskResumeAll+0x126>
    3d7e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d80:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d82:	86 81       	ldd	r24, Z+6	; 0x06
    3d84:	97 81       	ldd	r25, Z+7	; 0x07
    3d86:	ed 81       	ldd	r30, Y+5	; 0x05
    3d88:	fe 81       	ldd	r31, Y+6	; 0x06
    3d8a:	92 83       	std	Z+2, r25	; 0x02
    3d8c:	81 83       	std	Z+1, r24	; 0x01
    3d8e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d90:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d92:	13 86       	std	Z+11, r1	; 0x0b
    3d94:	12 86       	std	Z+10, r1	; 0x0a
    3d96:	ed 81       	ldd	r30, Y+5	; 0x05
    3d98:	fe 81       	ldd	r31, Y+6	; 0x06
    3d9a:	80 81       	ld	r24, Z
    3d9c:	81 50       	subi	r24, 0x01	; 1
    3d9e:	ed 81       	ldd	r30, Y+5	; 0x05
    3da0:	fe 81       	ldd	r31, Y+6	; 0x06
    3da2:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3da4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3da6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3da8:	96 89       	ldd	r25, Z+22	; 0x16
    3daa:	80 91 66 08 	lds	r24, 0x0866
    3dae:	89 17       	cp	r24, r25
    3db0:	28 f4       	brcc	.+10     	; 0x3dbc <xTaskResumeAll+0x154>
    3db2:	ea 85       	ldd	r30, Y+10	; 0x0a
    3db4:	fb 85       	ldd	r31, Y+11	; 0x0b
    3db6:	86 89       	ldd	r24, Z+22	; 0x16
    3db8:	80 93 66 08 	sts	0x0866, r24
    3dbc:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dbe:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dc0:	86 89       	ldd	r24, Z+22	; 0x16
    3dc2:	28 2f       	mov	r18, r24
    3dc4:	30 e0       	ldi	r19, 0x00	; 0
    3dc6:	c9 01       	movw	r24, r18
    3dc8:	88 0f       	add	r24, r24
    3dca:	99 1f       	adc	r25, r25
    3dcc:	88 0f       	add	r24, r24
    3dce:	99 1f       	adc	r25, r25
    3dd0:	88 0f       	add	r24, r24
    3dd2:	99 1f       	adc	r25, r25
    3dd4:	82 0f       	add	r24, r18
    3dd6:	93 1f       	adc	r25, r19
    3dd8:	fc 01       	movw	r30, r24
    3dda:	ee 58       	subi	r30, 0x8E	; 142
    3ddc:	f7 4f       	sbci	r31, 0xF7	; 247
    3dde:	81 81       	ldd	r24, Z+1	; 0x01
    3de0:	92 81       	ldd	r25, Z+2	; 0x02
    3de2:	9c 83       	std	Y+4, r25	; 0x04
    3de4:	8b 83       	std	Y+3, r24	; 0x03
    3de6:	ea 85       	ldd	r30, Y+10	; 0x0a
    3de8:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dea:	8b 81       	ldd	r24, Y+3	; 0x03
    3dec:	9c 81       	ldd	r25, Y+4	; 0x04
    3dee:	95 83       	std	Z+5, r25	; 0x05
    3df0:	84 83       	std	Z+4, r24	; 0x04
    3df2:	eb 81       	ldd	r30, Y+3	; 0x03
    3df4:	fc 81       	ldd	r31, Y+4	; 0x04
    3df6:	84 81       	ldd	r24, Z+4	; 0x04
    3df8:	95 81       	ldd	r25, Z+5	; 0x05
    3dfa:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dfc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dfe:	97 83       	std	Z+7, r25	; 0x07
    3e00:	86 83       	std	Z+6, r24	; 0x06
    3e02:	eb 81       	ldd	r30, Y+3	; 0x03
    3e04:	fc 81       	ldd	r31, Y+4	; 0x04
    3e06:	04 80       	ldd	r0, Z+4	; 0x04
    3e08:	f5 81       	ldd	r31, Z+5	; 0x05
    3e0a:	e0 2d       	mov	r30, r0
    3e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e10:	02 96       	adiw	r24, 0x02	; 2
    3e12:	93 83       	std	Z+3, r25	; 0x03
    3e14:	82 83       	std	Z+2, r24	; 0x02
    3e16:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e18:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e1a:	02 96       	adiw	r24, 0x02	; 2
    3e1c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e1e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e20:	95 83       	std	Z+5, r25	; 0x05
    3e22:	84 83       	std	Z+4, r24	; 0x04
    3e24:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e26:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e28:	86 89       	ldd	r24, Z+22	; 0x16
    3e2a:	28 2f       	mov	r18, r24
    3e2c:	30 e0       	ldi	r19, 0x00	; 0
    3e2e:	c9 01       	movw	r24, r18
    3e30:	88 0f       	add	r24, r24
    3e32:	99 1f       	adc	r25, r25
    3e34:	88 0f       	add	r24, r24
    3e36:	99 1f       	adc	r25, r25
    3e38:	88 0f       	add	r24, r24
    3e3a:	99 1f       	adc	r25, r25
    3e3c:	82 0f       	add	r24, r18
    3e3e:	93 1f       	adc	r25, r19
    3e40:	8e 58       	subi	r24, 0x8E	; 142
    3e42:	97 4f       	sbci	r25, 0xF7	; 247
    3e44:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e46:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e48:	93 87       	std	Z+11, r25	; 0x0b
    3e4a:	82 87       	std	Z+10, r24	; 0x0a
    3e4c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e4e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e50:	86 89       	ldd	r24, Z+22	; 0x16
    3e52:	28 2f       	mov	r18, r24
    3e54:	30 e0       	ldi	r19, 0x00	; 0
    3e56:	c9 01       	movw	r24, r18
    3e58:	88 0f       	add	r24, r24
    3e5a:	99 1f       	adc	r25, r25
    3e5c:	88 0f       	add	r24, r24
    3e5e:	99 1f       	adc	r25, r25
    3e60:	88 0f       	add	r24, r24
    3e62:	99 1f       	adc	r25, r25
    3e64:	82 0f       	add	r24, r18
    3e66:	93 1f       	adc	r25, r19
    3e68:	fc 01       	movw	r30, r24
    3e6a:	ee 58       	subi	r30, 0x8E	; 142
    3e6c:	f7 4f       	sbci	r31, 0xF7	; 247
    3e6e:	80 81       	ld	r24, Z
    3e70:	8f 5f       	subi	r24, 0xFF	; 255
    3e72:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3e74:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e76:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e78:	96 89       	ldd	r25, Z+22	; 0x16
    3e7a:	e0 91 60 08 	lds	r30, 0x0860
    3e7e:	f0 91 61 08 	lds	r31, 0x0861
    3e82:	86 89       	ldd	r24, Z+22	; 0x16
    3e84:	98 17       	cp	r25, r24
    3e86:	18 f0       	brcs	.+6      	; 0x3e8e <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    3e88:	81 e0       	ldi	r24, 0x01	; 1
    3e8a:	80 93 6a 08 	sts	0x086A, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3e8e:	80 91 ac 08 	lds	r24, 0x08AC
    3e92:	88 23       	and	r24, r24
    3e94:	09 f0       	breq	.+2      	; 0x3e98 <xTaskResumeAll+0x230>
    3e96:	08 cf       	rjmp	.-496    	; 0x3ca8 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3e98:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e9c:	00 97       	sbiw	r24, 0x00	; 0
    3e9e:	11 f0       	breq	.+4      	; 0x3ea4 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3ea0:	0e 94 7a 26 	call	0x4cf4	; 0x4cf4 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3ea4:	80 91 68 08 	lds	r24, 0x0868
    3ea8:	90 91 69 08 	lds	r25, 0x0869
    3eac:	9a 83       	std	Y+2, r25	; 0x02
    3eae:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    3eb0:	89 81       	ldd	r24, Y+1	; 0x01
    3eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    3eb4:	00 97       	sbiw	r24, 0x00	; 0
    3eb6:	a1 f0       	breq	.+40     	; 0x3ee0 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3eb8:	0e 94 01 20 	call	0x4002	; 0x4002 <xTaskIncrementTick>
    3ebc:	88 23       	and	r24, r24
    3ebe:	19 f0       	breq	.+6      	; 0x3ec6 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    3ec0:	81 e0       	ldi	r24, 0x01	; 1
    3ec2:	80 93 6a 08 	sts	0x086A, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3ec6:	89 81       	ldd	r24, Y+1	; 0x01
    3ec8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eca:	01 97       	sbiw	r24, 0x01	; 1
    3ecc:	9a 83       	std	Y+2, r25	; 0x02
    3ece:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3ed0:	89 81       	ldd	r24, Y+1	; 0x01
    3ed2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ed4:	00 97       	sbiw	r24, 0x00	; 0
    3ed6:	81 f7       	brne	.-32     	; 0x3eb8 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    3ed8:	10 92 69 08 	sts	0x0869, r1
    3edc:	10 92 68 08 	sts	0x0868, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3ee0:	80 91 6a 08 	lds	r24, 0x086A
    3ee4:	88 23       	and	r24, r24
    3ee6:	21 f0       	breq	.+8      	; 0x3ef0 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    3ee8:	81 e0       	ldi	r24, 0x01	; 1
    3eea:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3eec:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3ef0:	0f 90       	pop	r0
    3ef2:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    3ef4:	89 85       	ldd	r24, Y+9	; 0x09
}
    3ef6:	2b 96       	adiw	r28, 0x0b	; 11
    3ef8:	0f b6       	in	r0, 0x3f	; 63
    3efa:	f8 94       	cli
    3efc:	de bf       	out	0x3e, r29	; 62
    3efe:	0f be       	out	0x3f, r0	; 63
    3f00:	cd bf       	out	0x3d, r28	; 61
    3f02:	cf 91       	pop	r28
    3f04:	df 91       	pop	r29
    3f06:	08 95       	ret

00003f08 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3f08:	df 93       	push	r29
    3f0a:	cf 93       	push	r28
    3f0c:	00 d0       	rcall	.+0      	; 0x3f0e <xTaskGetTickCount+0x6>
    3f0e:	cd b7       	in	r28, 0x3d	; 61
    3f10:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3f12:	0f b6       	in	r0, 0x3f	; 63
    3f14:	f8 94       	cli
    3f16:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3f18:	80 91 64 08 	lds	r24, 0x0864
    3f1c:	90 91 65 08 	lds	r25, 0x0865
    3f20:	9a 83       	std	Y+2, r25	; 0x02
    3f22:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3f24:	0f 90       	pop	r0
    3f26:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3f28:	89 81       	ldd	r24, Y+1	; 0x01
    3f2a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3f2c:	0f 90       	pop	r0
    3f2e:	0f 90       	pop	r0
    3f30:	cf 91       	pop	r28
    3f32:	df 91       	pop	r29
    3f34:	08 95       	ret

00003f36 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3f36:	df 93       	push	r29
    3f38:	cf 93       	push	r28
    3f3a:	00 d0       	rcall	.+0      	; 0x3f3c <xTaskGetTickCountFromISR+0x6>
    3f3c:	0f 92       	push	r0
    3f3e:	cd b7       	in	r28, 0x3d	; 61
    3f40:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3f42:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    3f44:	80 91 64 08 	lds	r24, 0x0864
    3f48:	90 91 65 08 	lds	r25, 0x0865
    3f4c:	9b 83       	std	Y+3, r25	; 0x03
    3f4e:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3f50:	8a 81       	ldd	r24, Y+2	; 0x02
    3f52:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3f54:	0f 90       	pop	r0
    3f56:	0f 90       	pop	r0
    3f58:	0f 90       	pop	r0
    3f5a:	cf 91       	pop	r28
    3f5c:	df 91       	pop	r29
    3f5e:	08 95       	ret

00003f60 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3f60:	df 93       	push	r29
    3f62:	cf 93       	push	r28
    3f64:	cd b7       	in	r28, 0x3d	; 61
    3f66:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    3f68:	80 91 63 08 	lds	r24, 0x0863
}
    3f6c:	cf 91       	pop	r28
    3f6e:	df 91       	pop	r29
    3f70:	08 95       	ret

00003f72 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3f72:	df 93       	push	r29
    3f74:	cf 93       	push	r28
    3f76:	00 d0       	rcall	.+0      	; 0x3f78 <pcTaskGetName+0x6>
    3f78:	00 d0       	rcall	.+0      	; 0x3f7a <pcTaskGetName+0x8>
    3f7a:	00 d0       	rcall	.+0      	; 0x3f7c <pcTaskGetName+0xa>
    3f7c:	cd b7       	in	r28, 0x3d	; 61
    3f7e:	de b7       	in	r29, 0x3e	; 62
    3f80:	9c 83       	std	Y+4, r25	; 0x04
    3f82:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3f84:	8b 81       	ldd	r24, Y+3	; 0x03
    3f86:	9c 81       	ldd	r25, Y+4	; 0x04
    3f88:	00 97       	sbiw	r24, 0x00	; 0
    3f8a:	39 f4       	brne	.+14     	; 0x3f9a <pcTaskGetName+0x28>
    3f8c:	80 91 60 08 	lds	r24, 0x0860
    3f90:	90 91 61 08 	lds	r25, 0x0861
    3f94:	9e 83       	std	Y+6, r25	; 0x06
    3f96:	8d 83       	std	Y+5, r24	; 0x05
    3f98:	04 c0       	rjmp	.+8      	; 0x3fa2 <pcTaskGetName+0x30>
    3f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f9e:	9e 83       	std	Y+6, r25	; 0x06
    3fa0:	8d 83       	std	Y+5, r24	; 0x05
    3fa2:	8d 81       	ldd	r24, Y+5	; 0x05
    3fa4:	9e 81       	ldd	r25, Y+6	; 0x06
    3fa6:	9a 83       	std	Y+2, r25	; 0x02
    3fa8:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    3faa:	89 81       	ldd	r24, Y+1	; 0x01
    3fac:	9a 81       	ldd	r25, Y+2	; 0x02
    3fae:	49 96       	adiw	r24, 0x19	; 25
}
    3fb0:	26 96       	adiw	r28, 0x06	; 6
    3fb2:	0f b6       	in	r0, 0x3f	; 63
    3fb4:	f8 94       	cli
    3fb6:	de bf       	out	0x3e, r29	; 62
    3fb8:	0f be       	out	0x3f, r0	; 63
    3fba:	cd bf       	out	0x3d, r28	; 61
    3fbc:	cf 91       	pop	r28
    3fbe:	df 91       	pop	r29
    3fc0:	08 95       	ret

00003fc2 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3fc2:	df 93       	push	r29
    3fc4:	cf 93       	push	r28
    3fc6:	00 d0       	rcall	.+0      	; 0x3fc8 <xTaskCatchUpTicks+0x6>
    3fc8:	0f 92       	push	r0
    3fca:	cd b7       	in	r28, 0x3d	; 61
    3fcc:	de b7       	in	r29, 0x3e	; 62
    3fce:	9b 83       	std	Y+3, r25	; 0x03
    3fd0:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3fd2:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    3fd6:	20 91 68 08 	lds	r18, 0x0868
    3fda:	30 91 69 08 	lds	r19, 0x0869
    3fde:	8a 81       	ldd	r24, Y+2	; 0x02
    3fe0:	9b 81       	ldd	r25, Y+3	; 0x03
    3fe2:	82 0f       	add	r24, r18
    3fe4:	93 1f       	adc	r25, r19
    3fe6:	90 93 69 08 	sts	0x0869, r25
    3fea:	80 93 68 08 	sts	0x0868, r24
    xYieldOccurred = xTaskResumeAll();
    3fee:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    3ff2:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    3ff4:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ff6:	0f 90       	pop	r0
    3ff8:	0f 90       	pop	r0
    3ffa:	0f 90       	pop	r0
    3ffc:	cf 91       	pop	r28
    3ffe:	df 91       	pop	r29
    4000:	08 95       	ret

00004002 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4002:	df 93       	push	r29
    4004:	cf 93       	push	r28
    4006:	cd b7       	in	r28, 0x3d	; 61
    4008:	de b7       	in	r29, 0x3e	; 62
    400a:	2f 97       	sbiw	r28, 0x0f	; 15
    400c:	0f b6       	in	r0, 0x3f	; 63
    400e:	f8 94       	cli
    4010:	de bf       	out	0x3e, r29	; 62
    4012:	0f be       	out	0x3f, r0	; 63
    4014:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    4016:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4018:	80 91 71 08 	lds	r24, 0x0871
    401c:	88 23       	and	r24, r24
    401e:	09 f0       	breq	.+2      	; 0x4022 <xTaskIncrementTick+0x20>
    4020:	74 c1       	rjmp	.+744    	; 0x430a <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4022:	80 91 64 08 	lds	r24, 0x0864
    4026:	90 91 65 08 	lds	r25, 0x0865
    402a:	01 96       	adiw	r24, 0x01	; 1
    402c:	9a 87       	std	Y+10, r25	; 0x0a
    402e:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    4030:	89 85       	ldd	r24, Y+9	; 0x09
    4032:	9a 85       	ldd	r25, Y+10	; 0x0a
    4034:	90 93 65 08 	sts	0x0865, r25
    4038:	80 93 64 08 	sts	0x0864, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    403c:	89 85       	ldd	r24, Y+9	; 0x09
    403e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4040:	00 97       	sbiw	r24, 0x00	; 0
    4042:	d9 f4       	brne	.+54     	; 0x407a <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    4044:	80 91 a8 08 	lds	r24, 0x08A8
    4048:	90 91 a9 08 	lds	r25, 0x08A9
    404c:	98 87       	std	Y+8, r25	; 0x08
    404e:	8f 83       	std	Y+7, r24	; 0x07
    4050:	80 91 aa 08 	lds	r24, 0x08AA
    4054:	90 91 ab 08 	lds	r25, 0x08AB
    4058:	90 93 a9 08 	sts	0x08A9, r25
    405c:	80 93 a8 08 	sts	0x08A8, r24
    4060:	8f 81       	ldd	r24, Y+7	; 0x07
    4062:	98 85       	ldd	r25, Y+8	; 0x08
    4064:	90 93 ab 08 	sts	0x08AB, r25
    4068:	80 93 aa 08 	sts	0x08AA, r24
    406c:	80 91 6b 08 	lds	r24, 0x086B
    4070:	8f 5f       	subi	r24, 0xFF	; 255
    4072:	80 93 6b 08 	sts	0x086B, r24
    4076:	0e 94 7a 26 	call	0x4cf4	; 0x4cf4 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    407a:	20 91 6d 08 	lds	r18, 0x086D
    407e:	30 91 6e 08 	lds	r19, 0x086E
    4082:	89 85       	ldd	r24, Y+9	; 0x09
    4084:	9a 85       	ldd	r25, Y+10	; 0x0a
    4086:	82 17       	cp	r24, r18
    4088:	93 07       	cpc	r25, r19
    408a:	08 f4       	brcc	.+2      	; 0x408e <xTaskIncrementTick+0x8c>
    408c:	1f c1       	rjmp	.+574    	; 0x42cc <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    408e:	e0 91 a8 08 	lds	r30, 0x08A8
    4092:	f0 91 a9 08 	lds	r31, 0x08A9
    4096:	80 81       	ld	r24, Z
    4098:	88 23       	and	r24, r24
    409a:	39 f4       	brne	.+14     	; 0x40aa <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    409c:	8f ef       	ldi	r24, 0xFF	; 255
    409e:	9f ef       	ldi	r25, 0xFF	; 255
    40a0:	90 93 6e 08 	sts	0x086E, r25
    40a4:	80 93 6d 08 	sts	0x086D, r24
    40a8:	11 c1       	rjmp	.+546    	; 0x42cc <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    40aa:	e0 91 a8 08 	lds	r30, 0x08A8
    40ae:	f0 91 a9 08 	lds	r31, 0x08A9
    40b2:	05 80       	ldd	r0, Z+5	; 0x05
    40b4:	f6 81       	ldd	r31, Z+6	; 0x06
    40b6:	e0 2d       	mov	r30, r0
    40b8:	86 81       	ldd	r24, Z+6	; 0x06
    40ba:	97 81       	ldd	r25, Z+7	; 0x07
    40bc:	9f 87       	std	Y+15, r25	; 0x0f
    40be:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    40c0:	ee 85       	ldd	r30, Y+14	; 0x0e
    40c2:	ff 85       	ldd	r31, Y+15	; 0x0f
    40c4:	82 81       	ldd	r24, Z+2	; 0x02
    40c6:	93 81       	ldd	r25, Z+3	; 0x03
    40c8:	9d 87       	std	Y+13, r25	; 0x0d
    40ca:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    40cc:	29 85       	ldd	r18, Y+9	; 0x09
    40ce:	3a 85       	ldd	r19, Y+10	; 0x0a
    40d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    40d2:	9d 85       	ldd	r25, Y+13	; 0x0d
    40d4:	28 17       	cp	r18, r24
    40d6:	39 07       	cpc	r19, r25
    40d8:	38 f4       	brcc	.+14     	; 0x40e8 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    40da:	8c 85       	ldd	r24, Y+12	; 0x0c
    40dc:	9d 85       	ldd	r25, Y+13	; 0x0d
    40de:	90 93 6e 08 	sts	0x086E, r25
    40e2:	80 93 6d 08 	sts	0x086D, r24
    40e6:	f2 c0       	rjmp	.+484    	; 0x42cc <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    40e8:	ee 85       	ldd	r30, Y+14	; 0x0e
    40ea:	ff 85       	ldd	r31, Y+15	; 0x0f
    40ec:	82 85       	ldd	r24, Z+10	; 0x0a
    40ee:	93 85       	ldd	r25, Z+11	; 0x0b
    40f0:	9e 83       	std	Y+6, r25	; 0x06
    40f2:	8d 83       	std	Y+5, r24	; 0x05
    40f4:	ee 85       	ldd	r30, Y+14	; 0x0e
    40f6:	ff 85       	ldd	r31, Y+15	; 0x0f
    40f8:	a4 81       	ldd	r26, Z+4	; 0x04
    40fa:	b5 81       	ldd	r27, Z+5	; 0x05
    40fc:	ee 85       	ldd	r30, Y+14	; 0x0e
    40fe:	ff 85       	ldd	r31, Y+15	; 0x0f
    4100:	86 81       	ldd	r24, Z+6	; 0x06
    4102:	97 81       	ldd	r25, Z+7	; 0x07
    4104:	15 96       	adiw	r26, 0x05	; 5
    4106:	9c 93       	st	X, r25
    4108:	8e 93       	st	-X, r24
    410a:	14 97       	sbiw	r26, 0x04	; 4
    410c:	ee 85       	ldd	r30, Y+14	; 0x0e
    410e:	ff 85       	ldd	r31, Y+15	; 0x0f
    4110:	a6 81       	ldd	r26, Z+6	; 0x06
    4112:	b7 81       	ldd	r27, Z+7	; 0x07
    4114:	ee 85       	ldd	r30, Y+14	; 0x0e
    4116:	ff 85       	ldd	r31, Y+15	; 0x0f
    4118:	84 81       	ldd	r24, Z+4	; 0x04
    411a:	95 81       	ldd	r25, Z+5	; 0x05
    411c:	13 96       	adiw	r26, 0x03	; 3
    411e:	9c 93       	st	X, r25
    4120:	8e 93       	st	-X, r24
    4122:	12 97       	sbiw	r26, 0x02	; 2
    4124:	ed 81       	ldd	r30, Y+5	; 0x05
    4126:	fe 81       	ldd	r31, Y+6	; 0x06
    4128:	21 81       	ldd	r18, Z+1	; 0x01
    412a:	32 81       	ldd	r19, Z+2	; 0x02
    412c:	8e 85       	ldd	r24, Y+14	; 0x0e
    412e:	9f 85       	ldd	r25, Y+15	; 0x0f
    4130:	02 96       	adiw	r24, 0x02	; 2
    4132:	28 17       	cp	r18, r24
    4134:	39 07       	cpc	r19, r25
    4136:	41 f4       	brne	.+16     	; 0x4148 <xTaskIncrementTick+0x146>
    4138:	ee 85       	ldd	r30, Y+14	; 0x0e
    413a:	ff 85       	ldd	r31, Y+15	; 0x0f
    413c:	86 81       	ldd	r24, Z+6	; 0x06
    413e:	97 81       	ldd	r25, Z+7	; 0x07
    4140:	ed 81       	ldd	r30, Y+5	; 0x05
    4142:	fe 81       	ldd	r31, Y+6	; 0x06
    4144:	92 83       	std	Z+2, r25	; 0x02
    4146:	81 83       	std	Z+1, r24	; 0x01
    4148:	ee 85       	ldd	r30, Y+14	; 0x0e
    414a:	ff 85       	ldd	r31, Y+15	; 0x0f
    414c:	13 86       	std	Z+11, r1	; 0x0b
    414e:	12 86       	std	Z+10, r1	; 0x0a
    4150:	ed 81       	ldd	r30, Y+5	; 0x05
    4152:	fe 81       	ldd	r31, Y+6	; 0x06
    4154:	80 81       	ld	r24, Z
    4156:	81 50       	subi	r24, 0x01	; 1
    4158:	ed 81       	ldd	r30, Y+5	; 0x05
    415a:	fe 81       	ldd	r31, Y+6	; 0x06
    415c:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    415e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4160:	ff 85       	ldd	r31, Y+15	; 0x0f
    4162:	84 89       	ldd	r24, Z+20	; 0x14
    4164:	95 89       	ldd	r25, Z+21	; 0x15
    4166:	00 97       	sbiw	r24, 0x00	; 0
    4168:	d9 f1       	breq	.+118    	; 0x41e0 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    416a:	ee 85       	ldd	r30, Y+14	; 0x0e
    416c:	ff 85       	ldd	r31, Y+15	; 0x0f
    416e:	84 89       	ldd	r24, Z+20	; 0x14
    4170:	95 89       	ldd	r25, Z+21	; 0x15
    4172:	9c 83       	std	Y+4, r25	; 0x04
    4174:	8b 83       	std	Y+3, r24	; 0x03
    4176:	ee 85       	ldd	r30, Y+14	; 0x0e
    4178:	ff 85       	ldd	r31, Y+15	; 0x0f
    417a:	a6 85       	ldd	r26, Z+14	; 0x0e
    417c:	b7 85       	ldd	r27, Z+15	; 0x0f
    417e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4180:	ff 85       	ldd	r31, Y+15	; 0x0f
    4182:	80 89       	ldd	r24, Z+16	; 0x10
    4184:	91 89       	ldd	r25, Z+17	; 0x11
    4186:	15 96       	adiw	r26, 0x05	; 5
    4188:	9c 93       	st	X, r25
    418a:	8e 93       	st	-X, r24
    418c:	14 97       	sbiw	r26, 0x04	; 4
    418e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4190:	ff 85       	ldd	r31, Y+15	; 0x0f
    4192:	a0 89       	ldd	r26, Z+16	; 0x10
    4194:	b1 89       	ldd	r27, Z+17	; 0x11
    4196:	ee 85       	ldd	r30, Y+14	; 0x0e
    4198:	ff 85       	ldd	r31, Y+15	; 0x0f
    419a:	86 85       	ldd	r24, Z+14	; 0x0e
    419c:	97 85       	ldd	r25, Z+15	; 0x0f
    419e:	13 96       	adiw	r26, 0x03	; 3
    41a0:	9c 93       	st	X, r25
    41a2:	8e 93       	st	-X, r24
    41a4:	12 97       	sbiw	r26, 0x02	; 2
    41a6:	eb 81       	ldd	r30, Y+3	; 0x03
    41a8:	fc 81       	ldd	r31, Y+4	; 0x04
    41aa:	21 81       	ldd	r18, Z+1	; 0x01
    41ac:	32 81       	ldd	r19, Z+2	; 0x02
    41ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    41b0:	9f 85       	ldd	r25, Y+15	; 0x0f
    41b2:	0c 96       	adiw	r24, 0x0c	; 12
    41b4:	28 17       	cp	r18, r24
    41b6:	39 07       	cpc	r19, r25
    41b8:	41 f4       	brne	.+16     	; 0x41ca <xTaskIncrementTick+0x1c8>
    41ba:	ee 85       	ldd	r30, Y+14	; 0x0e
    41bc:	ff 85       	ldd	r31, Y+15	; 0x0f
    41be:	80 89       	ldd	r24, Z+16	; 0x10
    41c0:	91 89       	ldd	r25, Z+17	; 0x11
    41c2:	eb 81       	ldd	r30, Y+3	; 0x03
    41c4:	fc 81       	ldd	r31, Y+4	; 0x04
    41c6:	92 83       	std	Z+2, r25	; 0x02
    41c8:	81 83       	std	Z+1, r24	; 0x01
    41ca:	ee 85       	ldd	r30, Y+14	; 0x0e
    41cc:	ff 85       	ldd	r31, Y+15	; 0x0f
    41ce:	15 8a       	std	Z+21, r1	; 0x15
    41d0:	14 8a       	std	Z+20, r1	; 0x14
    41d2:	eb 81       	ldd	r30, Y+3	; 0x03
    41d4:	fc 81       	ldd	r31, Y+4	; 0x04
    41d6:	80 81       	ld	r24, Z
    41d8:	81 50       	subi	r24, 0x01	; 1
    41da:	eb 81       	ldd	r30, Y+3	; 0x03
    41dc:	fc 81       	ldd	r31, Y+4	; 0x04
    41de:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    41e0:	ee 85       	ldd	r30, Y+14	; 0x0e
    41e2:	ff 85       	ldd	r31, Y+15	; 0x0f
    41e4:	96 89       	ldd	r25, Z+22	; 0x16
    41e6:	80 91 66 08 	lds	r24, 0x0866
    41ea:	89 17       	cp	r24, r25
    41ec:	28 f4       	brcc	.+10     	; 0x41f8 <xTaskIncrementTick+0x1f6>
    41ee:	ee 85       	ldd	r30, Y+14	; 0x0e
    41f0:	ff 85       	ldd	r31, Y+15	; 0x0f
    41f2:	86 89       	ldd	r24, Z+22	; 0x16
    41f4:	80 93 66 08 	sts	0x0866, r24
    41f8:	ee 85       	ldd	r30, Y+14	; 0x0e
    41fa:	ff 85       	ldd	r31, Y+15	; 0x0f
    41fc:	86 89       	ldd	r24, Z+22	; 0x16
    41fe:	28 2f       	mov	r18, r24
    4200:	30 e0       	ldi	r19, 0x00	; 0
    4202:	c9 01       	movw	r24, r18
    4204:	88 0f       	add	r24, r24
    4206:	99 1f       	adc	r25, r25
    4208:	88 0f       	add	r24, r24
    420a:	99 1f       	adc	r25, r25
    420c:	88 0f       	add	r24, r24
    420e:	99 1f       	adc	r25, r25
    4210:	82 0f       	add	r24, r18
    4212:	93 1f       	adc	r25, r19
    4214:	fc 01       	movw	r30, r24
    4216:	ee 58       	subi	r30, 0x8E	; 142
    4218:	f7 4f       	sbci	r31, 0xF7	; 247
    421a:	81 81       	ldd	r24, Z+1	; 0x01
    421c:	92 81       	ldd	r25, Z+2	; 0x02
    421e:	9a 83       	std	Y+2, r25	; 0x02
    4220:	89 83       	std	Y+1, r24	; 0x01
    4222:	ee 85       	ldd	r30, Y+14	; 0x0e
    4224:	ff 85       	ldd	r31, Y+15	; 0x0f
    4226:	89 81       	ldd	r24, Y+1	; 0x01
    4228:	9a 81       	ldd	r25, Y+2	; 0x02
    422a:	95 83       	std	Z+5, r25	; 0x05
    422c:	84 83       	std	Z+4, r24	; 0x04
    422e:	e9 81       	ldd	r30, Y+1	; 0x01
    4230:	fa 81       	ldd	r31, Y+2	; 0x02
    4232:	84 81       	ldd	r24, Z+4	; 0x04
    4234:	95 81       	ldd	r25, Z+5	; 0x05
    4236:	ee 85       	ldd	r30, Y+14	; 0x0e
    4238:	ff 85       	ldd	r31, Y+15	; 0x0f
    423a:	97 83       	std	Z+7, r25	; 0x07
    423c:	86 83       	std	Z+6, r24	; 0x06
    423e:	e9 81       	ldd	r30, Y+1	; 0x01
    4240:	fa 81       	ldd	r31, Y+2	; 0x02
    4242:	04 80       	ldd	r0, Z+4	; 0x04
    4244:	f5 81       	ldd	r31, Z+5	; 0x05
    4246:	e0 2d       	mov	r30, r0
    4248:	8e 85       	ldd	r24, Y+14	; 0x0e
    424a:	9f 85       	ldd	r25, Y+15	; 0x0f
    424c:	02 96       	adiw	r24, 0x02	; 2
    424e:	93 83       	std	Z+3, r25	; 0x03
    4250:	82 83       	std	Z+2, r24	; 0x02
    4252:	8e 85       	ldd	r24, Y+14	; 0x0e
    4254:	9f 85       	ldd	r25, Y+15	; 0x0f
    4256:	02 96       	adiw	r24, 0x02	; 2
    4258:	e9 81       	ldd	r30, Y+1	; 0x01
    425a:	fa 81       	ldd	r31, Y+2	; 0x02
    425c:	95 83       	std	Z+5, r25	; 0x05
    425e:	84 83       	std	Z+4, r24	; 0x04
    4260:	ee 85       	ldd	r30, Y+14	; 0x0e
    4262:	ff 85       	ldd	r31, Y+15	; 0x0f
    4264:	86 89       	ldd	r24, Z+22	; 0x16
    4266:	28 2f       	mov	r18, r24
    4268:	30 e0       	ldi	r19, 0x00	; 0
    426a:	c9 01       	movw	r24, r18
    426c:	88 0f       	add	r24, r24
    426e:	99 1f       	adc	r25, r25
    4270:	88 0f       	add	r24, r24
    4272:	99 1f       	adc	r25, r25
    4274:	88 0f       	add	r24, r24
    4276:	99 1f       	adc	r25, r25
    4278:	82 0f       	add	r24, r18
    427a:	93 1f       	adc	r25, r19
    427c:	8e 58       	subi	r24, 0x8E	; 142
    427e:	97 4f       	sbci	r25, 0xF7	; 247
    4280:	ee 85       	ldd	r30, Y+14	; 0x0e
    4282:	ff 85       	ldd	r31, Y+15	; 0x0f
    4284:	93 87       	std	Z+11, r25	; 0x0b
    4286:	82 87       	std	Z+10, r24	; 0x0a
    4288:	ee 85       	ldd	r30, Y+14	; 0x0e
    428a:	ff 85       	ldd	r31, Y+15	; 0x0f
    428c:	86 89       	ldd	r24, Z+22	; 0x16
    428e:	28 2f       	mov	r18, r24
    4290:	30 e0       	ldi	r19, 0x00	; 0
    4292:	c9 01       	movw	r24, r18
    4294:	88 0f       	add	r24, r24
    4296:	99 1f       	adc	r25, r25
    4298:	88 0f       	add	r24, r24
    429a:	99 1f       	adc	r25, r25
    429c:	88 0f       	add	r24, r24
    429e:	99 1f       	adc	r25, r25
    42a0:	82 0f       	add	r24, r18
    42a2:	93 1f       	adc	r25, r19
    42a4:	fc 01       	movw	r30, r24
    42a6:	ee 58       	subi	r30, 0x8E	; 142
    42a8:	f7 4f       	sbci	r31, 0xF7	; 247
    42aa:	80 81       	ld	r24, Z
    42ac:	8f 5f       	subi	r24, 0xFF	; 255
    42ae:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    42b0:	ee 85       	ldd	r30, Y+14	; 0x0e
    42b2:	ff 85       	ldd	r31, Y+15	; 0x0f
    42b4:	96 89       	ldd	r25, Z+22	; 0x16
    42b6:	e0 91 60 08 	lds	r30, 0x0860
    42ba:	f0 91 61 08 	lds	r31, 0x0861
    42be:	86 89       	ldd	r24, Z+22	; 0x16
    42c0:	98 17       	cp	r25, r24
    42c2:	08 f4       	brcc	.+2      	; 0x42c6 <xTaskIncrementTick+0x2c4>
    42c4:	e4 ce       	rjmp	.-568    	; 0x408e <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    42c6:	81 e0       	ldi	r24, 0x01	; 1
    42c8:	8b 87       	std	Y+11, r24	; 0x0b
    42ca:	e1 ce       	rjmp	.-574    	; 0x408e <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    42cc:	e0 91 60 08 	lds	r30, 0x0860
    42d0:	f0 91 61 08 	lds	r31, 0x0861
    42d4:	86 89       	ldd	r24, Z+22	; 0x16
    42d6:	28 2f       	mov	r18, r24
    42d8:	30 e0       	ldi	r19, 0x00	; 0
    42da:	c9 01       	movw	r24, r18
    42dc:	88 0f       	add	r24, r24
    42de:	99 1f       	adc	r25, r25
    42e0:	88 0f       	add	r24, r24
    42e2:	99 1f       	adc	r25, r25
    42e4:	88 0f       	add	r24, r24
    42e6:	99 1f       	adc	r25, r25
    42e8:	82 0f       	add	r24, r18
    42ea:	93 1f       	adc	r25, r19
    42ec:	fc 01       	movw	r30, r24
    42ee:	ee 58       	subi	r30, 0x8E	; 142
    42f0:	f7 4f       	sbci	r31, 0xF7	; 247
    42f2:	80 81       	ld	r24, Z
    42f4:	82 30       	cpi	r24, 0x02	; 2
    42f6:	10 f0       	brcs	.+4      	; 0x42fc <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    42f8:	81 e0       	ldi	r24, 0x01	; 1
    42fa:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    42fc:	80 91 6a 08 	lds	r24, 0x086A
    4300:	88 23       	and	r24, r24
    4302:	61 f0       	breq	.+24     	; 0x431c <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    4304:	81 e0       	ldi	r24, 0x01	; 1
    4306:	8b 87       	std	Y+11, r24	; 0x0b
    4308:	09 c0       	rjmp	.+18     	; 0x431c <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    430a:	80 91 68 08 	lds	r24, 0x0868
    430e:	90 91 69 08 	lds	r25, 0x0869
    4312:	01 96       	adiw	r24, 0x01	; 1
    4314:	90 93 69 08 	sts	0x0869, r25
    4318:	80 93 68 08 	sts	0x0868, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    431c:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    431e:	2f 96       	adiw	r28, 0x0f	; 15
    4320:	0f b6       	in	r0, 0x3f	; 63
    4322:	f8 94       	cli
    4324:	de bf       	out	0x3e, r29	; 62
    4326:	0f be       	out	0x3f, r0	; 63
    4328:	cd bf       	out	0x3d, r28	; 61
    432a:	cf 91       	pop	r28
    432c:	df 91       	pop	r29
    432e:	08 95       	ret

00004330 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4330:	df 93       	push	r29
    4332:	cf 93       	push	r28
    4334:	00 d0       	rcall	.+0      	; 0x4336 <vTaskSwitchContext+0x6>
    4336:	0f 92       	push	r0
    4338:	cd b7       	in	r28, 0x3d	; 61
    433a:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    433c:	80 91 71 08 	lds	r24, 0x0871
    4340:	88 23       	and	r24, r24
    4342:	21 f0       	breq	.+8      	; 0x434c <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    4344:	81 e0       	ldi	r24, 0x01	; 1
    4346:	80 93 6a 08 	sts	0x086A, r24
    434a:	59 c0       	rjmp	.+178    	; 0x43fe <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    434c:	10 92 6a 08 	sts	0x086A, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4350:	80 91 66 08 	lds	r24, 0x0866
    4354:	8b 83       	std	Y+3, r24	; 0x03
    4356:	03 c0       	rjmp	.+6      	; 0x435e <vTaskSwitchContext+0x2e>
    4358:	8b 81       	ldd	r24, Y+3	; 0x03
    435a:	81 50       	subi	r24, 0x01	; 1
    435c:	8b 83       	std	Y+3, r24	; 0x03
    435e:	8b 81       	ldd	r24, Y+3	; 0x03
    4360:	28 2f       	mov	r18, r24
    4362:	30 e0       	ldi	r19, 0x00	; 0
    4364:	c9 01       	movw	r24, r18
    4366:	88 0f       	add	r24, r24
    4368:	99 1f       	adc	r25, r25
    436a:	88 0f       	add	r24, r24
    436c:	99 1f       	adc	r25, r25
    436e:	88 0f       	add	r24, r24
    4370:	99 1f       	adc	r25, r25
    4372:	82 0f       	add	r24, r18
    4374:	93 1f       	adc	r25, r19
    4376:	fc 01       	movw	r30, r24
    4378:	ee 58       	subi	r30, 0x8E	; 142
    437a:	f7 4f       	sbci	r31, 0xF7	; 247
    437c:	80 81       	ld	r24, Z
    437e:	88 23       	and	r24, r24
    4380:	59 f3       	breq	.-42     	; 0x4358 <vTaskSwitchContext+0x28>
    4382:	8b 81       	ldd	r24, Y+3	; 0x03
    4384:	28 2f       	mov	r18, r24
    4386:	30 e0       	ldi	r19, 0x00	; 0
    4388:	c9 01       	movw	r24, r18
    438a:	88 0f       	add	r24, r24
    438c:	99 1f       	adc	r25, r25
    438e:	88 0f       	add	r24, r24
    4390:	99 1f       	adc	r25, r25
    4392:	88 0f       	add	r24, r24
    4394:	99 1f       	adc	r25, r25
    4396:	82 0f       	add	r24, r18
    4398:	93 1f       	adc	r25, r19
    439a:	8e 58       	subi	r24, 0x8E	; 142
    439c:	97 4f       	sbci	r25, 0xF7	; 247
    439e:	9a 83       	std	Y+2, r25	; 0x02
    43a0:	89 83       	std	Y+1, r24	; 0x01
    43a2:	e9 81       	ldd	r30, Y+1	; 0x01
    43a4:	fa 81       	ldd	r31, Y+2	; 0x02
    43a6:	01 80       	ldd	r0, Z+1	; 0x01
    43a8:	f2 81       	ldd	r31, Z+2	; 0x02
    43aa:	e0 2d       	mov	r30, r0
    43ac:	82 81       	ldd	r24, Z+2	; 0x02
    43ae:	93 81       	ldd	r25, Z+3	; 0x03
    43b0:	e9 81       	ldd	r30, Y+1	; 0x01
    43b2:	fa 81       	ldd	r31, Y+2	; 0x02
    43b4:	92 83       	std	Z+2, r25	; 0x02
    43b6:	81 83       	std	Z+1, r24	; 0x01
    43b8:	e9 81       	ldd	r30, Y+1	; 0x01
    43ba:	fa 81       	ldd	r31, Y+2	; 0x02
    43bc:	21 81       	ldd	r18, Z+1	; 0x01
    43be:	32 81       	ldd	r19, Z+2	; 0x02
    43c0:	89 81       	ldd	r24, Y+1	; 0x01
    43c2:	9a 81       	ldd	r25, Y+2	; 0x02
    43c4:	03 96       	adiw	r24, 0x03	; 3
    43c6:	28 17       	cp	r18, r24
    43c8:	39 07       	cpc	r19, r25
    43ca:	59 f4       	brne	.+22     	; 0x43e2 <vTaskSwitchContext+0xb2>
    43cc:	e9 81       	ldd	r30, Y+1	; 0x01
    43ce:	fa 81       	ldd	r31, Y+2	; 0x02
    43d0:	01 80       	ldd	r0, Z+1	; 0x01
    43d2:	f2 81       	ldd	r31, Z+2	; 0x02
    43d4:	e0 2d       	mov	r30, r0
    43d6:	82 81       	ldd	r24, Z+2	; 0x02
    43d8:	93 81       	ldd	r25, Z+3	; 0x03
    43da:	e9 81       	ldd	r30, Y+1	; 0x01
    43dc:	fa 81       	ldd	r31, Y+2	; 0x02
    43de:	92 83       	std	Z+2, r25	; 0x02
    43e0:	81 83       	std	Z+1, r24	; 0x01
    43e2:	e9 81       	ldd	r30, Y+1	; 0x01
    43e4:	fa 81       	ldd	r31, Y+2	; 0x02
    43e6:	01 80       	ldd	r0, Z+1	; 0x01
    43e8:	f2 81       	ldd	r31, Z+2	; 0x02
    43ea:	e0 2d       	mov	r30, r0
    43ec:	86 81       	ldd	r24, Z+6	; 0x06
    43ee:	97 81       	ldd	r25, Z+7	; 0x07
    43f0:	90 93 61 08 	sts	0x0861, r25
    43f4:	80 93 60 08 	sts	0x0860, r24
    43f8:	8b 81       	ldd	r24, Y+3	; 0x03
    43fa:	80 93 66 08 	sts	0x0866, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    43fe:	0f 90       	pop	r0
    4400:	0f 90       	pop	r0
    4402:	0f 90       	pop	r0
    4404:	cf 91       	pop	r28
    4406:	df 91       	pop	r29
    4408:	08 95       	ret

0000440a <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    440a:	df 93       	push	r29
    440c:	cf 93       	push	r28
    440e:	00 d0       	rcall	.+0      	; 0x4410 <vTaskPlaceOnEventList+0x6>
    4410:	00 d0       	rcall	.+0      	; 0x4412 <vTaskPlaceOnEventList+0x8>
    4412:	cd b7       	in	r28, 0x3d	; 61
    4414:	de b7       	in	r29, 0x3e	; 62
    4416:	9a 83       	std	Y+2, r25	; 0x02
    4418:	89 83       	std	Y+1, r24	; 0x01
    441a:	7c 83       	std	Y+4, r23	; 0x04
    441c:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    441e:	80 91 60 08 	lds	r24, 0x0860
    4422:	90 91 61 08 	lds	r25, 0x0861
    4426:	9c 01       	movw	r18, r24
    4428:	24 5f       	subi	r18, 0xF4	; 244
    442a:	3f 4f       	sbci	r19, 0xFF	; 255
    442c:	89 81       	ldd	r24, Y+1	; 0x01
    442e:	9a 81       	ldd	r25, Y+2	; 0x02
    4430:	b9 01       	movw	r22, r18
    4432:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4436:	8b 81       	ldd	r24, Y+3	; 0x03
    4438:	9c 81       	ldd	r25, Y+4	; 0x04
    443a:	61 e0       	ldi	r22, 0x01	; 1
    443c:	0e 94 61 2e 	call	0x5cc2	; 0x5cc2 <prvAddCurrentTaskToDelayedList>
}
    4440:	0f 90       	pop	r0
    4442:	0f 90       	pop	r0
    4444:	0f 90       	pop	r0
    4446:	0f 90       	pop	r0
    4448:	cf 91       	pop	r28
    444a:	df 91       	pop	r29
    444c:	08 95       	ret

0000444e <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    444e:	df 93       	push	r29
    4450:	cf 93       	push	r28
    4452:	cd b7       	in	r28, 0x3d	; 61
    4454:	de b7       	in	r29, 0x3e	; 62
    4456:	28 97       	sbiw	r28, 0x08	; 8
    4458:	0f b6       	in	r0, 0x3f	; 63
    445a:	f8 94       	cli
    445c:	de bf       	out	0x3e, r29	; 62
    445e:	0f be       	out	0x3f, r0	; 63
    4460:	cd bf       	out	0x3d, r28	; 61
    4462:	9c 83       	std	Y+4, r25	; 0x04
    4464:	8b 83       	std	Y+3, r24	; 0x03
    4466:	7e 83       	std	Y+6, r23	; 0x06
    4468:	6d 83       	std	Y+5, r22	; 0x05
    446a:	58 87       	std	Y+8, r21	; 0x08
    446c:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    446e:	e0 91 60 08 	lds	r30, 0x0860
    4472:	f0 91 61 08 	lds	r31, 0x0861
    4476:	8d 81       	ldd	r24, Y+5	; 0x05
    4478:	9e 81       	ldd	r25, Y+6	; 0x06
    447a:	90 68       	ori	r25, 0x80	; 128
    447c:	95 87       	std	Z+13, r25	; 0x0d
    447e:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4480:	eb 81       	ldd	r30, Y+3	; 0x03
    4482:	fc 81       	ldd	r31, Y+4	; 0x04
    4484:	81 81       	ldd	r24, Z+1	; 0x01
    4486:	92 81       	ldd	r25, Z+2	; 0x02
    4488:	9a 83       	std	Y+2, r25	; 0x02
    448a:	89 83       	std	Y+1, r24	; 0x01
    448c:	e0 91 60 08 	lds	r30, 0x0860
    4490:	f0 91 61 08 	lds	r31, 0x0861
    4494:	89 81       	ldd	r24, Y+1	; 0x01
    4496:	9a 81       	ldd	r25, Y+2	; 0x02
    4498:	97 87       	std	Z+15, r25	; 0x0f
    449a:	86 87       	std	Z+14, r24	; 0x0e
    449c:	a0 91 60 08 	lds	r26, 0x0860
    44a0:	b0 91 61 08 	lds	r27, 0x0861
    44a4:	e9 81       	ldd	r30, Y+1	; 0x01
    44a6:	fa 81       	ldd	r31, Y+2	; 0x02
    44a8:	84 81       	ldd	r24, Z+4	; 0x04
    44aa:	95 81       	ldd	r25, Z+5	; 0x05
    44ac:	51 96       	adiw	r26, 0x11	; 17
    44ae:	9c 93       	st	X, r25
    44b0:	8e 93       	st	-X, r24
    44b2:	50 97       	sbiw	r26, 0x10	; 16
    44b4:	e9 81       	ldd	r30, Y+1	; 0x01
    44b6:	fa 81       	ldd	r31, Y+2	; 0x02
    44b8:	04 80       	ldd	r0, Z+4	; 0x04
    44ba:	f5 81       	ldd	r31, Z+5	; 0x05
    44bc:	e0 2d       	mov	r30, r0
    44be:	80 91 60 08 	lds	r24, 0x0860
    44c2:	90 91 61 08 	lds	r25, 0x0861
    44c6:	0c 96       	adiw	r24, 0x0c	; 12
    44c8:	93 83       	std	Z+3, r25	; 0x03
    44ca:	82 83       	std	Z+2, r24	; 0x02
    44cc:	80 91 60 08 	lds	r24, 0x0860
    44d0:	90 91 61 08 	lds	r25, 0x0861
    44d4:	0c 96       	adiw	r24, 0x0c	; 12
    44d6:	e9 81       	ldd	r30, Y+1	; 0x01
    44d8:	fa 81       	ldd	r31, Y+2	; 0x02
    44da:	95 83       	std	Z+5, r25	; 0x05
    44dc:	84 83       	std	Z+4, r24	; 0x04
    44de:	e0 91 60 08 	lds	r30, 0x0860
    44e2:	f0 91 61 08 	lds	r31, 0x0861
    44e6:	8b 81       	ldd	r24, Y+3	; 0x03
    44e8:	9c 81       	ldd	r25, Y+4	; 0x04
    44ea:	95 8b       	std	Z+21, r25	; 0x15
    44ec:	84 8b       	std	Z+20, r24	; 0x14
    44ee:	eb 81       	ldd	r30, Y+3	; 0x03
    44f0:	fc 81       	ldd	r31, Y+4	; 0x04
    44f2:	80 81       	ld	r24, Z
    44f4:	8f 5f       	subi	r24, 0xFF	; 255
    44f6:	eb 81       	ldd	r30, Y+3	; 0x03
    44f8:	fc 81       	ldd	r31, Y+4	; 0x04
    44fa:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    44fc:	8f 81       	ldd	r24, Y+7	; 0x07
    44fe:	98 85       	ldd	r25, Y+8	; 0x08
    4500:	61 e0       	ldi	r22, 0x01	; 1
    4502:	0e 94 61 2e 	call	0x5cc2	; 0x5cc2 <prvAddCurrentTaskToDelayedList>
}
    4506:	28 96       	adiw	r28, 0x08	; 8
    4508:	0f b6       	in	r0, 0x3f	; 63
    450a:	f8 94       	cli
    450c:	de bf       	out	0x3e, r29	; 62
    450e:	0f be       	out	0x3f, r0	; 63
    4510:	cd bf       	out	0x3d, r28	; 61
    4512:	cf 91       	pop	r28
    4514:	df 91       	pop	r29
    4516:	08 95       	ret

00004518 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    4518:	df 93       	push	r29
    451a:	cf 93       	push	r28
    451c:	cd b7       	in	r28, 0x3d	; 61
    451e:	de b7       	in	r29, 0x3e	; 62
    4520:	27 97       	sbiw	r28, 0x07	; 7
    4522:	0f b6       	in	r0, 0x3f	; 63
    4524:	f8 94       	cli
    4526:	de bf       	out	0x3e, r29	; 62
    4528:	0f be       	out	0x3f, r0	; 63
    452a:	cd bf       	out	0x3d, r28	; 61
    452c:	9c 83       	std	Y+4, r25	; 0x04
    452e:	8b 83       	std	Y+3, r24	; 0x03
    4530:	7e 83       	std	Y+6, r23	; 0x06
    4532:	6d 83       	std	Y+5, r22	; 0x05
    4534:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4536:	eb 81       	ldd	r30, Y+3	; 0x03
    4538:	fc 81       	ldd	r31, Y+4	; 0x04
    453a:	81 81       	ldd	r24, Z+1	; 0x01
    453c:	92 81       	ldd	r25, Z+2	; 0x02
    453e:	9a 83       	std	Y+2, r25	; 0x02
    4540:	89 83       	std	Y+1, r24	; 0x01
    4542:	e0 91 60 08 	lds	r30, 0x0860
    4546:	f0 91 61 08 	lds	r31, 0x0861
    454a:	89 81       	ldd	r24, Y+1	; 0x01
    454c:	9a 81       	ldd	r25, Y+2	; 0x02
    454e:	97 87       	std	Z+15, r25	; 0x0f
    4550:	86 87       	std	Z+14, r24	; 0x0e
    4552:	a0 91 60 08 	lds	r26, 0x0860
    4556:	b0 91 61 08 	lds	r27, 0x0861
    455a:	e9 81       	ldd	r30, Y+1	; 0x01
    455c:	fa 81       	ldd	r31, Y+2	; 0x02
    455e:	84 81       	ldd	r24, Z+4	; 0x04
    4560:	95 81       	ldd	r25, Z+5	; 0x05
    4562:	51 96       	adiw	r26, 0x11	; 17
    4564:	9c 93       	st	X, r25
    4566:	8e 93       	st	-X, r24
    4568:	50 97       	sbiw	r26, 0x10	; 16
    456a:	e9 81       	ldd	r30, Y+1	; 0x01
    456c:	fa 81       	ldd	r31, Y+2	; 0x02
    456e:	04 80       	ldd	r0, Z+4	; 0x04
    4570:	f5 81       	ldd	r31, Z+5	; 0x05
    4572:	e0 2d       	mov	r30, r0
    4574:	80 91 60 08 	lds	r24, 0x0860
    4578:	90 91 61 08 	lds	r25, 0x0861
    457c:	0c 96       	adiw	r24, 0x0c	; 12
    457e:	93 83       	std	Z+3, r25	; 0x03
    4580:	82 83       	std	Z+2, r24	; 0x02
    4582:	80 91 60 08 	lds	r24, 0x0860
    4586:	90 91 61 08 	lds	r25, 0x0861
    458a:	0c 96       	adiw	r24, 0x0c	; 12
    458c:	e9 81       	ldd	r30, Y+1	; 0x01
    458e:	fa 81       	ldd	r31, Y+2	; 0x02
    4590:	95 83       	std	Z+5, r25	; 0x05
    4592:	84 83       	std	Z+4, r24	; 0x04
    4594:	e0 91 60 08 	lds	r30, 0x0860
    4598:	f0 91 61 08 	lds	r31, 0x0861
    459c:	8b 81       	ldd	r24, Y+3	; 0x03
    459e:	9c 81       	ldd	r25, Y+4	; 0x04
    45a0:	95 8b       	std	Z+21, r25	; 0x15
    45a2:	84 8b       	std	Z+20, r24	; 0x14
    45a4:	eb 81       	ldd	r30, Y+3	; 0x03
    45a6:	fc 81       	ldd	r31, Y+4	; 0x04
    45a8:	80 81       	ld	r24, Z
    45aa:	8f 5f       	subi	r24, 0xFF	; 255
    45ac:	eb 81       	ldd	r30, Y+3	; 0x03
    45ae:	fc 81       	ldd	r31, Y+4	; 0x04
    45b0:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    45b2:	8f 81       	ldd	r24, Y+7	; 0x07
    45b4:	88 23       	and	r24, r24
    45b6:	21 f0       	breq	.+8      	; 0x45c0 <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    45b8:	8f ef       	ldi	r24, 0xFF	; 255
    45ba:	9f ef       	ldi	r25, 0xFF	; 255
    45bc:	9e 83       	std	Y+6, r25	; 0x06
    45be:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    45c0:	8d 81       	ldd	r24, Y+5	; 0x05
    45c2:	9e 81       	ldd	r25, Y+6	; 0x06
    45c4:	6f 81       	ldd	r22, Y+7	; 0x07
    45c6:	0e 94 61 2e 	call	0x5cc2	; 0x5cc2 <prvAddCurrentTaskToDelayedList>
    }
    45ca:	27 96       	adiw	r28, 0x07	; 7
    45cc:	0f b6       	in	r0, 0x3f	; 63
    45ce:	f8 94       	cli
    45d0:	de bf       	out	0x3e, r29	; 62
    45d2:	0f be       	out	0x3f, r0	; 63
    45d4:	cd bf       	out	0x3d, r28	; 61
    45d6:	cf 91       	pop	r28
    45d8:	df 91       	pop	r29
    45da:	08 95       	ret

000045dc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    45dc:	df 93       	push	r29
    45de:	cf 93       	push	r28
    45e0:	cd b7       	in	r28, 0x3d	; 61
    45e2:	de b7       	in	r29, 0x3e	; 62
    45e4:	2d 97       	sbiw	r28, 0x0d	; 13
    45e6:	0f b6       	in	r0, 0x3f	; 63
    45e8:	f8 94       	cli
    45ea:	de bf       	out	0x3e, r29	; 62
    45ec:	0f be       	out	0x3f, r0	; 63
    45ee:	cd bf       	out	0x3d, r28	; 61
    45f0:	9d 87       	std	Y+13, r25	; 0x0d
    45f2:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    45f4:	ec 85       	ldd	r30, Y+12	; 0x0c
    45f6:	fd 85       	ldd	r31, Y+13	; 0x0d
    45f8:	05 80       	ldd	r0, Z+5	; 0x05
    45fa:	f6 81       	ldd	r31, Z+6	; 0x06
    45fc:	e0 2d       	mov	r30, r0
    45fe:	86 81       	ldd	r24, Z+6	; 0x06
    4600:	97 81       	ldd	r25, Z+7	; 0x07
    4602:	9b 87       	std	Y+11, r25	; 0x0b
    4604:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    4606:	ea 85       	ldd	r30, Y+10	; 0x0a
    4608:	fb 85       	ldd	r31, Y+11	; 0x0b
    460a:	84 89       	ldd	r24, Z+20	; 0x14
    460c:	95 89       	ldd	r25, Z+21	; 0x15
    460e:	98 87       	std	Y+8, r25	; 0x08
    4610:	8f 83       	std	Y+7, r24	; 0x07
    4612:	ea 85       	ldd	r30, Y+10	; 0x0a
    4614:	fb 85       	ldd	r31, Y+11	; 0x0b
    4616:	a6 85       	ldd	r26, Z+14	; 0x0e
    4618:	b7 85       	ldd	r27, Z+15	; 0x0f
    461a:	ea 85       	ldd	r30, Y+10	; 0x0a
    461c:	fb 85       	ldd	r31, Y+11	; 0x0b
    461e:	80 89       	ldd	r24, Z+16	; 0x10
    4620:	91 89       	ldd	r25, Z+17	; 0x11
    4622:	15 96       	adiw	r26, 0x05	; 5
    4624:	9c 93       	st	X, r25
    4626:	8e 93       	st	-X, r24
    4628:	14 97       	sbiw	r26, 0x04	; 4
    462a:	ea 85       	ldd	r30, Y+10	; 0x0a
    462c:	fb 85       	ldd	r31, Y+11	; 0x0b
    462e:	a0 89       	ldd	r26, Z+16	; 0x10
    4630:	b1 89       	ldd	r27, Z+17	; 0x11
    4632:	ea 85       	ldd	r30, Y+10	; 0x0a
    4634:	fb 85       	ldd	r31, Y+11	; 0x0b
    4636:	86 85       	ldd	r24, Z+14	; 0x0e
    4638:	97 85       	ldd	r25, Z+15	; 0x0f
    463a:	13 96       	adiw	r26, 0x03	; 3
    463c:	9c 93       	st	X, r25
    463e:	8e 93       	st	-X, r24
    4640:	12 97       	sbiw	r26, 0x02	; 2
    4642:	ef 81       	ldd	r30, Y+7	; 0x07
    4644:	f8 85       	ldd	r31, Y+8	; 0x08
    4646:	21 81       	ldd	r18, Z+1	; 0x01
    4648:	32 81       	ldd	r19, Z+2	; 0x02
    464a:	8a 85       	ldd	r24, Y+10	; 0x0a
    464c:	9b 85       	ldd	r25, Y+11	; 0x0b
    464e:	0c 96       	adiw	r24, 0x0c	; 12
    4650:	28 17       	cp	r18, r24
    4652:	39 07       	cpc	r19, r25
    4654:	41 f4       	brne	.+16     	; 0x4666 <xTaskRemoveFromEventList+0x8a>
    4656:	ea 85       	ldd	r30, Y+10	; 0x0a
    4658:	fb 85       	ldd	r31, Y+11	; 0x0b
    465a:	80 89       	ldd	r24, Z+16	; 0x10
    465c:	91 89       	ldd	r25, Z+17	; 0x11
    465e:	ef 81       	ldd	r30, Y+7	; 0x07
    4660:	f8 85       	ldd	r31, Y+8	; 0x08
    4662:	92 83       	std	Z+2, r25	; 0x02
    4664:	81 83       	std	Z+1, r24	; 0x01
    4666:	ea 85       	ldd	r30, Y+10	; 0x0a
    4668:	fb 85       	ldd	r31, Y+11	; 0x0b
    466a:	15 8a       	std	Z+21, r1	; 0x15
    466c:	14 8a       	std	Z+20, r1	; 0x14
    466e:	ef 81       	ldd	r30, Y+7	; 0x07
    4670:	f8 85       	ldd	r31, Y+8	; 0x08
    4672:	80 81       	ld	r24, Z
    4674:	81 50       	subi	r24, 0x01	; 1
    4676:	ef 81       	ldd	r30, Y+7	; 0x07
    4678:	f8 85       	ldd	r31, Y+8	; 0x08
    467a:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    467c:	80 91 71 08 	lds	r24, 0x0871
    4680:	88 23       	and	r24, r24
    4682:	09 f0       	breq	.+2      	; 0x4686 <xTaskRemoveFromEventList+0xaa>
    4684:	a4 c0       	rjmp	.+328    	; 0x47ce <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4686:	ea 85       	ldd	r30, Y+10	; 0x0a
    4688:	fb 85       	ldd	r31, Y+11	; 0x0b
    468a:	82 85       	ldd	r24, Z+10	; 0x0a
    468c:	93 85       	ldd	r25, Z+11	; 0x0b
    468e:	9e 83       	std	Y+6, r25	; 0x06
    4690:	8d 83       	std	Y+5, r24	; 0x05
    4692:	ea 85       	ldd	r30, Y+10	; 0x0a
    4694:	fb 85       	ldd	r31, Y+11	; 0x0b
    4696:	a4 81       	ldd	r26, Z+4	; 0x04
    4698:	b5 81       	ldd	r27, Z+5	; 0x05
    469a:	ea 85       	ldd	r30, Y+10	; 0x0a
    469c:	fb 85       	ldd	r31, Y+11	; 0x0b
    469e:	86 81       	ldd	r24, Z+6	; 0x06
    46a0:	97 81       	ldd	r25, Z+7	; 0x07
    46a2:	15 96       	adiw	r26, 0x05	; 5
    46a4:	9c 93       	st	X, r25
    46a6:	8e 93       	st	-X, r24
    46a8:	14 97       	sbiw	r26, 0x04	; 4
    46aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    46ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    46ae:	a6 81       	ldd	r26, Z+6	; 0x06
    46b0:	b7 81       	ldd	r27, Z+7	; 0x07
    46b2:	ea 85       	ldd	r30, Y+10	; 0x0a
    46b4:	fb 85       	ldd	r31, Y+11	; 0x0b
    46b6:	84 81       	ldd	r24, Z+4	; 0x04
    46b8:	95 81       	ldd	r25, Z+5	; 0x05
    46ba:	13 96       	adiw	r26, 0x03	; 3
    46bc:	9c 93       	st	X, r25
    46be:	8e 93       	st	-X, r24
    46c0:	12 97       	sbiw	r26, 0x02	; 2
    46c2:	ed 81       	ldd	r30, Y+5	; 0x05
    46c4:	fe 81       	ldd	r31, Y+6	; 0x06
    46c6:	21 81       	ldd	r18, Z+1	; 0x01
    46c8:	32 81       	ldd	r19, Z+2	; 0x02
    46ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    46cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    46ce:	02 96       	adiw	r24, 0x02	; 2
    46d0:	28 17       	cp	r18, r24
    46d2:	39 07       	cpc	r19, r25
    46d4:	41 f4       	brne	.+16     	; 0x46e6 <xTaskRemoveFromEventList+0x10a>
    46d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    46d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    46da:	86 81       	ldd	r24, Z+6	; 0x06
    46dc:	97 81       	ldd	r25, Z+7	; 0x07
    46de:	ed 81       	ldd	r30, Y+5	; 0x05
    46e0:	fe 81       	ldd	r31, Y+6	; 0x06
    46e2:	92 83       	std	Z+2, r25	; 0x02
    46e4:	81 83       	std	Z+1, r24	; 0x01
    46e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    46e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    46ea:	13 86       	std	Z+11, r1	; 0x0b
    46ec:	12 86       	std	Z+10, r1	; 0x0a
    46ee:	ed 81       	ldd	r30, Y+5	; 0x05
    46f0:	fe 81       	ldd	r31, Y+6	; 0x06
    46f2:	80 81       	ld	r24, Z
    46f4:	81 50       	subi	r24, 0x01	; 1
    46f6:	ed 81       	ldd	r30, Y+5	; 0x05
    46f8:	fe 81       	ldd	r31, Y+6	; 0x06
    46fa:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    46fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    46fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    4700:	96 89       	ldd	r25, Z+22	; 0x16
    4702:	80 91 66 08 	lds	r24, 0x0866
    4706:	89 17       	cp	r24, r25
    4708:	28 f4       	brcc	.+10     	; 0x4714 <xTaskRemoveFromEventList+0x138>
    470a:	ea 85       	ldd	r30, Y+10	; 0x0a
    470c:	fb 85       	ldd	r31, Y+11	; 0x0b
    470e:	86 89       	ldd	r24, Z+22	; 0x16
    4710:	80 93 66 08 	sts	0x0866, r24
    4714:	ea 85       	ldd	r30, Y+10	; 0x0a
    4716:	fb 85       	ldd	r31, Y+11	; 0x0b
    4718:	86 89       	ldd	r24, Z+22	; 0x16
    471a:	28 2f       	mov	r18, r24
    471c:	30 e0       	ldi	r19, 0x00	; 0
    471e:	c9 01       	movw	r24, r18
    4720:	88 0f       	add	r24, r24
    4722:	99 1f       	adc	r25, r25
    4724:	88 0f       	add	r24, r24
    4726:	99 1f       	adc	r25, r25
    4728:	88 0f       	add	r24, r24
    472a:	99 1f       	adc	r25, r25
    472c:	82 0f       	add	r24, r18
    472e:	93 1f       	adc	r25, r19
    4730:	fc 01       	movw	r30, r24
    4732:	ee 58       	subi	r30, 0x8E	; 142
    4734:	f7 4f       	sbci	r31, 0xF7	; 247
    4736:	81 81       	ldd	r24, Z+1	; 0x01
    4738:	92 81       	ldd	r25, Z+2	; 0x02
    473a:	9c 83       	std	Y+4, r25	; 0x04
    473c:	8b 83       	std	Y+3, r24	; 0x03
    473e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4740:	fb 85       	ldd	r31, Y+11	; 0x0b
    4742:	8b 81       	ldd	r24, Y+3	; 0x03
    4744:	9c 81       	ldd	r25, Y+4	; 0x04
    4746:	95 83       	std	Z+5, r25	; 0x05
    4748:	84 83       	std	Z+4, r24	; 0x04
    474a:	eb 81       	ldd	r30, Y+3	; 0x03
    474c:	fc 81       	ldd	r31, Y+4	; 0x04
    474e:	84 81       	ldd	r24, Z+4	; 0x04
    4750:	95 81       	ldd	r25, Z+5	; 0x05
    4752:	ea 85       	ldd	r30, Y+10	; 0x0a
    4754:	fb 85       	ldd	r31, Y+11	; 0x0b
    4756:	97 83       	std	Z+7, r25	; 0x07
    4758:	86 83       	std	Z+6, r24	; 0x06
    475a:	eb 81       	ldd	r30, Y+3	; 0x03
    475c:	fc 81       	ldd	r31, Y+4	; 0x04
    475e:	04 80       	ldd	r0, Z+4	; 0x04
    4760:	f5 81       	ldd	r31, Z+5	; 0x05
    4762:	e0 2d       	mov	r30, r0
    4764:	8a 85       	ldd	r24, Y+10	; 0x0a
    4766:	9b 85       	ldd	r25, Y+11	; 0x0b
    4768:	02 96       	adiw	r24, 0x02	; 2
    476a:	93 83       	std	Z+3, r25	; 0x03
    476c:	82 83       	std	Z+2, r24	; 0x02
    476e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4770:	9b 85       	ldd	r25, Y+11	; 0x0b
    4772:	02 96       	adiw	r24, 0x02	; 2
    4774:	eb 81       	ldd	r30, Y+3	; 0x03
    4776:	fc 81       	ldd	r31, Y+4	; 0x04
    4778:	95 83       	std	Z+5, r25	; 0x05
    477a:	84 83       	std	Z+4, r24	; 0x04
    477c:	ea 85       	ldd	r30, Y+10	; 0x0a
    477e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4780:	86 89       	ldd	r24, Z+22	; 0x16
    4782:	28 2f       	mov	r18, r24
    4784:	30 e0       	ldi	r19, 0x00	; 0
    4786:	c9 01       	movw	r24, r18
    4788:	88 0f       	add	r24, r24
    478a:	99 1f       	adc	r25, r25
    478c:	88 0f       	add	r24, r24
    478e:	99 1f       	adc	r25, r25
    4790:	88 0f       	add	r24, r24
    4792:	99 1f       	adc	r25, r25
    4794:	82 0f       	add	r24, r18
    4796:	93 1f       	adc	r25, r19
    4798:	8e 58       	subi	r24, 0x8E	; 142
    479a:	97 4f       	sbci	r25, 0xF7	; 247
    479c:	ea 85       	ldd	r30, Y+10	; 0x0a
    479e:	fb 85       	ldd	r31, Y+11	; 0x0b
    47a0:	93 87       	std	Z+11, r25	; 0x0b
    47a2:	82 87       	std	Z+10, r24	; 0x0a
    47a4:	ea 85       	ldd	r30, Y+10	; 0x0a
    47a6:	fb 85       	ldd	r31, Y+11	; 0x0b
    47a8:	86 89       	ldd	r24, Z+22	; 0x16
    47aa:	28 2f       	mov	r18, r24
    47ac:	30 e0       	ldi	r19, 0x00	; 0
    47ae:	c9 01       	movw	r24, r18
    47b0:	88 0f       	add	r24, r24
    47b2:	99 1f       	adc	r25, r25
    47b4:	88 0f       	add	r24, r24
    47b6:	99 1f       	adc	r25, r25
    47b8:	88 0f       	add	r24, r24
    47ba:	99 1f       	adc	r25, r25
    47bc:	82 0f       	add	r24, r18
    47be:	93 1f       	adc	r25, r19
    47c0:	fc 01       	movw	r30, r24
    47c2:	ee 58       	subi	r30, 0x8E	; 142
    47c4:	f7 4f       	sbci	r31, 0xF7	; 247
    47c6:	80 81       	ld	r24, Z
    47c8:	8f 5f       	subi	r24, 0xFF	; 255
    47ca:	80 83       	st	Z, r24
    47cc:	30 c0       	rjmp	.+96     	; 0x482e <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    47ce:	80 91 ad 08 	lds	r24, 0x08AD
    47d2:	90 91 ae 08 	lds	r25, 0x08AE
    47d6:	9a 83       	std	Y+2, r25	; 0x02
    47d8:	89 83       	std	Y+1, r24	; 0x01
    47da:	ea 85       	ldd	r30, Y+10	; 0x0a
    47dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    47de:	89 81       	ldd	r24, Y+1	; 0x01
    47e0:	9a 81       	ldd	r25, Y+2	; 0x02
    47e2:	97 87       	std	Z+15, r25	; 0x0f
    47e4:	86 87       	std	Z+14, r24	; 0x0e
    47e6:	e9 81       	ldd	r30, Y+1	; 0x01
    47e8:	fa 81       	ldd	r31, Y+2	; 0x02
    47ea:	84 81       	ldd	r24, Z+4	; 0x04
    47ec:	95 81       	ldd	r25, Z+5	; 0x05
    47ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    47f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    47f2:	91 8b       	std	Z+17, r25	; 0x11
    47f4:	80 8b       	std	Z+16, r24	; 0x10
    47f6:	e9 81       	ldd	r30, Y+1	; 0x01
    47f8:	fa 81       	ldd	r31, Y+2	; 0x02
    47fa:	04 80       	ldd	r0, Z+4	; 0x04
    47fc:	f5 81       	ldd	r31, Z+5	; 0x05
    47fe:	e0 2d       	mov	r30, r0
    4800:	8a 85       	ldd	r24, Y+10	; 0x0a
    4802:	9b 85       	ldd	r25, Y+11	; 0x0b
    4804:	0c 96       	adiw	r24, 0x0c	; 12
    4806:	93 83       	std	Z+3, r25	; 0x03
    4808:	82 83       	std	Z+2, r24	; 0x02
    480a:	8a 85       	ldd	r24, Y+10	; 0x0a
    480c:	9b 85       	ldd	r25, Y+11	; 0x0b
    480e:	0c 96       	adiw	r24, 0x0c	; 12
    4810:	e9 81       	ldd	r30, Y+1	; 0x01
    4812:	fa 81       	ldd	r31, Y+2	; 0x02
    4814:	95 83       	std	Z+5, r25	; 0x05
    4816:	84 83       	std	Z+4, r24	; 0x04
    4818:	ea 85       	ldd	r30, Y+10	; 0x0a
    481a:	fb 85       	ldd	r31, Y+11	; 0x0b
    481c:	8c ea       	ldi	r24, 0xAC	; 172
    481e:	98 e0       	ldi	r25, 0x08	; 8
    4820:	95 8b       	std	Z+21, r25	; 0x15
    4822:	84 8b       	std	Z+20, r24	; 0x14
    4824:	80 91 ac 08 	lds	r24, 0x08AC
    4828:	8f 5f       	subi	r24, 0xFF	; 255
    482a:	80 93 ac 08 	sts	0x08AC, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    482e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4830:	fb 85       	ldd	r31, Y+11	; 0x0b
    4832:	96 89       	ldd	r25, Z+22	; 0x16
    4834:	e0 91 60 08 	lds	r30, 0x0860
    4838:	f0 91 61 08 	lds	r31, 0x0861
    483c:	86 89       	ldd	r24, Z+22	; 0x16
    483e:	89 17       	cp	r24, r25
    4840:	30 f4       	brcc	.+12     	; 0x484e <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    4842:	81 e0       	ldi	r24, 0x01	; 1
    4844:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4846:	81 e0       	ldi	r24, 0x01	; 1
    4848:	80 93 6a 08 	sts	0x086A, r24
    484c:	01 c0       	rjmp	.+2      	; 0x4850 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    484e:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    4850:	89 85       	ldd	r24, Y+9	; 0x09
}
    4852:	2d 96       	adiw	r28, 0x0d	; 13
    4854:	0f b6       	in	r0, 0x3f	; 63
    4856:	f8 94       	cli
    4858:	de bf       	out	0x3e, r29	; 62
    485a:	0f be       	out	0x3f, r0	; 63
    485c:	cd bf       	out	0x3d, r28	; 61
    485e:	cf 91       	pop	r28
    4860:	df 91       	pop	r29
    4862:	08 95       	ret

00004864 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4864:	df 93       	push	r29
    4866:	cf 93       	push	r28
    4868:	cd b7       	in	r28, 0x3d	; 61
    486a:	de b7       	in	r29, 0x3e	; 62
    486c:	2c 97       	sbiw	r28, 0x0c	; 12
    486e:	0f b6       	in	r0, 0x3f	; 63
    4870:	f8 94       	cli
    4872:	de bf       	out	0x3e, r29	; 62
    4874:	0f be       	out	0x3f, r0	; 63
    4876:	cd bf       	out	0x3d, r28	; 61
    4878:	9a 87       	std	Y+10, r25	; 0x0a
    487a:	89 87       	std	Y+9, r24	; 0x09
    487c:	7c 87       	std	Y+12, r23	; 0x0c
    487e:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4880:	8b 85       	ldd	r24, Y+11	; 0x0b
    4882:	9c 85       	ldd	r25, Y+12	; 0x0c
    4884:	90 68       	ori	r25, 0x80	; 128
    4886:	e9 85       	ldd	r30, Y+9	; 0x09
    4888:	fa 85       	ldd	r31, Y+10	; 0x0a
    488a:	91 83       	std	Z+1, r25	; 0x01
    488c:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    488e:	e9 85       	ldd	r30, Y+9	; 0x09
    4890:	fa 85       	ldd	r31, Y+10	; 0x0a
    4892:	86 81       	ldd	r24, Z+6	; 0x06
    4894:	97 81       	ldd	r25, Z+7	; 0x07
    4896:	98 87       	std	Y+8, r25	; 0x08
    4898:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    489a:	e9 85       	ldd	r30, Y+9	; 0x09
    489c:	fa 85       	ldd	r31, Y+10	; 0x0a
    489e:	80 85       	ldd	r24, Z+8	; 0x08
    48a0:	91 85       	ldd	r25, Z+9	; 0x09
    48a2:	9e 83       	std	Y+6, r25	; 0x06
    48a4:	8d 83       	std	Y+5, r24	; 0x05
    48a6:	e9 85       	ldd	r30, Y+9	; 0x09
    48a8:	fa 85       	ldd	r31, Y+10	; 0x0a
    48aa:	a2 81       	ldd	r26, Z+2	; 0x02
    48ac:	b3 81       	ldd	r27, Z+3	; 0x03
    48ae:	e9 85       	ldd	r30, Y+9	; 0x09
    48b0:	fa 85       	ldd	r31, Y+10	; 0x0a
    48b2:	84 81       	ldd	r24, Z+4	; 0x04
    48b4:	95 81       	ldd	r25, Z+5	; 0x05
    48b6:	15 96       	adiw	r26, 0x05	; 5
    48b8:	9c 93       	st	X, r25
    48ba:	8e 93       	st	-X, r24
    48bc:	14 97       	sbiw	r26, 0x04	; 4
    48be:	e9 85       	ldd	r30, Y+9	; 0x09
    48c0:	fa 85       	ldd	r31, Y+10	; 0x0a
    48c2:	a4 81       	ldd	r26, Z+4	; 0x04
    48c4:	b5 81       	ldd	r27, Z+5	; 0x05
    48c6:	e9 85       	ldd	r30, Y+9	; 0x09
    48c8:	fa 85       	ldd	r31, Y+10	; 0x0a
    48ca:	82 81       	ldd	r24, Z+2	; 0x02
    48cc:	93 81       	ldd	r25, Z+3	; 0x03
    48ce:	13 96       	adiw	r26, 0x03	; 3
    48d0:	9c 93       	st	X, r25
    48d2:	8e 93       	st	-X, r24
    48d4:	12 97       	sbiw	r26, 0x02	; 2
    48d6:	ed 81       	ldd	r30, Y+5	; 0x05
    48d8:	fe 81       	ldd	r31, Y+6	; 0x06
    48da:	21 81       	ldd	r18, Z+1	; 0x01
    48dc:	32 81       	ldd	r19, Z+2	; 0x02
    48de:	89 85       	ldd	r24, Y+9	; 0x09
    48e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    48e2:	28 17       	cp	r18, r24
    48e4:	39 07       	cpc	r19, r25
    48e6:	41 f4       	brne	.+16     	; 0x48f8 <vTaskRemoveFromUnorderedEventList+0x94>
    48e8:	e9 85       	ldd	r30, Y+9	; 0x09
    48ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    48ec:	84 81       	ldd	r24, Z+4	; 0x04
    48ee:	95 81       	ldd	r25, Z+5	; 0x05
    48f0:	ed 81       	ldd	r30, Y+5	; 0x05
    48f2:	fe 81       	ldd	r31, Y+6	; 0x06
    48f4:	92 83       	std	Z+2, r25	; 0x02
    48f6:	81 83       	std	Z+1, r24	; 0x01
    48f8:	e9 85       	ldd	r30, Y+9	; 0x09
    48fa:	fa 85       	ldd	r31, Y+10	; 0x0a
    48fc:	11 86       	std	Z+9, r1	; 0x09
    48fe:	10 86       	std	Z+8, r1	; 0x08
    4900:	ed 81       	ldd	r30, Y+5	; 0x05
    4902:	fe 81       	ldd	r31, Y+6	; 0x06
    4904:	80 81       	ld	r24, Z
    4906:	81 50       	subi	r24, 0x01	; 1
    4908:	ed 81       	ldd	r30, Y+5	; 0x05
    490a:	fe 81       	ldd	r31, Y+6	; 0x06
    490c:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    490e:	ef 81       	ldd	r30, Y+7	; 0x07
    4910:	f8 85       	ldd	r31, Y+8	; 0x08
    4912:	82 85       	ldd	r24, Z+10	; 0x0a
    4914:	93 85       	ldd	r25, Z+11	; 0x0b
    4916:	9c 83       	std	Y+4, r25	; 0x04
    4918:	8b 83       	std	Y+3, r24	; 0x03
    491a:	ef 81       	ldd	r30, Y+7	; 0x07
    491c:	f8 85       	ldd	r31, Y+8	; 0x08
    491e:	a4 81       	ldd	r26, Z+4	; 0x04
    4920:	b5 81       	ldd	r27, Z+5	; 0x05
    4922:	ef 81       	ldd	r30, Y+7	; 0x07
    4924:	f8 85       	ldd	r31, Y+8	; 0x08
    4926:	86 81       	ldd	r24, Z+6	; 0x06
    4928:	97 81       	ldd	r25, Z+7	; 0x07
    492a:	15 96       	adiw	r26, 0x05	; 5
    492c:	9c 93       	st	X, r25
    492e:	8e 93       	st	-X, r24
    4930:	14 97       	sbiw	r26, 0x04	; 4
    4932:	ef 81       	ldd	r30, Y+7	; 0x07
    4934:	f8 85       	ldd	r31, Y+8	; 0x08
    4936:	a6 81       	ldd	r26, Z+6	; 0x06
    4938:	b7 81       	ldd	r27, Z+7	; 0x07
    493a:	ef 81       	ldd	r30, Y+7	; 0x07
    493c:	f8 85       	ldd	r31, Y+8	; 0x08
    493e:	84 81       	ldd	r24, Z+4	; 0x04
    4940:	95 81       	ldd	r25, Z+5	; 0x05
    4942:	13 96       	adiw	r26, 0x03	; 3
    4944:	9c 93       	st	X, r25
    4946:	8e 93       	st	-X, r24
    4948:	12 97       	sbiw	r26, 0x02	; 2
    494a:	eb 81       	ldd	r30, Y+3	; 0x03
    494c:	fc 81       	ldd	r31, Y+4	; 0x04
    494e:	21 81       	ldd	r18, Z+1	; 0x01
    4950:	32 81       	ldd	r19, Z+2	; 0x02
    4952:	8f 81       	ldd	r24, Y+7	; 0x07
    4954:	98 85       	ldd	r25, Y+8	; 0x08
    4956:	02 96       	adiw	r24, 0x02	; 2
    4958:	28 17       	cp	r18, r24
    495a:	39 07       	cpc	r19, r25
    495c:	41 f4       	brne	.+16     	; 0x496e <vTaskRemoveFromUnorderedEventList+0x10a>
    495e:	ef 81       	ldd	r30, Y+7	; 0x07
    4960:	f8 85       	ldd	r31, Y+8	; 0x08
    4962:	86 81       	ldd	r24, Z+6	; 0x06
    4964:	97 81       	ldd	r25, Z+7	; 0x07
    4966:	eb 81       	ldd	r30, Y+3	; 0x03
    4968:	fc 81       	ldd	r31, Y+4	; 0x04
    496a:	92 83       	std	Z+2, r25	; 0x02
    496c:	81 83       	std	Z+1, r24	; 0x01
    496e:	ef 81       	ldd	r30, Y+7	; 0x07
    4970:	f8 85       	ldd	r31, Y+8	; 0x08
    4972:	13 86       	std	Z+11, r1	; 0x0b
    4974:	12 86       	std	Z+10, r1	; 0x0a
    4976:	eb 81       	ldd	r30, Y+3	; 0x03
    4978:	fc 81       	ldd	r31, Y+4	; 0x04
    497a:	80 81       	ld	r24, Z
    497c:	81 50       	subi	r24, 0x01	; 1
    497e:	eb 81       	ldd	r30, Y+3	; 0x03
    4980:	fc 81       	ldd	r31, Y+4	; 0x04
    4982:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4984:	ef 81       	ldd	r30, Y+7	; 0x07
    4986:	f8 85       	ldd	r31, Y+8	; 0x08
    4988:	96 89       	ldd	r25, Z+22	; 0x16
    498a:	80 91 66 08 	lds	r24, 0x0866
    498e:	89 17       	cp	r24, r25
    4990:	28 f4       	brcc	.+10     	; 0x499c <vTaskRemoveFromUnorderedEventList+0x138>
    4992:	ef 81       	ldd	r30, Y+7	; 0x07
    4994:	f8 85       	ldd	r31, Y+8	; 0x08
    4996:	86 89       	ldd	r24, Z+22	; 0x16
    4998:	80 93 66 08 	sts	0x0866, r24
    499c:	ef 81       	ldd	r30, Y+7	; 0x07
    499e:	f8 85       	ldd	r31, Y+8	; 0x08
    49a0:	86 89       	ldd	r24, Z+22	; 0x16
    49a2:	28 2f       	mov	r18, r24
    49a4:	30 e0       	ldi	r19, 0x00	; 0
    49a6:	c9 01       	movw	r24, r18
    49a8:	88 0f       	add	r24, r24
    49aa:	99 1f       	adc	r25, r25
    49ac:	88 0f       	add	r24, r24
    49ae:	99 1f       	adc	r25, r25
    49b0:	88 0f       	add	r24, r24
    49b2:	99 1f       	adc	r25, r25
    49b4:	82 0f       	add	r24, r18
    49b6:	93 1f       	adc	r25, r19
    49b8:	fc 01       	movw	r30, r24
    49ba:	ee 58       	subi	r30, 0x8E	; 142
    49bc:	f7 4f       	sbci	r31, 0xF7	; 247
    49be:	81 81       	ldd	r24, Z+1	; 0x01
    49c0:	92 81       	ldd	r25, Z+2	; 0x02
    49c2:	9a 83       	std	Y+2, r25	; 0x02
    49c4:	89 83       	std	Y+1, r24	; 0x01
    49c6:	ef 81       	ldd	r30, Y+7	; 0x07
    49c8:	f8 85       	ldd	r31, Y+8	; 0x08
    49ca:	89 81       	ldd	r24, Y+1	; 0x01
    49cc:	9a 81       	ldd	r25, Y+2	; 0x02
    49ce:	95 83       	std	Z+5, r25	; 0x05
    49d0:	84 83       	std	Z+4, r24	; 0x04
    49d2:	e9 81       	ldd	r30, Y+1	; 0x01
    49d4:	fa 81       	ldd	r31, Y+2	; 0x02
    49d6:	84 81       	ldd	r24, Z+4	; 0x04
    49d8:	95 81       	ldd	r25, Z+5	; 0x05
    49da:	ef 81       	ldd	r30, Y+7	; 0x07
    49dc:	f8 85       	ldd	r31, Y+8	; 0x08
    49de:	97 83       	std	Z+7, r25	; 0x07
    49e0:	86 83       	std	Z+6, r24	; 0x06
    49e2:	e9 81       	ldd	r30, Y+1	; 0x01
    49e4:	fa 81       	ldd	r31, Y+2	; 0x02
    49e6:	04 80       	ldd	r0, Z+4	; 0x04
    49e8:	f5 81       	ldd	r31, Z+5	; 0x05
    49ea:	e0 2d       	mov	r30, r0
    49ec:	8f 81       	ldd	r24, Y+7	; 0x07
    49ee:	98 85       	ldd	r25, Y+8	; 0x08
    49f0:	02 96       	adiw	r24, 0x02	; 2
    49f2:	93 83       	std	Z+3, r25	; 0x03
    49f4:	82 83       	std	Z+2, r24	; 0x02
    49f6:	8f 81       	ldd	r24, Y+7	; 0x07
    49f8:	98 85       	ldd	r25, Y+8	; 0x08
    49fa:	02 96       	adiw	r24, 0x02	; 2
    49fc:	e9 81       	ldd	r30, Y+1	; 0x01
    49fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4a00:	95 83       	std	Z+5, r25	; 0x05
    4a02:	84 83       	std	Z+4, r24	; 0x04
    4a04:	ef 81       	ldd	r30, Y+7	; 0x07
    4a06:	f8 85       	ldd	r31, Y+8	; 0x08
    4a08:	86 89       	ldd	r24, Z+22	; 0x16
    4a0a:	28 2f       	mov	r18, r24
    4a0c:	30 e0       	ldi	r19, 0x00	; 0
    4a0e:	c9 01       	movw	r24, r18
    4a10:	88 0f       	add	r24, r24
    4a12:	99 1f       	adc	r25, r25
    4a14:	88 0f       	add	r24, r24
    4a16:	99 1f       	adc	r25, r25
    4a18:	88 0f       	add	r24, r24
    4a1a:	99 1f       	adc	r25, r25
    4a1c:	82 0f       	add	r24, r18
    4a1e:	93 1f       	adc	r25, r19
    4a20:	8e 58       	subi	r24, 0x8E	; 142
    4a22:	97 4f       	sbci	r25, 0xF7	; 247
    4a24:	ef 81       	ldd	r30, Y+7	; 0x07
    4a26:	f8 85       	ldd	r31, Y+8	; 0x08
    4a28:	93 87       	std	Z+11, r25	; 0x0b
    4a2a:	82 87       	std	Z+10, r24	; 0x0a
    4a2c:	ef 81       	ldd	r30, Y+7	; 0x07
    4a2e:	f8 85       	ldd	r31, Y+8	; 0x08
    4a30:	86 89       	ldd	r24, Z+22	; 0x16
    4a32:	28 2f       	mov	r18, r24
    4a34:	30 e0       	ldi	r19, 0x00	; 0
    4a36:	c9 01       	movw	r24, r18
    4a38:	88 0f       	add	r24, r24
    4a3a:	99 1f       	adc	r25, r25
    4a3c:	88 0f       	add	r24, r24
    4a3e:	99 1f       	adc	r25, r25
    4a40:	88 0f       	add	r24, r24
    4a42:	99 1f       	adc	r25, r25
    4a44:	82 0f       	add	r24, r18
    4a46:	93 1f       	adc	r25, r19
    4a48:	fc 01       	movw	r30, r24
    4a4a:	ee 58       	subi	r30, 0x8E	; 142
    4a4c:	f7 4f       	sbci	r31, 0xF7	; 247
    4a4e:	80 81       	ld	r24, Z
    4a50:	8f 5f       	subi	r24, 0xFF	; 255
    4a52:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4a54:	ef 81       	ldd	r30, Y+7	; 0x07
    4a56:	f8 85       	ldd	r31, Y+8	; 0x08
    4a58:	96 89       	ldd	r25, Z+22	; 0x16
    4a5a:	e0 91 60 08 	lds	r30, 0x0860
    4a5e:	f0 91 61 08 	lds	r31, 0x0861
    4a62:	86 89       	ldd	r24, Z+22	; 0x16
    4a64:	89 17       	cp	r24, r25
    4a66:	18 f4       	brcc	.+6      	; 0x4a6e <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4a68:	81 e0       	ldi	r24, 0x01	; 1
    4a6a:	80 93 6a 08 	sts	0x086A, r24
    }
}
    4a6e:	2c 96       	adiw	r28, 0x0c	; 12
    4a70:	0f b6       	in	r0, 0x3f	; 63
    4a72:	f8 94       	cli
    4a74:	de bf       	out	0x3e, r29	; 62
    4a76:	0f be       	out	0x3f, r0	; 63
    4a78:	cd bf       	out	0x3d, r28	; 61
    4a7a:	cf 91       	pop	r28
    4a7c:	df 91       	pop	r29
    4a7e:	08 95       	ret

00004a80 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4a80:	df 93       	push	r29
    4a82:	cf 93       	push	r28
    4a84:	00 d0       	rcall	.+0      	; 0x4a86 <vTaskSetTimeOutState+0x6>
    4a86:	cd b7       	in	r28, 0x3d	; 61
    4a88:	de b7       	in	r29, 0x3e	; 62
    4a8a:	9a 83       	std	Y+2, r25	; 0x02
    4a8c:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4a8e:	0f b6       	in	r0, 0x3f	; 63
    4a90:	f8 94       	cli
    4a92:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4a94:	80 91 6b 08 	lds	r24, 0x086B
    4a98:	e9 81       	ldd	r30, Y+1	; 0x01
    4a9a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a9c:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4a9e:	80 91 64 08 	lds	r24, 0x0864
    4aa2:	90 91 65 08 	lds	r25, 0x0865
    4aa6:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa8:	fa 81       	ldd	r31, Y+2	; 0x02
    4aaa:	92 83       	std	Z+2, r25	; 0x02
    4aac:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4aae:	0f 90       	pop	r0
    4ab0:	0f be       	out	0x3f, r0	; 63
}
    4ab2:	0f 90       	pop	r0
    4ab4:	0f 90       	pop	r0
    4ab6:	cf 91       	pop	r28
    4ab8:	df 91       	pop	r29
    4aba:	08 95       	ret

00004abc <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4abc:	df 93       	push	r29
    4abe:	cf 93       	push	r28
    4ac0:	00 d0       	rcall	.+0      	; 0x4ac2 <vTaskInternalSetTimeOutState+0x6>
    4ac2:	cd b7       	in	r28, 0x3d	; 61
    4ac4:	de b7       	in	r29, 0x3e	; 62
    4ac6:	9a 83       	std	Y+2, r25	; 0x02
    4ac8:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4aca:	80 91 6b 08 	lds	r24, 0x086B
    4ace:	e9 81       	ldd	r30, Y+1	; 0x01
    4ad0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ad2:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4ad4:	80 91 64 08 	lds	r24, 0x0864
    4ad8:	90 91 65 08 	lds	r25, 0x0865
    4adc:	e9 81       	ldd	r30, Y+1	; 0x01
    4ade:	fa 81       	ldd	r31, Y+2	; 0x02
    4ae0:	92 83       	std	Z+2, r25	; 0x02
    4ae2:	81 83       	std	Z+1, r24	; 0x01
}
    4ae4:	0f 90       	pop	r0
    4ae6:	0f 90       	pop	r0
    4ae8:	cf 91       	pop	r28
    4aea:	df 91       	pop	r29
    4aec:	08 95       	ret

00004aee <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4aee:	df 93       	push	r29
    4af0:	cf 93       	push	r28
    4af2:	cd b7       	in	r28, 0x3d	; 61
    4af4:	de b7       	in	r29, 0x3e	; 62
    4af6:	29 97       	sbiw	r28, 0x09	; 9
    4af8:	0f b6       	in	r0, 0x3f	; 63
    4afa:	f8 94       	cli
    4afc:	de bf       	out	0x3e, r29	; 62
    4afe:	0f be       	out	0x3f, r0	; 63
    4b00:	cd bf       	out	0x3d, r28	; 61
    4b02:	9f 83       	std	Y+7, r25	; 0x07
    4b04:	8e 83       	std	Y+6, r24	; 0x06
    4b06:	79 87       	std	Y+9, r23	; 0x09
    4b08:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4b0a:	0f b6       	in	r0, 0x3f	; 63
    4b0c:	f8 94       	cli
    4b0e:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4b10:	80 91 64 08 	lds	r24, 0x0864
    4b14:	90 91 65 08 	lds	r25, 0x0865
    4b18:	9c 83       	std	Y+4, r25	; 0x04
    4b1a:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4b1c:	ee 81       	ldd	r30, Y+6	; 0x06
    4b1e:	ff 81       	ldd	r31, Y+7	; 0x07
    4b20:	21 81       	ldd	r18, Z+1	; 0x01
    4b22:	32 81       	ldd	r19, Z+2	; 0x02
    4b24:	8b 81       	ldd	r24, Y+3	; 0x03
    4b26:	9c 81       	ldd	r25, Y+4	; 0x04
    4b28:	82 1b       	sub	r24, r18
    4b2a:	93 0b       	sbc	r25, r19
    4b2c:	9a 83       	std	Y+2, r25	; 0x02
    4b2e:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4b30:	ee 81       	ldd	r30, Y+6	; 0x06
    4b32:	ff 81       	ldd	r31, Y+7	; 0x07
    4b34:	90 81       	ld	r25, Z
    4b36:	80 91 6b 08 	lds	r24, 0x086B
    4b3a:	98 17       	cp	r25, r24
    4b3c:	81 f0       	breq	.+32     	; 0x4b5e <xTaskCheckForTimeOut+0x70>
    4b3e:	ee 81       	ldd	r30, Y+6	; 0x06
    4b40:	ff 81       	ldd	r31, Y+7	; 0x07
    4b42:	21 81       	ldd	r18, Z+1	; 0x01
    4b44:	32 81       	ldd	r19, Z+2	; 0x02
    4b46:	8b 81       	ldd	r24, Y+3	; 0x03
    4b48:	9c 81       	ldd	r25, Y+4	; 0x04
    4b4a:	82 17       	cp	r24, r18
    4b4c:	93 07       	cpc	r25, r19
    4b4e:	38 f0       	brcs	.+14     	; 0x4b5e <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4b50:	81 e0       	ldi	r24, 0x01	; 1
    4b52:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    4b54:	e8 85       	ldd	r30, Y+8	; 0x08
    4b56:	f9 85       	ldd	r31, Y+9	; 0x09
    4b58:	11 82       	std	Z+1, r1	; 0x01
    4b5a:	10 82       	st	Z, r1
    4b5c:	23 c0       	rjmp	.+70     	; 0x4ba4 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4b5e:	e8 85       	ldd	r30, Y+8	; 0x08
    4b60:	f9 85       	ldd	r31, Y+9	; 0x09
    4b62:	20 81       	ld	r18, Z
    4b64:	31 81       	ldd	r19, Z+1	; 0x01
    4b66:	89 81       	ldd	r24, Y+1	; 0x01
    4b68:	9a 81       	ldd	r25, Y+2	; 0x02
    4b6a:	82 17       	cp	r24, r18
    4b6c:	93 07       	cpc	r25, r19
    4b6e:	a0 f4       	brcc	.+40     	; 0x4b98 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4b70:	e8 85       	ldd	r30, Y+8	; 0x08
    4b72:	f9 85       	ldd	r31, Y+9	; 0x09
    4b74:	20 81       	ld	r18, Z
    4b76:	31 81       	ldd	r19, Z+1	; 0x01
    4b78:	89 81       	ldd	r24, Y+1	; 0x01
    4b7a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b7c:	a9 01       	movw	r20, r18
    4b7e:	48 1b       	sub	r20, r24
    4b80:	59 0b       	sbc	r21, r25
    4b82:	ca 01       	movw	r24, r20
    4b84:	e8 85       	ldd	r30, Y+8	; 0x08
    4b86:	f9 85       	ldd	r31, Y+9	; 0x09
    4b88:	91 83       	std	Z+1, r25	; 0x01
    4b8a:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    4b8c:	8e 81       	ldd	r24, Y+6	; 0x06
    4b8e:	9f 81       	ldd	r25, Y+7	; 0x07
    4b90:	0e 94 5e 25 	call	0x4abc	; 0x4abc <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4b94:	1d 82       	std	Y+5, r1	; 0x05
    4b96:	06 c0       	rjmp	.+12     	; 0x4ba4 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4b98:	e8 85       	ldd	r30, Y+8	; 0x08
    4b9a:	f9 85       	ldd	r31, Y+9	; 0x09
    4b9c:	11 82       	std	Z+1, r1	; 0x01
    4b9e:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    4ba0:	81 e0       	ldi	r24, 0x01	; 1
    4ba2:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    4ba4:	0f 90       	pop	r0
    4ba6:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4ba8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4baa:	29 96       	adiw	r28, 0x09	; 9
    4bac:	0f b6       	in	r0, 0x3f	; 63
    4bae:	f8 94       	cli
    4bb0:	de bf       	out	0x3e, r29	; 62
    4bb2:	0f be       	out	0x3f, r0	; 63
    4bb4:	cd bf       	out	0x3d, r28	; 61
    4bb6:	cf 91       	pop	r28
    4bb8:	df 91       	pop	r29
    4bba:	08 95       	ret

00004bbc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4bbc:	df 93       	push	r29
    4bbe:	cf 93       	push	r28
    4bc0:	cd b7       	in	r28, 0x3d	; 61
    4bc2:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    4bc4:	81 e0       	ldi	r24, 0x01	; 1
    4bc6:	80 93 6a 08 	sts	0x086A, r24
}
    4bca:	cf 91       	pop	r28
    4bcc:	df 91       	pop	r29
    4bce:	08 95       	ret

00004bd0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4bd0:	df 93       	push	r29
    4bd2:	cf 93       	push	r28
    4bd4:	00 d0       	rcall	.+0      	; 0x4bd6 <prvIdleTask+0x6>
    4bd6:	cd b7       	in	r28, 0x3d	; 61
    4bd8:	de b7       	in	r29, 0x3e	; 62
    4bda:	9a 83       	std	Y+2, r25	; 0x02
    4bdc:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4bde:	0e 94 35 26 	call	0x4c6a	; 0x4c6a <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4be2:	80 91 72 08 	lds	r24, 0x0872
    4be6:	82 30       	cpi	r24, 0x02	; 2
    4be8:	d0 f3       	brcs	.-12     	; 0x4bde <prvIdleTask+0xe>
                {
                    taskYIELD();
    4bea:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    4bee:	f7 cf       	rjmp	.-18     	; 0x4bde <prvIdleTask+0xe>

00004bf0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4bf0:	df 93       	push	r29
    4bf2:	cf 93       	push	r28
    4bf4:	0f 92       	push	r0
    4bf6:	cd b7       	in	r28, 0x3d	; 61
    4bf8:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4bfa:	19 82       	std	Y+1, r1	; 0x01
    4bfc:	13 c0       	rjmp	.+38     	; 0x4c24 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4bfe:	89 81       	ldd	r24, Y+1	; 0x01
    4c00:	28 2f       	mov	r18, r24
    4c02:	30 e0       	ldi	r19, 0x00	; 0
    4c04:	c9 01       	movw	r24, r18
    4c06:	88 0f       	add	r24, r24
    4c08:	99 1f       	adc	r25, r25
    4c0a:	88 0f       	add	r24, r24
    4c0c:	99 1f       	adc	r25, r25
    4c0e:	88 0f       	add	r24, r24
    4c10:	99 1f       	adc	r25, r25
    4c12:	82 0f       	add	r24, r18
    4c14:	93 1f       	adc	r25, r19
    4c16:	8e 58       	subi	r24, 0x8E	; 142
    4c18:	97 4f       	sbci	r25, 0xF7	; 247
    4c1a:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4c1e:	89 81       	ldd	r24, Y+1	; 0x01
    4c20:	8f 5f       	subi	r24, 0xFF	; 255
    4c22:	89 83       	std	Y+1, r24	; 0x01
    4c24:	89 81       	ldd	r24, Y+1	; 0x01
    4c26:	84 30       	cpi	r24, 0x04	; 4
    4c28:	50 f3       	brcs	.-44     	; 0x4bfe <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4c2a:	86 e9       	ldi	r24, 0x96	; 150
    4c2c:	98 e0       	ldi	r25, 0x08	; 8
    4c2e:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    4c32:	8f e9       	ldi	r24, 0x9F	; 159
    4c34:	98 e0       	ldi	r25, 0x08	; 8
    4c36:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4c3a:	8c ea       	ldi	r24, 0xAC	; 172
    4c3c:	98 e0       	ldi	r25, 0x08	; 8
    4c3e:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    4c42:	85 eb       	ldi	r24, 0xB5	; 181
    4c44:	98 e0       	ldi	r25, 0x08	; 8
    4c46:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4c4a:	86 e9       	ldi	r24, 0x96	; 150
    4c4c:	98 e0       	ldi	r25, 0x08	; 8
    4c4e:	90 93 a9 08 	sts	0x08A9, r25
    4c52:	80 93 a8 08 	sts	0x08A8, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4c56:	8f e9       	ldi	r24, 0x9F	; 159
    4c58:	98 e0       	ldi	r25, 0x08	; 8
    4c5a:	90 93 ab 08 	sts	0x08AB, r25
    4c5e:	80 93 aa 08 	sts	0x08AA, r24
}
    4c62:	0f 90       	pop	r0
    4c64:	cf 91       	pop	r28
    4c66:	df 91       	pop	r29
    4c68:	08 95       	ret

00004c6a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4c6a:	df 93       	push	r29
    4c6c:	cf 93       	push	r28
    4c6e:	00 d0       	rcall	.+0      	; 0x4c70 <prvCheckTasksWaitingTermination+0x6>
    4c70:	cd b7       	in	r28, 0x3d	; 61
    4c72:	de b7       	in	r29, 0x3e	; 62
    4c74:	20 c0       	rjmp	.+64     	; 0x4cb6 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    4c76:	0f b6       	in	r0, 0x3f	; 63
    4c78:	f8 94       	cli
    4c7a:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4c7c:	e0 91 ba 08 	lds	r30, 0x08BA
    4c80:	f0 91 bb 08 	lds	r31, 0x08BB
    4c84:	86 81       	ldd	r24, Z+6	; 0x06
    4c86:	97 81       	ldd	r25, Z+7	; 0x07
    4c88:	9a 83       	std	Y+2, r25	; 0x02
    4c8a:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4c8c:	89 81       	ldd	r24, Y+1	; 0x01
    4c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    4c90:	02 96       	adiw	r24, 0x02	; 2
    4c92:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>
                    --uxCurrentNumberOfTasks;
    4c96:	80 91 63 08 	lds	r24, 0x0863
    4c9a:	81 50       	subi	r24, 0x01	; 1
    4c9c:	80 93 63 08 	sts	0x0863, r24
                    --uxDeletedTasksWaitingCleanUp;
    4ca0:	80 91 62 08 	lds	r24, 0x0862
    4ca4:	81 50       	subi	r24, 0x01	; 1
    4ca6:	80 93 62 08 	sts	0x0862, r24
                }
                taskEXIT_CRITICAL();
    4caa:	0f 90       	pop	r0
    4cac:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    4cae:	89 81       	ldd	r24, Y+1	; 0x01
    4cb0:	9a 81       	ldd	r25, Y+2	; 0x02
    4cb2:	0e 94 64 26 	call	0x4cc8	; 0x4cc8 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4cb6:	80 91 62 08 	lds	r24, 0x0862
    4cba:	88 23       	and	r24, r24
    4cbc:	e1 f6       	brne	.-72     	; 0x4c76 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    4cbe:	0f 90       	pop	r0
    4cc0:	0f 90       	pop	r0
    4cc2:	cf 91       	pop	r28
    4cc4:	df 91       	pop	r29
    4cc6:	08 95       	ret

00004cc8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    4cc8:	df 93       	push	r29
    4cca:	cf 93       	push	r28
    4ccc:	00 d0       	rcall	.+0      	; 0x4cce <prvDeleteTCB+0x6>
    4cce:	cd b7       	in	r28, 0x3d	; 61
    4cd0:	de b7       	in	r29, 0x3e	; 62
    4cd2:	9a 83       	std	Y+2, r25	; 0x02
    4cd4:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    4cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    4cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    4cda:	87 89       	ldd	r24, Z+23	; 0x17
    4cdc:	90 8d       	ldd	r25, Z+24	; 0x18
    4cde:	0e 94 2d 07 	call	0xe5a	; 0xe5a <vPortFree>
                vPortFree( pxTCB );
    4ce2:	89 81       	ldd	r24, Y+1	; 0x01
    4ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ce6:	0e 94 2d 07 	call	0xe5a	; 0xe5a <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    4cea:	0f 90       	pop	r0
    4cec:	0f 90       	pop	r0
    4cee:	cf 91       	pop	r28
    4cf0:	df 91       	pop	r29
    4cf2:	08 95       	ret

00004cf4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4cf4:	df 93       	push	r29
    4cf6:	cf 93       	push	r28
    4cf8:	cd b7       	in	r28, 0x3d	; 61
    4cfa:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4cfc:	e0 91 a8 08 	lds	r30, 0x08A8
    4d00:	f0 91 a9 08 	lds	r31, 0x08A9
    4d04:	80 81       	ld	r24, Z
    4d06:	88 23       	and	r24, r24
    4d08:	39 f4       	brne	.+14     	; 0x4d18 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4d0a:	8f ef       	ldi	r24, 0xFF	; 255
    4d0c:	9f ef       	ldi	r25, 0xFF	; 255
    4d0e:	90 93 6e 08 	sts	0x086E, r25
    4d12:	80 93 6d 08 	sts	0x086D, r24
    4d16:	0d c0       	rjmp	.+26     	; 0x4d32 <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4d18:	e0 91 a8 08 	lds	r30, 0x08A8
    4d1c:	f0 91 a9 08 	lds	r31, 0x08A9
    4d20:	05 80       	ldd	r0, Z+5	; 0x05
    4d22:	f6 81       	ldd	r31, Z+6	; 0x06
    4d24:	e0 2d       	mov	r30, r0
    4d26:	80 81       	ld	r24, Z
    4d28:	91 81       	ldd	r25, Z+1	; 0x01
    4d2a:	90 93 6e 08 	sts	0x086E, r25
    4d2e:	80 93 6d 08 	sts	0x086D, r24
    }
}
    4d32:	cf 91       	pop	r28
    4d34:	df 91       	pop	r29
    4d36:	08 95       	ret

00004d38 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    4d38:	df 93       	push	r29
    4d3a:	cf 93       	push	r28
    4d3c:	0f 92       	push	r0
    4d3e:	cd b7       	in	r28, 0x3d	; 61
    4d40:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    4d42:	80 91 67 08 	lds	r24, 0x0867
    4d46:	88 23       	and	r24, r24
    4d48:	19 f4       	brne	.+6      	; 0x4d50 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    4d4a:	81 e0       	ldi	r24, 0x01	; 1
    4d4c:	89 83       	std	Y+1, r24	; 0x01
    4d4e:	08 c0       	rjmp	.+16     	; 0x4d60 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4d50:	80 91 71 08 	lds	r24, 0x0871
    4d54:	88 23       	and	r24, r24
    4d56:	19 f4       	brne	.+6      	; 0x4d5e <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    4d58:	82 e0       	ldi	r24, 0x02	; 2
    4d5a:	89 83       	std	Y+1, r24	; 0x01
    4d5c:	01 c0       	rjmp	.+2      	; 0x4d60 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    4d5e:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    4d60:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4d62:	0f 90       	pop	r0
    4d64:	cf 91       	pop	r28
    4d66:	df 91       	pop	r29
    4d68:	08 95       	ret

00004d6a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4d6a:	df 93       	push	r29
    4d6c:	cf 93       	push	r28
    4d6e:	00 d0       	rcall	.+0      	; 0x4d70 <uxTaskResetEventItemValue+0x6>
    4d70:	cd b7       	in	r28, 0x3d	; 61
    4d72:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4d74:	e0 91 60 08 	lds	r30, 0x0860
    4d78:	f0 91 61 08 	lds	r31, 0x0861
    4d7c:	84 85       	ldd	r24, Z+12	; 0x0c
    4d7e:	95 85       	ldd	r25, Z+13	; 0x0d
    4d80:	9a 83       	std	Y+2, r25	; 0x02
    4d82:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4d84:	a0 91 60 08 	lds	r26, 0x0860
    4d88:	b0 91 61 08 	lds	r27, 0x0861
    4d8c:	e0 91 60 08 	lds	r30, 0x0860
    4d90:	f0 91 61 08 	lds	r31, 0x0861
    4d94:	86 89       	ldd	r24, Z+22	; 0x16
    4d96:	28 2f       	mov	r18, r24
    4d98:	30 e0       	ldi	r19, 0x00	; 0
    4d9a:	84 e0       	ldi	r24, 0x04	; 4
    4d9c:	90 e0       	ldi	r25, 0x00	; 0
    4d9e:	82 1b       	sub	r24, r18
    4da0:	93 0b       	sbc	r25, r19
    4da2:	1d 96       	adiw	r26, 0x0d	; 13
    4da4:	9c 93       	st	X, r25
    4da6:	8e 93       	st	-X, r24
    4da8:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4daa:	89 81       	ldd	r24, Y+1	; 0x01
    4dac:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4dae:	0f 90       	pop	r0
    4db0:	0f 90       	pop	r0
    4db2:	cf 91       	pop	r28
    4db4:	df 91       	pop	r29
    4db6:	08 95       	ret

00004db8 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    4db8:	df 93       	push	r29
    4dba:	cf 93       	push	r28
    4dbc:	cd b7       	in	r28, 0x3d	; 61
    4dbe:	de b7       	in	r29, 0x3e	; 62
    4dc0:	28 97       	sbiw	r28, 0x08	; 8
    4dc2:	0f b6       	in	r0, 0x3f	; 63
    4dc4:	f8 94       	cli
    4dc6:	de bf       	out	0x3e, r29	; 62
    4dc8:	0f be       	out	0x3f, r0	; 63
    4dca:	cd bf       	out	0x3d, r28	; 61
    4dcc:	8d 83       	std	Y+5, r24	; 0x05
    4dce:	6e 83       	std	Y+6, r22	; 0x06
    4dd0:	58 87       	std	Y+8, r21	; 0x08
    4dd2:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4dd4:	0f b6       	in	r0, 0x3f	; 63
    4dd6:	f8 94       	cli
    4dd8:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4dda:	20 91 60 08 	lds	r18, 0x0860
    4dde:	30 91 61 08 	lds	r19, 0x0861
    4de2:	8d 81       	ldd	r24, Y+5	; 0x05
    4de4:	88 2f       	mov	r24, r24
    4de6:	90 e0       	ldi	r25, 0x00	; 0
    4de8:	88 0f       	add	r24, r24
    4dea:	99 1f       	adc	r25, r25
    4dec:	88 0f       	add	r24, r24
    4dee:	99 1f       	adc	r25, r25
    4df0:	82 0f       	add	r24, r18
    4df2:	93 1f       	adc	r25, r19
    4df4:	fc 01       	movw	r30, r24
    4df6:	b1 96       	adiw	r30, 0x21	; 33
    4df8:	80 81       	ld	r24, Z
    4dfa:	91 81       	ldd	r25, Z+1	; 0x01
    4dfc:	a2 81       	ldd	r26, Z+2	; 0x02
    4dfe:	b3 81       	ldd	r27, Z+3	; 0x03
    4e00:	00 97       	sbiw	r24, 0x00	; 0
    4e02:	a1 05       	cpc	r26, r1
    4e04:	b1 05       	cpc	r27, r1
    4e06:	c1 f4       	brne	.+48     	; 0x4e38 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4e08:	20 91 60 08 	lds	r18, 0x0860
    4e0c:	30 91 61 08 	lds	r19, 0x0861
    4e10:	8d 81       	ldd	r24, Y+5	; 0x05
    4e12:	88 2f       	mov	r24, r24
    4e14:	90 e0       	ldi	r25, 0x00	; 0
    4e16:	82 0f       	add	r24, r18
    4e18:	93 1f       	adc	r25, r19
    4e1a:	fc 01       	movw	r30, r24
    4e1c:	b5 96       	adiw	r30, 0x25	; 37
    4e1e:	81 e0       	ldi	r24, 0x01	; 1
    4e20:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4e22:	8f 81       	ldd	r24, Y+7	; 0x07
    4e24:	98 85       	ldd	r25, Y+8	; 0x08
    4e26:	00 97       	sbiw	r24, 0x00	; 0
    4e28:	39 f0       	breq	.+14     	; 0x4e38 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4e2a:	8f 81       	ldd	r24, Y+7	; 0x07
    4e2c:	98 85       	ldd	r25, Y+8	; 0x08
    4e2e:	61 e0       	ldi	r22, 0x01	; 1
    4e30:	0e 94 61 2e 	call	0x5cc2	; 0x5cc2 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4e34:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4e38:	0f 90       	pop	r0
    4e3a:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4e3c:	0f b6       	in	r0, 0x3f	; 63
    4e3e:	f8 94       	cli
    4e40:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4e42:	20 91 60 08 	lds	r18, 0x0860
    4e46:	30 91 61 08 	lds	r19, 0x0861
    4e4a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e4c:	88 2f       	mov	r24, r24
    4e4e:	90 e0       	ldi	r25, 0x00	; 0
    4e50:	88 0f       	add	r24, r24
    4e52:	99 1f       	adc	r25, r25
    4e54:	88 0f       	add	r24, r24
    4e56:	99 1f       	adc	r25, r25
    4e58:	82 0f       	add	r24, r18
    4e5a:	93 1f       	adc	r25, r19
    4e5c:	fc 01       	movw	r30, r24
    4e5e:	b1 96       	adiw	r30, 0x21	; 33
    4e60:	80 81       	ld	r24, Z
    4e62:	91 81       	ldd	r25, Z+1	; 0x01
    4e64:	a2 81       	ldd	r26, Z+2	; 0x02
    4e66:	b3 81       	ldd	r27, Z+3	; 0x03
    4e68:	89 83       	std	Y+1, r24	; 0x01
    4e6a:	9a 83       	std	Y+2, r25	; 0x02
    4e6c:	ab 83       	std	Y+3, r26	; 0x03
    4e6e:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4e70:	89 81       	ldd	r24, Y+1	; 0x01
    4e72:	9a 81       	ldd	r25, Y+2	; 0x02
    4e74:	ab 81       	ldd	r26, Y+3	; 0x03
    4e76:	bc 81       	ldd	r27, Y+4	; 0x04
    4e78:	00 97       	sbiw	r24, 0x00	; 0
    4e7a:	a1 05       	cpc	r26, r1
    4e7c:	b1 05       	cpc	r27, r1
    4e7e:	a9 f1       	breq	.+106    	; 0x4eea <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    4e80:	8e 81       	ldd	r24, Y+6	; 0x06
    4e82:	88 23       	and	r24, r24
    4e84:	a1 f0       	breq	.+40     	; 0x4eae <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4e86:	20 91 60 08 	lds	r18, 0x0860
    4e8a:	30 91 61 08 	lds	r19, 0x0861
    4e8e:	8d 81       	ldd	r24, Y+5	; 0x05
    4e90:	88 2f       	mov	r24, r24
    4e92:	90 e0       	ldi	r25, 0x00	; 0
    4e94:	88 0f       	add	r24, r24
    4e96:	99 1f       	adc	r25, r25
    4e98:	88 0f       	add	r24, r24
    4e9a:	99 1f       	adc	r25, r25
    4e9c:	82 0f       	add	r24, r18
    4e9e:	93 1f       	adc	r25, r19
    4ea0:	fc 01       	movw	r30, r24
    4ea2:	b1 96       	adiw	r30, 0x21	; 33
    4ea4:	10 82       	st	Z, r1
    4ea6:	11 82       	std	Z+1, r1	; 0x01
    4ea8:	12 82       	std	Z+2, r1	; 0x02
    4eaa:	13 82       	std	Z+3, r1	; 0x03
    4eac:	1e c0       	rjmp	.+60     	; 0x4eea <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4eae:	e0 91 60 08 	lds	r30, 0x0860
    4eb2:	f0 91 61 08 	lds	r31, 0x0861
    4eb6:	8d 81       	ldd	r24, Y+5	; 0x05
    4eb8:	68 2f       	mov	r22, r24
    4eba:	70 e0       	ldi	r23, 0x00	; 0
    4ebc:	89 81       	ldd	r24, Y+1	; 0x01
    4ebe:	9a 81       	ldd	r25, Y+2	; 0x02
    4ec0:	ab 81       	ldd	r26, Y+3	; 0x03
    4ec2:	bc 81       	ldd	r27, Y+4	; 0x04
    4ec4:	9c 01       	movw	r18, r24
    4ec6:	ad 01       	movw	r20, r26
    4ec8:	21 50       	subi	r18, 0x01	; 1
    4eca:	30 40       	sbci	r19, 0x00	; 0
    4ecc:	40 40       	sbci	r20, 0x00	; 0
    4ece:	50 40       	sbci	r21, 0x00	; 0
    4ed0:	cb 01       	movw	r24, r22
    4ed2:	88 0f       	add	r24, r24
    4ed4:	99 1f       	adc	r25, r25
    4ed6:	88 0f       	add	r24, r24
    4ed8:	99 1f       	adc	r25, r25
    4eda:	8e 0f       	add	r24, r30
    4edc:	9f 1f       	adc	r25, r31
    4ede:	fc 01       	movw	r30, r24
    4ee0:	b1 96       	adiw	r30, 0x21	; 33
    4ee2:	20 83       	st	Z, r18
    4ee4:	31 83       	std	Z+1, r19	; 0x01
    4ee6:	42 83       	std	Z+2, r20	; 0x02
    4ee8:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4eea:	20 91 60 08 	lds	r18, 0x0860
    4eee:	30 91 61 08 	lds	r19, 0x0861
    4ef2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ef4:	88 2f       	mov	r24, r24
    4ef6:	90 e0       	ldi	r25, 0x00	; 0
    4ef8:	82 0f       	add	r24, r18
    4efa:	93 1f       	adc	r25, r19
    4efc:	fc 01       	movw	r30, r24
    4efe:	b5 96       	adiw	r30, 0x25	; 37
    4f00:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4f02:	0f 90       	pop	r0
    4f04:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4f06:	89 81       	ldd	r24, Y+1	; 0x01
    4f08:	9a 81       	ldd	r25, Y+2	; 0x02
    4f0a:	ab 81       	ldd	r26, Y+3	; 0x03
    4f0c:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4f0e:	bc 01       	movw	r22, r24
    4f10:	cd 01       	movw	r24, r26
    4f12:	28 96       	adiw	r28, 0x08	; 8
    4f14:	0f b6       	in	r0, 0x3f	; 63
    4f16:	f8 94       	cli
    4f18:	de bf       	out	0x3e, r29	; 62
    4f1a:	0f be       	out	0x3f, r0	; 63
    4f1c:	cd bf       	out	0x3d, r28	; 61
    4f1e:	cf 91       	pop	r28
    4f20:	df 91       	pop	r29
    4f22:	08 95       	ret

00004f24 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4f24:	cf 92       	push	r12
    4f26:	df 92       	push	r13
    4f28:	ef 92       	push	r14
    4f2a:	ff 92       	push	r15
    4f2c:	0f 93       	push	r16
    4f2e:	1f 93       	push	r17
    4f30:	df 93       	push	r29
    4f32:	cf 93       	push	r28
    4f34:	cd b7       	in	r28, 0x3d	; 61
    4f36:	de b7       	in	r29, 0x3e	; 62
    4f38:	2e 97       	sbiw	r28, 0x0e	; 14
    4f3a:	0f b6       	in	r0, 0x3f	; 63
    4f3c:	f8 94       	cli
    4f3e:	de bf       	out	0x3e, r29	; 62
    4f40:	0f be       	out	0x3f, r0	; 63
    4f42:	cd bf       	out	0x3d, r28	; 61
    4f44:	8a 83       	std	Y+2, r24	; 0x02
    4f46:	4b 83       	std	Y+3, r20	; 0x03
    4f48:	5c 83       	std	Y+4, r21	; 0x04
    4f4a:	6d 83       	std	Y+5, r22	; 0x05
    4f4c:	7e 83       	std	Y+6, r23	; 0x06
    4f4e:	0f 83       	std	Y+7, r16	; 0x07
    4f50:	18 87       	std	Y+8, r17	; 0x08
    4f52:	29 87       	std	Y+9, r18	; 0x09
    4f54:	3a 87       	std	Y+10, r19	; 0x0a
    4f56:	fc 86       	std	Y+12, r15	; 0x0c
    4f58:	eb 86       	std	Y+11, r14	; 0x0b
    4f5a:	de 86       	std	Y+14, r13	; 0x0e
    4f5c:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4f5e:	0f b6       	in	r0, 0x3f	; 63
    4f60:	f8 94       	cli
    4f62:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4f64:	20 91 60 08 	lds	r18, 0x0860
    4f68:	30 91 61 08 	lds	r19, 0x0861
    4f6c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f6e:	88 2f       	mov	r24, r24
    4f70:	90 e0       	ldi	r25, 0x00	; 0
    4f72:	82 0f       	add	r24, r18
    4f74:	93 1f       	adc	r25, r19
    4f76:	fc 01       	movw	r30, r24
    4f78:	b5 96       	adiw	r30, 0x25	; 37
    4f7a:	80 81       	ld	r24, Z
    4f7c:	82 30       	cpi	r24, 0x02	; 2
    4f7e:	09 f4       	brne	.+2      	; 0x4f82 <xTaskGenericNotifyWait+0x5e>
    4f80:	47 c0       	rjmp	.+142    	; 0x5010 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    4f82:	60 91 60 08 	lds	r22, 0x0860
    4f86:	70 91 61 08 	lds	r23, 0x0861
    4f8a:	8a 81       	ldd	r24, Y+2	; 0x02
    4f8c:	08 2f       	mov	r16, r24
    4f8e:	10 e0       	ldi	r17, 0x00	; 0
    4f90:	8a 81       	ldd	r24, Y+2	; 0x02
    4f92:	88 2f       	mov	r24, r24
    4f94:	90 e0       	ldi	r25, 0x00	; 0
    4f96:	88 0f       	add	r24, r24
    4f98:	99 1f       	adc	r25, r25
    4f9a:	88 0f       	add	r24, r24
    4f9c:	99 1f       	adc	r25, r25
    4f9e:	86 0f       	add	r24, r22
    4fa0:	97 1f       	adc	r25, r23
    4fa2:	fc 01       	movw	r30, r24
    4fa4:	b1 96       	adiw	r30, 0x21	; 33
    4fa6:	20 81       	ld	r18, Z
    4fa8:	31 81       	ldd	r19, Z+1	; 0x01
    4faa:	42 81       	ldd	r20, Z+2	; 0x02
    4fac:	53 81       	ldd	r21, Z+3	; 0x03
    4fae:	8b 81       	ldd	r24, Y+3	; 0x03
    4fb0:	9c 81       	ldd	r25, Y+4	; 0x04
    4fb2:	ad 81       	ldd	r26, Y+5	; 0x05
    4fb4:	be 81       	ldd	r27, Y+6	; 0x06
    4fb6:	80 95       	com	r24
    4fb8:	90 95       	com	r25
    4fba:	a0 95       	com	r26
    4fbc:	b0 95       	com	r27
    4fbe:	28 23       	and	r18, r24
    4fc0:	39 23       	and	r19, r25
    4fc2:	4a 23       	and	r20, r26
    4fc4:	5b 23       	and	r21, r27
    4fc6:	c8 01       	movw	r24, r16
    4fc8:	88 0f       	add	r24, r24
    4fca:	99 1f       	adc	r25, r25
    4fcc:	88 0f       	add	r24, r24
    4fce:	99 1f       	adc	r25, r25
    4fd0:	86 0f       	add	r24, r22
    4fd2:	97 1f       	adc	r25, r23
    4fd4:	fc 01       	movw	r30, r24
    4fd6:	b1 96       	adiw	r30, 0x21	; 33
    4fd8:	20 83       	st	Z, r18
    4fda:	31 83       	std	Z+1, r19	; 0x01
    4fdc:	42 83       	std	Z+2, r20	; 0x02
    4fde:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4fe0:	20 91 60 08 	lds	r18, 0x0860
    4fe4:	30 91 61 08 	lds	r19, 0x0861
    4fe8:	8a 81       	ldd	r24, Y+2	; 0x02
    4fea:	88 2f       	mov	r24, r24
    4fec:	90 e0       	ldi	r25, 0x00	; 0
    4fee:	82 0f       	add	r24, r18
    4ff0:	93 1f       	adc	r25, r19
    4ff2:	fc 01       	movw	r30, r24
    4ff4:	b5 96       	adiw	r30, 0x25	; 37
    4ff6:	81 e0       	ldi	r24, 0x01	; 1
    4ff8:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4ffa:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ffc:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ffe:	00 97       	sbiw	r24, 0x00	; 0
    5000:	39 f0       	breq	.+14     	; 0x5010 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5002:	8d 85       	ldd	r24, Y+13	; 0x0d
    5004:	9e 85       	ldd	r25, Y+14	; 0x0e
    5006:	61 e0       	ldi	r22, 0x01	; 1
    5008:	0e 94 61 2e 	call	0x5cc2	; 0x5cc2 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    500c:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5010:	0f 90       	pop	r0
    5012:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5014:	0f b6       	in	r0, 0x3f	; 63
    5016:	f8 94       	cli
    5018:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    501a:	8b 85       	ldd	r24, Y+11	; 0x0b
    501c:	9c 85       	ldd	r25, Y+12	; 0x0c
    501e:	00 97       	sbiw	r24, 0x00	; 0
    5020:	c9 f0       	breq	.+50     	; 0x5054 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5022:	20 91 60 08 	lds	r18, 0x0860
    5026:	30 91 61 08 	lds	r19, 0x0861
    502a:	8a 81       	ldd	r24, Y+2	; 0x02
    502c:	88 2f       	mov	r24, r24
    502e:	90 e0       	ldi	r25, 0x00	; 0
    5030:	88 0f       	add	r24, r24
    5032:	99 1f       	adc	r25, r25
    5034:	88 0f       	add	r24, r24
    5036:	99 1f       	adc	r25, r25
    5038:	82 0f       	add	r24, r18
    503a:	93 1f       	adc	r25, r19
    503c:	fc 01       	movw	r30, r24
    503e:	b1 96       	adiw	r30, 0x21	; 33
    5040:	80 81       	ld	r24, Z
    5042:	91 81       	ldd	r25, Z+1	; 0x01
    5044:	a2 81       	ldd	r26, Z+2	; 0x02
    5046:	b3 81       	ldd	r27, Z+3	; 0x03
    5048:	eb 85       	ldd	r30, Y+11	; 0x0b
    504a:	fc 85       	ldd	r31, Y+12	; 0x0c
    504c:	80 83       	st	Z, r24
    504e:	91 83       	std	Z+1, r25	; 0x01
    5050:	a2 83       	std	Z+2, r26	; 0x02
    5052:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5054:	20 91 60 08 	lds	r18, 0x0860
    5058:	30 91 61 08 	lds	r19, 0x0861
    505c:	8a 81       	ldd	r24, Y+2	; 0x02
    505e:	88 2f       	mov	r24, r24
    5060:	90 e0       	ldi	r25, 0x00	; 0
    5062:	82 0f       	add	r24, r18
    5064:	93 1f       	adc	r25, r19
    5066:	fc 01       	movw	r30, r24
    5068:	b5 96       	adiw	r30, 0x25	; 37
    506a:	80 81       	ld	r24, Z
    506c:	82 30       	cpi	r24, 0x02	; 2
    506e:	11 f0       	breq	.+4      	; 0x5074 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    5070:	19 82       	std	Y+1, r1	; 0x01
    5072:	31 c0       	rjmp	.+98     	; 0x50d6 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5074:	60 91 60 08 	lds	r22, 0x0860
    5078:	70 91 61 08 	lds	r23, 0x0861
    507c:	8a 81       	ldd	r24, Y+2	; 0x02
    507e:	08 2f       	mov	r16, r24
    5080:	10 e0       	ldi	r17, 0x00	; 0
    5082:	8a 81       	ldd	r24, Y+2	; 0x02
    5084:	88 2f       	mov	r24, r24
    5086:	90 e0       	ldi	r25, 0x00	; 0
    5088:	88 0f       	add	r24, r24
    508a:	99 1f       	adc	r25, r25
    508c:	88 0f       	add	r24, r24
    508e:	99 1f       	adc	r25, r25
    5090:	86 0f       	add	r24, r22
    5092:	97 1f       	adc	r25, r23
    5094:	fc 01       	movw	r30, r24
    5096:	b1 96       	adiw	r30, 0x21	; 33
    5098:	20 81       	ld	r18, Z
    509a:	31 81       	ldd	r19, Z+1	; 0x01
    509c:	42 81       	ldd	r20, Z+2	; 0x02
    509e:	53 81       	ldd	r21, Z+3	; 0x03
    50a0:	8f 81       	ldd	r24, Y+7	; 0x07
    50a2:	98 85       	ldd	r25, Y+8	; 0x08
    50a4:	a9 85       	ldd	r26, Y+9	; 0x09
    50a6:	ba 85       	ldd	r27, Y+10	; 0x0a
    50a8:	80 95       	com	r24
    50aa:	90 95       	com	r25
    50ac:	a0 95       	com	r26
    50ae:	b0 95       	com	r27
    50b0:	28 23       	and	r18, r24
    50b2:	39 23       	and	r19, r25
    50b4:	4a 23       	and	r20, r26
    50b6:	5b 23       	and	r21, r27
    50b8:	c8 01       	movw	r24, r16
    50ba:	88 0f       	add	r24, r24
    50bc:	99 1f       	adc	r25, r25
    50be:	88 0f       	add	r24, r24
    50c0:	99 1f       	adc	r25, r25
    50c2:	86 0f       	add	r24, r22
    50c4:	97 1f       	adc	r25, r23
    50c6:	fc 01       	movw	r30, r24
    50c8:	b1 96       	adiw	r30, 0x21	; 33
    50ca:	20 83       	st	Z, r18
    50cc:	31 83       	std	Z+1, r19	; 0x01
    50ce:	42 83       	std	Z+2, r20	; 0x02
    50d0:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    50d2:	81 e0       	ldi	r24, 0x01	; 1
    50d4:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    50d6:	20 91 60 08 	lds	r18, 0x0860
    50da:	30 91 61 08 	lds	r19, 0x0861
    50de:	8a 81       	ldd	r24, Y+2	; 0x02
    50e0:	88 2f       	mov	r24, r24
    50e2:	90 e0       	ldi	r25, 0x00	; 0
    50e4:	82 0f       	add	r24, r18
    50e6:	93 1f       	adc	r25, r19
    50e8:	fc 01       	movw	r30, r24
    50ea:	b5 96       	adiw	r30, 0x25	; 37
    50ec:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    50ee:	0f 90       	pop	r0
    50f0:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    50f2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    50f4:	2e 96       	adiw	r28, 0x0e	; 14
    50f6:	0f b6       	in	r0, 0x3f	; 63
    50f8:	f8 94       	cli
    50fa:	de bf       	out	0x3e, r29	; 62
    50fc:	0f be       	out	0x3f, r0	; 63
    50fe:	cd bf       	out	0x3d, r28	; 61
    5100:	cf 91       	pop	r28
    5102:	df 91       	pop	r29
    5104:	1f 91       	pop	r17
    5106:	0f 91       	pop	r16
    5108:	ff 90       	pop	r15
    510a:	ef 90       	pop	r14
    510c:	df 90       	pop	r13
    510e:	cf 90       	pop	r12
    5110:	08 95       	ret

00005112 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    5112:	ef 92       	push	r14
    5114:	ff 92       	push	r15
    5116:	0f 93       	push	r16
    5118:	1f 93       	push	r17
    511a:	df 93       	push	r29
    511c:	cf 93       	push	r28
    511e:	cd b7       	in	r28, 0x3d	; 61
    5120:	de b7       	in	r29, 0x3e	; 62
    5122:	64 97       	sbiw	r28, 0x14	; 20
    5124:	0f b6       	in	r0, 0x3f	; 63
    5126:	f8 94       	cli
    5128:	de bf       	out	0x3e, r29	; 62
    512a:	0f be       	out	0x3f, r0	; 63
    512c:	cd bf       	out	0x3d, r28	; 61
    512e:	9a 87       	std	Y+10, r25	; 0x0a
    5130:	89 87       	std	Y+9, r24	; 0x09
    5132:	6b 87       	std	Y+11, r22	; 0x0b
    5134:	2c 87       	std	Y+12, r18	; 0x0c
    5136:	3d 87       	std	Y+13, r19	; 0x0d
    5138:	4e 87       	std	Y+14, r20	; 0x0e
    513a:	5f 87       	std	Y+15, r21	; 0x0f
    513c:	08 8b       	std	Y+16, r16	; 0x10
    513e:	fa 8a       	std	Y+18, r15	; 0x12
    5140:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    5142:	81 e0       	ldi	r24, 0x01	; 1
    5144:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    5146:	89 85       	ldd	r24, Y+9	; 0x09
    5148:	9a 85       	ldd	r25, Y+10	; 0x0a
    514a:	98 87       	std	Y+8, r25	; 0x08
    514c:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    514e:	0f b6       	in	r0, 0x3f	; 63
    5150:	f8 94       	cli
    5152:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    5154:	89 89       	ldd	r24, Y+17	; 0x11
    5156:	9a 89       	ldd	r25, Y+18	; 0x12
    5158:	00 97       	sbiw	r24, 0x00	; 0
    515a:	b9 f0       	breq	.+46     	; 0x518a <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    515c:	8b 85       	ldd	r24, Y+11	; 0x0b
    515e:	88 2f       	mov	r24, r24
    5160:	90 e0       	ldi	r25, 0x00	; 0
    5162:	2f 81       	ldd	r18, Y+7	; 0x07
    5164:	38 85       	ldd	r19, Y+8	; 0x08
    5166:	88 0f       	add	r24, r24
    5168:	99 1f       	adc	r25, r25
    516a:	88 0f       	add	r24, r24
    516c:	99 1f       	adc	r25, r25
    516e:	82 0f       	add	r24, r18
    5170:	93 1f       	adc	r25, r19
    5172:	fc 01       	movw	r30, r24
    5174:	b1 96       	adiw	r30, 0x21	; 33
    5176:	80 81       	ld	r24, Z
    5178:	91 81       	ldd	r25, Z+1	; 0x01
    517a:	a2 81       	ldd	r26, Z+2	; 0x02
    517c:	b3 81       	ldd	r27, Z+3	; 0x03
    517e:	e9 89       	ldd	r30, Y+17	; 0x11
    5180:	fa 89       	ldd	r31, Y+18	; 0x12
    5182:	80 83       	st	Z, r24
    5184:	91 83       	std	Z+1, r25	; 0x01
    5186:	a2 83       	std	Z+2, r26	; 0x02
    5188:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    518a:	8b 85       	ldd	r24, Y+11	; 0x0b
    518c:	28 2f       	mov	r18, r24
    518e:	30 e0       	ldi	r19, 0x00	; 0
    5190:	8f 81       	ldd	r24, Y+7	; 0x07
    5192:	98 85       	ldd	r25, Y+8	; 0x08
    5194:	82 0f       	add	r24, r18
    5196:	93 1f       	adc	r25, r19
    5198:	fc 01       	movw	r30, r24
    519a:	b5 96       	adiw	r30, 0x25	; 37
    519c:	80 81       	ld	r24, Z
    519e:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    51a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    51a2:	28 2f       	mov	r18, r24
    51a4:	30 e0       	ldi	r19, 0x00	; 0
    51a6:	8f 81       	ldd	r24, Y+7	; 0x07
    51a8:	98 85       	ldd	r25, Y+8	; 0x08
    51aa:	82 0f       	add	r24, r18
    51ac:	93 1f       	adc	r25, r19
    51ae:	fc 01       	movw	r30, r24
    51b0:	b5 96       	adiw	r30, 0x25	; 37
    51b2:	82 e0       	ldi	r24, 0x02	; 2
    51b4:	80 83       	st	Z, r24

            switch( eAction )
    51b6:	88 89       	ldd	r24, Y+16	; 0x10
    51b8:	28 2f       	mov	r18, r24
    51ba:	30 e0       	ldi	r19, 0x00	; 0
    51bc:	3c 8b       	std	Y+20, r19	; 0x14
    51be:	2b 8b       	std	Y+19, r18	; 0x13
    51c0:	8b 89       	ldd	r24, Y+19	; 0x13
    51c2:	9c 89       	ldd	r25, Y+20	; 0x14
    51c4:	82 30       	cpi	r24, 0x02	; 2
    51c6:	91 05       	cpc	r25, r1
    51c8:	09 f4       	brne	.+2      	; 0x51cc <xTaskGenericNotify+0xba>
    51ca:	46 c0       	rjmp	.+140    	; 0x5258 <xTaskGenericNotify+0x146>
    51cc:	2b 89       	ldd	r18, Y+19	; 0x13
    51ce:	3c 89       	ldd	r19, Y+20	; 0x14
    51d0:	23 30       	cpi	r18, 0x03	; 3
    51d2:	31 05       	cpc	r19, r1
    51d4:	34 f4       	brge	.+12     	; 0x51e2 <xTaskGenericNotify+0xd0>
    51d6:	8b 89       	ldd	r24, Y+19	; 0x13
    51d8:	9c 89       	ldd	r25, Y+20	; 0x14
    51da:	81 30       	cpi	r24, 0x01	; 1
    51dc:	91 05       	cpc	r25, r1
    51de:	71 f0       	breq	.+28     	; 0x51fc <xTaskGenericNotify+0xea>
    51e0:	93 c0       	rjmp	.+294    	; 0x5308 <xTaskGenericNotify+0x1f6>
    51e2:	2b 89       	ldd	r18, Y+19	; 0x13
    51e4:	3c 89       	ldd	r19, Y+20	; 0x14
    51e6:	23 30       	cpi	r18, 0x03	; 3
    51e8:	31 05       	cpc	r19, r1
    51ea:	09 f4       	brne	.+2      	; 0x51ee <xTaskGenericNotify+0xdc>
    51ec:	5d c0       	rjmp	.+186    	; 0x52a8 <xTaskGenericNotify+0x196>
    51ee:	8b 89       	ldd	r24, Y+19	; 0x13
    51f0:	9c 89       	ldd	r25, Y+20	; 0x14
    51f2:	84 30       	cpi	r24, 0x04	; 4
    51f4:	91 05       	cpc	r25, r1
    51f6:	09 f4       	brne	.+2      	; 0x51fa <xTaskGenericNotify+0xe8>
    51f8:	6d c0       	rjmp	.+218    	; 0x52d4 <xTaskGenericNotify+0x1c2>
    51fa:	86 c0       	rjmp	.+268    	; 0x5308 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    51fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    51fe:	08 2f       	mov	r16, r24
    5200:	10 e0       	ldi	r17, 0x00	; 0
    5202:	8b 85       	ldd	r24, Y+11	; 0x0b
    5204:	88 2f       	mov	r24, r24
    5206:	90 e0       	ldi	r25, 0x00	; 0
    5208:	2f 81       	ldd	r18, Y+7	; 0x07
    520a:	38 85       	ldd	r19, Y+8	; 0x08
    520c:	88 0f       	add	r24, r24
    520e:	99 1f       	adc	r25, r25
    5210:	88 0f       	add	r24, r24
    5212:	99 1f       	adc	r25, r25
    5214:	82 0f       	add	r24, r18
    5216:	93 1f       	adc	r25, r19
    5218:	fc 01       	movw	r30, r24
    521a:	b1 96       	adiw	r30, 0x21	; 33
    521c:	20 81       	ld	r18, Z
    521e:	31 81       	ldd	r19, Z+1	; 0x01
    5220:	42 81       	ldd	r20, Z+2	; 0x02
    5222:	53 81       	ldd	r21, Z+3	; 0x03
    5224:	8c 85       	ldd	r24, Y+12	; 0x0c
    5226:	9d 85       	ldd	r25, Y+13	; 0x0d
    5228:	ae 85       	ldd	r26, Y+14	; 0x0e
    522a:	bf 85       	ldd	r27, Y+15	; 0x0f
    522c:	ba 01       	movw	r22, r20
    522e:	a9 01       	movw	r20, r18
    5230:	48 2b       	or	r20, r24
    5232:	59 2b       	or	r21, r25
    5234:	6a 2b       	or	r22, r26
    5236:	7b 2b       	or	r23, r27
    5238:	2f 81       	ldd	r18, Y+7	; 0x07
    523a:	38 85       	ldd	r19, Y+8	; 0x08
    523c:	c8 01       	movw	r24, r16
    523e:	88 0f       	add	r24, r24
    5240:	99 1f       	adc	r25, r25
    5242:	88 0f       	add	r24, r24
    5244:	99 1f       	adc	r25, r25
    5246:	82 0f       	add	r24, r18
    5248:	93 1f       	adc	r25, r19
    524a:	fc 01       	movw	r30, r24
    524c:	b1 96       	adiw	r30, 0x21	; 33
    524e:	40 83       	st	Z, r20
    5250:	51 83       	std	Z+1, r21	; 0x01
    5252:	62 83       	std	Z+2, r22	; 0x02
    5254:	73 83       	std	Z+3, r23	; 0x03
    5256:	58 c0       	rjmp	.+176    	; 0x5308 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5258:	8b 85       	ldd	r24, Y+11	; 0x0b
    525a:	08 2f       	mov	r16, r24
    525c:	10 e0       	ldi	r17, 0x00	; 0
    525e:	2f 81       	ldd	r18, Y+7	; 0x07
    5260:	38 85       	ldd	r19, Y+8	; 0x08
    5262:	c8 01       	movw	r24, r16
    5264:	88 0f       	add	r24, r24
    5266:	99 1f       	adc	r25, r25
    5268:	88 0f       	add	r24, r24
    526a:	99 1f       	adc	r25, r25
    526c:	82 0f       	add	r24, r18
    526e:	93 1f       	adc	r25, r19
    5270:	fc 01       	movw	r30, r24
    5272:	b1 96       	adiw	r30, 0x21	; 33
    5274:	80 81       	ld	r24, Z
    5276:	91 81       	ldd	r25, Z+1	; 0x01
    5278:	a2 81       	ldd	r26, Z+2	; 0x02
    527a:	b3 81       	ldd	r27, Z+3	; 0x03
    527c:	ac 01       	movw	r20, r24
    527e:	bd 01       	movw	r22, r26
    5280:	4f 5f       	subi	r20, 0xFF	; 255
    5282:	5f 4f       	sbci	r21, 0xFF	; 255
    5284:	6f 4f       	sbci	r22, 0xFF	; 255
    5286:	7f 4f       	sbci	r23, 0xFF	; 255
    5288:	2f 81       	ldd	r18, Y+7	; 0x07
    528a:	38 85       	ldd	r19, Y+8	; 0x08
    528c:	c8 01       	movw	r24, r16
    528e:	88 0f       	add	r24, r24
    5290:	99 1f       	adc	r25, r25
    5292:	88 0f       	add	r24, r24
    5294:	99 1f       	adc	r25, r25
    5296:	82 0f       	add	r24, r18
    5298:	93 1f       	adc	r25, r19
    529a:	fc 01       	movw	r30, r24
    529c:	b1 96       	adiw	r30, 0x21	; 33
    529e:	40 83       	st	Z, r20
    52a0:	51 83       	std	Z+1, r21	; 0x01
    52a2:	62 83       	std	Z+2, r22	; 0x02
    52a4:	73 83       	std	Z+3, r23	; 0x03
    52a6:	30 c0       	rjmp	.+96     	; 0x5308 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    52a8:	8b 85       	ldd	r24, Y+11	; 0x0b
    52aa:	88 2f       	mov	r24, r24
    52ac:	90 e0       	ldi	r25, 0x00	; 0
    52ae:	2f 81       	ldd	r18, Y+7	; 0x07
    52b0:	38 85       	ldd	r19, Y+8	; 0x08
    52b2:	88 0f       	add	r24, r24
    52b4:	99 1f       	adc	r25, r25
    52b6:	88 0f       	add	r24, r24
    52b8:	99 1f       	adc	r25, r25
    52ba:	82 0f       	add	r24, r18
    52bc:	93 1f       	adc	r25, r19
    52be:	fc 01       	movw	r30, r24
    52c0:	b1 96       	adiw	r30, 0x21	; 33
    52c2:	8c 85       	ldd	r24, Y+12	; 0x0c
    52c4:	9d 85       	ldd	r25, Y+13	; 0x0d
    52c6:	ae 85       	ldd	r26, Y+14	; 0x0e
    52c8:	bf 85       	ldd	r27, Y+15	; 0x0f
    52ca:	80 83       	st	Z, r24
    52cc:	91 83       	std	Z+1, r25	; 0x01
    52ce:	a2 83       	std	Z+2, r26	; 0x02
    52d0:	b3 83       	std	Z+3, r27	; 0x03
    52d2:	1a c0       	rjmp	.+52     	; 0x5308 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    52d4:	8d 81       	ldd	r24, Y+5	; 0x05
    52d6:	82 30       	cpi	r24, 0x02	; 2
    52d8:	b1 f0       	breq	.+44     	; 0x5306 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    52da:	8b 85       	ldd	r24, Y+11	; 0x0b
    52dc:	88 2f       	mov	r24, r24
    52de:	90 e0       	ldi	r25, 0x00	; 0
    52e0:	2f 81       	ldd	r18, Y+7	; 0x07
    52e2:	38 85       	ldd	r19, Y+8	; 0x08
    52e4:	88 0f       	add	r24, r24
    52e6:	99 1f       	adc	r25, r25
    52e8:	88 0f       	add	r24, r24
    52ea:	99 1f       	adc	r25, r25
    52ec:	82 0f       	add	r24, r18
    52ee:	93 1f       	adc	r25, r19
    52f0:	fc 01       	movw	r30, r24
    52f2:	b1 96       	adiw	r30, 0x21	; 33
    52f4:	8c 85       	ldd	r24, Y+12	; 0x0c
    52f6:	9d 85       	ldd	r25, Y+13	; 0x0d
    52f8:	ae 85       	ldd	r26, Y+14	; 0x0e
    52fa:	bf 85       	ldd	r27, Y+15	; 0x0f
    52fc:	80 83       	st	Z, r24
    52fe:	91 83       	std	Z+1, r25	; 0x01
    5300:	a2 83       	std	Z+2, r26	; 0x02
    5302:	b3 83       	std	Z+3, r27	; 0x03
    5304:	01 c0       	rjmp	.+2      	; 0x5308 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    5306:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5308:	8d 81       	ldd	r24, Y+5	; 0x05
    530a:	81 30       	cpi	r24, 0x01	; 1
    530c:	09 f0       	breq	.+2      	; 0x5310 <xTaskGenericNotify+0x1fe>
    530e:	af c0       	rjmp	.+350    	; 0x546e <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5310:	ef 81       	ldd	r30, Y+7	; 0x07
    5312:	f8 85       	ldd	r31, Y+8	; 0x08
    5314:	82 85       	ldd	r24, Z+10	; 0x0a
    5316:	93 85       	ldd	r25, Z+11	; 0x0b
    5318:	9c 83       	std	Y+4, r25	; 0x04
    531a:	8b 83       	std	Y+3, r24	; 0x03
    531c:	ef 81       	ldd	r30, Y+7	; 0x07
    531e:	f8 85       	ldd	r31, Y+8	; 0x08
    5320:	a4 81       	ldd	r26, Z+4	; 0x04
    5322:	b5 81       	ldd	r27, Z+5	; 0x05
    5324:	ef 81       	ldd	r30, Y+7	; 0x07
    5326:	f8 85       	ldd	r31, Y+8	; 0x08
    5328:	86 81       	ldd	r24, Z+6	; 0x06
    532a:	97 81       	ldd	r25, Z+7	; 0x07
    532c:	15 96       	adiw	r26, 0x05	; 5
    532e:	9c 93       	st	X, r25
    5330:	8e 93       	st	-X, r24
    5332:	14 97       	sbiw	r26, 0x04	; 4
    5334:	ef 81       	ldd	r30, Y+7	; 0x07
    5336:	f8 85       	ldd	r31, Y+8	; 0x08
    5338:	a6 81       	ldd	r26, Z+6	; 0x06
    533a:	b7 81       	ldd	r27, Z+7	; 0x07
    533c:	ef 81       	ldd	r30, Y+7	; 0x07
    533e:	f8 85       	ldd	r31, Y+8	; 0x08
    5340:	84 81       	ldd	r24, Z+4	; 0x04
    5342:	95 81       	ldd	r25, Z+5	; 0x05
    5344:	13 96       	adiw	r26, 0x03	; 3
    5346:	9c 93       	st	X, r25
    5348:	8e 93       	st	-X, r24
    534a:	12 97       	sbiw	r26, 0x02	; 2
    534c:	eb 81       	ldd	r30, Y+3	; 0x03
    534e:	fc 81       	ldd	r31, Y+4	; 0x04
    5350:	21 81       	ldd	r18, Z+1	; 0x01
    5352:	32 81       	ldd	r19, Z+2	; 0x02
    5354:	8f 81       	ldd	r24, Y+7	; 0x07
    5356:	98 85       	ldd	r25, Y+8	; 0x08
    5358:	02 96       	adiw	r24, 0x02	; 2
    535a:	28 17       	cp	r18, r24
    535c:	39 07       	cpc	r19, r25
    535e:	41 f4       	brne	.+16     	; 0x5370 <xTaskGenericNotify+0x25e>
    5360:	ef 81       	ldd	r30, Y+7	; 0x07
    5362:	f8 85       	ldd	r31, Y+8	; 0x08
    5364:	86 81       	ldd	r24, Z+6	; 0x06
    5366:	97 81       	ldd	r25, Z+7	; 0x07
    5368:	eb 81       	ldd	r30, Y+3	; 0x03
    536a:	fc 81       	ldd	r31, Y+4	; 0x04
    536c:	92 83       	std	Z+2, r25	; 0x02
    536e:	81 83       	std	Z+1, r24	; 0x01
    5370:	ef 81       	ldd	r30, Y+7	; 0x07
    5372:	f8 85       	ldd	r31, Y+8	; 0x08
    5374:	13 86       	std	Z+11, r1	; 0x0b
    5376:	12 86       	std	Z+10, r1	; 0x0a
    5378:	eb 81       	ldd	r30, Y+3	; 0x03
    537a:	fc 81       	ldd	r31, Y+4	; 0x04
    537c:	80 81       	ld	r24, Z
    537e:	81 50       	subi	r24, 0x01	; 1
    5380:	eb 81       	ldd	r30, Y+3	; 0x03
    5382:	fc 81       	ldd	r31, Y+4	; 0x04
    5384:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    5386:	ef 81       	ldd	r30, Y+7	; 0x07
    5388:	f8 85       	ldd	r31, Y+8	; 0x08
    538a:	96 89       	ldd	r25, Z+22	; 0x16
    538c:	80 91 66 08 	lds	r24, 0x0866
    5390:	89 17       	cp	r24, r25
    5392:	28 f4       	brcc	.+10     	; 0x539e <xTaskGenericNotify+0x28c>
    5394:	ef 81       	ldd	r30, Y+7	; 0x07
    5396:	f8 85       	ldd	r31, Y+8	; 0x08
    5398:	86 89       	ldd	r24, Z+22	; 0x16
    539a:	80 93 66 08 	sts	0x0866, r24
    539e:	ef 81       	ldd	r30, Y+7	; 0x07
    53a0:	f8 85       	ldd	r31, Y+8	; 0x08
    53a2:	86 89       	ldd	r24, Z+22	; 0x16
    53a4:	28 2f       	mov	r18, r24
    53a6:	30 e0       	ldi	r19, 0x00	; 0
    53a8:	c9 01       	movw	r24, r18
    53aa:	88 0f       	add	r24, r24
    53ac:	99 1f       	adc	r25, r25
    53ae:	88 0f       	add	r24, r24
    53b0:	99 1f       	adc	r25, r25
    53b2:	88 0f       	add	r24, r24
    53b4:	99 1f       	adc	r25, r25
    53b6:	82 0f       	add	r24, r18
    53b8:	93 1f       	adc	r25, r19
    53ba:	fc 01       	movw	r30, r24
    53bc:	ee 58       	subi	r30, 0x8E	; 142
    53be:	f7 4f       	sbci	r31, 0xF7	; 247
    53c0:	81 81       	ldd	r24, Z+1	; 0x01
    53c2:	92 81       	ldd	r25, Z+2	; 0x02
    53c4:	9a 83       	std	Y+2, r25	; 0x02
    53c6:	89 83       	std	Y+1, r24	; 0x01
    53c8:	ef 81       	ldd	r30, Y+7	; 0x07
    53ca:	f8 85       	ldd	r31, Y+8	; 0x08
    53cc:	89 81       	ldd	r24, Y+1	; 0x01
    53ce:	9a 81       	ldd	r25, Y+2	; 0x02
    53d0:	95 83       	std	Z+5, r25	; 0x05
    53d2:	84 83       	std	Z+4, r24	; 0x04
    53d4:	e9 81       	ldd	r30, Y+1	; 0x01
    53d6:	fa 81       	ldd	r31, Y+2	; 0x02
    53d8:	84 81       	ldd	r24, Z+4	; 0x04
    53da:	95 81       	ldd	r25, Z+5	; 0x05
    53dc:	ef 81       	ldd	r30, Y+7	; 0x07
    53de:	f8 85       	ldd	r31, Y+8	; 0x08
    53e0:	97 83       	std	Z+7, r25	; 0x07
    53e2:	86 83       	std	Z+6, r24	; 0x06
    53e4:	e9 81       	ldd	r30, Y+1	; 0x01
    53e6:	fa 81       	ldd	r31, Y+2	; 0x02
    53e8:	04 80       	ldd	r0, Z+4	; 0x04
    53ea:	f5 81       	ldd	r31, Z+5	; 0x05
    53ec:	e0 2d       	mov	r30, r0
    53ee:	8f 81       	ldd	r24, Y+7	; 0x07
    53f0:	98 85       	ldd	r25, Y+8	; 0x08
    53f2:	02 96       	adiw	r24, 0x02	; 2
    53f4:	93 83       	std	Z+3, r25	; 0x03
    53f6:	82 83       	std	Z+2, r24	; 0x02
    53f8:	8f 81       	ldd	r24, Y+7	; 0x07
    53fa:	98 85       	ldd	r25, Y+8	; 0x08
    53fc:	02 96       	adiw	r24, 0x02	; 2
    53fe:	e9 81       	ldd	r30, Y+1	; 0x01
    5400:	fa 81       	ldd	r31, Y+2	; 0x02
    5402:	95 83       	std	Z+5, r25	; 0x05
    5404:	84 83       	std	Z+4, r24	; 0x04
    5406:	ef 81       	ldd	r30, Y+7	; 0x07
    5408:	f8 85       	ldd	r31, Y+8	; 0x08
    540a:	86 89       	ldd	r24, Z+22	; 0x16
    540c:	28 2f       	mov	r18, r24
    540e:	30 e0       	ldi	r19, 0x00	; 0
    5410:	c9 01       	movw	r24, r18
    5412:	88 0f       	add	r24, r24
    5414:	99 1f       	adc	r25, r25
    5416:	88 0f       	add	r24, r24
    5418:	99 1f       	adc	r25, r25
    541a:	88 0f       	add	r24, r24
    541c:	99 1f       	adc	r25, r25
    541e:	82 0f       	add	r24, r18
    5420:	93 1f       	adc	r25, r19
    5422:	8e 58       	subi	r24, 0x8E	; 142
    5424:	97 4f       	sbci	r25, 0xF7	; 247
    5426:	ef 81       	ldd	r30, Y+7	; 0x07
    5428:	f8 85       	ldd	r31, Y+8	; 0x08
    542a:	93 87       	std	Z+11, r25	; 0x0b
    542c:	82 87       	std	Z+10, r24	; 0x0a
    542e:	ef 81       	ldd	r30, Y+7	; 0x07
    5430:	f8 85       	ldd	r31, Y+8	; 0x08
    5432:	86 89       	ldd	r24, Z+22	; 0x16
    5434:	28 2f       	mov	r18, r24
    5436:	30 e0       	ldi	r19, 0x00	; 0
    5438:	c9 01       	movw	r24, r18
    543a:	88 0f       	add	r24, r24
    543c:	99 1f       	adc	r25, r25
    543e:	88 0f       	add	r24, r24
    5440:	99 1f       	adc	r25, r25
    5442:	88 0f       	add	r24, r24
    5444:	99 1f       	adc	r25, r25
    5446:	82 0f       	add	r24, r18
    5448:	93 1f       	adc	r25, r19
    544a:	fc 01       	movw	r30, r24
    544c:	ee 58       	subi	r30, 0x8E	; 142
    544e:	f7 4f       	sbci	r31, 0xF7	; 247
    5450:	80 81       	ld	r24, Z
    5452:	8f 5f       	subi	r24, 0xFF	; 255
    5454:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5456:	ef 81       	ldd	r30, Y+7	; 0x07
    5458:	f8 85       	ldd	r31, Y+8	; 0x08
    545a:	96 89       	ldd	r25, Z+22	; 0x16
    545c:	e0 91 60 08 	lds	r30, 0x0860
    5460:	f0 91 61 08 	lds	r31, 0x0861
    5464:	86 89       	ldd	r24, Z+22	; 0x16
    5466:	89 17       	cp	r24, r25
    5468:	10 f4       	brcc	.+4      	; 0x546e <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    546a:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    546e:	0f 90       	pop	r0
    5470:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5472:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    5474:	64 96       	adiw	r28, 0x14	; 20
    5476:	0f b6       	in	r0, 0x3f	; 63
    5478:	f8 94       	cli
    547a:	de bf       	out	0x3e, r29	; 62
    547c:	0f be       	out	0x3f, r0	; 63
    547e:	cd bf       	out	0x3d, r28	; 61
    5480:	cf 91       	pop	r28
    5482:	df 91       	pop	r29
    5484:	1f 91       	pop	r17
    5486:	0f 91       	pop	r16
    5488:	ff 90       	pop	r15
    548a:	ef 90       	pop	r14
    548c:	08 95       	ret

0000548e <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    548e:	cf 92       	push	r12
    5490:	df 92       	push	r13
    5492:	ef 92       	push	r14
    5494:	ff 92       	push	r15
    5496:	0f 93       	push	r16
    5498:	1f 93       	push	r17
    549a:	df 93       	push	r29
    549c:	cf 93       	push	r28
    549e:	cd b7       	in	r28, 0x3d	; 61
    54a0:	de b7       	in	r29, 0x3e	; 62
    54a2:	69 97       	sbiw	r28, 0x19	; 25
    54a4:	0f b6       	in	r0, 0x3f	; 63
    54a6:	f8 94       	cli
    54a8:	de bf       	out	0x3e, r29	; 62
    54aa:	0f be       	out	0x3f, r0	; 63
    54ac:	cd bf       	out	0x3d, r28	; 61
    54ae:	9d 87       	std	Y+13, r25	; 0x0d
    54b0:	8c 87       	std	Y+12, r24	; 0x0c
    54b2:	6e 87       	std	Y+14, r22	; 0x0e
    54b4:	2f 87       	std	Y+15, r18	; 0x0f
    54b6:	38 8b       	std	Y+16, r19	; 0x10
    54b8:	49 8b       	std	Y+17, r20	; 0x11
    54ba:	5a 8b       	std	Y+18, r21	; 0x12
    54bc:	0b 8b       	std	Y+19, r16	; 0x13
    54be:	fd 8a       	std	Y+21, r15	; 0x15
    54c0:	ec 8a       	std	Y+20, r14	; 0x14
    54c2:	df 8a       	std	Y+23, r13	; 0x17
    54c4:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    54c6:	81 e0       	ldi	r24, 0x01	; 1
    54c8:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    54ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    54cc:	9d 85       	ldd	r25, Y+13	; 0x0d
    54ce:	9b 87       	std	Y+11, r25	; 0x0b
    54d0:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    54d2:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    54d4:	8c 89       	ldd	r24, Y+20	; 0x14
    54d6:	9d 89       	ldd	r25, Y+21	; 0x15
    54d8:	00 97       	sbiw	r24, 0x00	; 0
    54da:	b9 f0       	breq	.+46     	; 0x550a <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    54dc:	8e 85       	ldd	r24, Y+14	; 0x0e
    54de:	88 2f       	mov	r24, r24
    54e0:	90 e0       	ldi	r25, 0x00	; 0
    54e2:	2a 85       	ldd	r18, Y+10	; 0x0a
    54e4:	3b 85       	ldd	r19, Y+11	; 0x0b
    54e6:	88 0f       	add	r24, r24
    54e8:	99 1f       	adc	r25, r25
    54ea:	88 0f       	add	r24, r24
    54ec:	99 1f       	adc	r25, r25
    54ee:	82 0f       	add	r24, r18
    54f0:	93 1f       	adc	r25, r19
    54f2:	fc 01       	movw	r30, r24
    54f4:	b1 96       	adiw	r30, 0x21	; 33
    54f6:	80 81       	ld	r24, Z
    54f8:	91 81       	ldd	r25, Z+1	; 0x01
    54fa:	a2 81       	ldd	r26, Z+2	; 0x02
    54fc:	b3 81       	ldd	r27, Z+3	; 0x03
    54fe:	ec 89       	ldd	r30, Y+20	; 0x14
    5500:	fd 89       	ldd	r31, Y+21	; 0x15
    5502:	80 83       	st	Z, r24
    5504:	91 83       	std	Z+1, r25	; 0x01
    5506:	a2 83       	std	Z+2, r26	; 0x02
    5508:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    550a:	8e 85       	ldd	r24, Y+14	; 0x0e
    550c:	28 2f       	mov	r18, r24
    550e:	30 e0       	ldi	r19, 0x00	; 0
    5510:	8a 85       	ldd	r24, Y+10	; 0x0a
    5512:	9b 85       	ldd	r25, Y+11	; 0x0b
    5514:	82 0f       	add	r24, r18
    5516:	93 1f       	adc	r25, r19
    5518:	fc 01       	movw	r30, r24
    551a:	b5 96       	adiw	r30, 0x25	; 37
    551c:	80 81       	ld	r24, Z
    551e:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5520:	8e 85       	ldd	r24, Y+14	; 0x0e
    5522:	28 2f       	mov	r18, r24
    5524:	30 e0       	ldi	r19, 0x00	; 0
    5526:	8a 85       	ldd	r24, Y+10	; 0x0a
    5528:	9b 85       	ldd	r25, Y+11	; 0x0b
    552a:	82 0f       	add	r24, r18
    552c:	93 1f       	adc	r25, r19
    552e:	fc 01       	movw	r30, r24
    5530:	b5 96       	adiw	r30, 0x25	; 37
    5532:	82 e0       	ldi	r24, 0x02	; 2
    5534:	80 83       	st	Z, r24

            switch( eAction )
    5536:	8b 89       	ldd	r24, Y+19	; 0x13
    5538:	28 2f       	mov	r18, r24
    553a:	30 e0       	ldi	r19, 0x00	; 0
    553c:	39 8f       	std	Y+25, r19	; 0x19
    553e:	28 8f       	std	Y+24, r18	; 0x18
    5540:	88 8d       	ldd	r24, Y+24	; 0x18
    5542:	99 8d       	ldd	r25, Y+25	; 0x19
    5544:	82 30       	cpi	r24, 0x02	; 2
    5546:	91 05       	cpc	r25, r1
    5548:	09 f4       	brne	.+2      	; 0x554c <xTaskGenericNotifyFromISR+0xbe>
    554a:	46 c0       	rjmp	.+140    	; 0x55d8 <xTaskGenericNotifyFromISR+0x14a>
    554c:	28 8d       	ldd	r18, Y+24	; 0x18
    554e:	39 8d       	ldd	r19, Y+25	; 0x19
    5550:	23 30       	cpi	r18, 0x03	; 3
    5552:	31 05       	cpc	r19, r1
    5554:	34 f4       	brge	.+12     	; 0x5562 <xTaskGenericNotifyFromISR+0xd4>
    5556:	88 8d       	ldd	r24, Y+24	; 0x18
    5558:	99 8d       	ldd	r25, Y+25	; 0x19
    555a:	81 30       	cpi	r24, 0x01	; 1
    555c:	91 05       	cpc	r25, r1
    555e:	71 f0       	breq	.+28     	; 0x557c <xTaskGenericNotifyFromISR+0xee>
    5560:	93 c0       	rjmp	.+294    	; 0x5688 <xTaskGenericNotifyFromISR+0x1fa>
    5562:	28 8d       	ldd	r18, Y+24	; 0x18
    5564:	39 8d       	ldd	r19, Y+25	; 0x19
    5566:	23 30       	cpi	r18, 0x03	; 3
    5568:	31 05       	cpc	r19, r1
    556a:	09 f4       	brne	.+2      	; 0x556e <xTaskGenericNotifyFromISR+0xe0>
    556c:	5d c0       	rjmp	.+186    	; 0x5628 <xTaskGenericNotifyFromISR+0x19a>
    556e:	88 8d       	ldd	r24, Y+24	; 0x18
    5570:	99 8d       	ldd	r25, Y+25	; 0x19
    5572:	84 30       	cpi	r24, 0x04	; 4
    5574:	91 05       	cpc	r25, r1
    5576:	09 f4       	brne	.+2      	; 0x557a <xTaskGenericNotifyFromISR+0xec>
    5578:	6d c0       	rjmp	.+218    	; 0x5654 <xTaskGenericNotifyFromISR+0x1c6>
    557a:	86 c0       	rjmp	.+268    	; 0x5688 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    557c:	8e 85       	ldd	r24, Y+14	; 0x0e
    557e:	08 2f       	mov	r16, r24
    5580:	10 e0       	ldi	r17, 0x00	; 0
    5582:	8e 85       	ldd	r24, Y+14	; 0x0e
    5584:	88 2f       	mov	r24, r24
    5586:	90 e0       	ldi	r25, 0x00	; 0
    5588:	2a 85       	ldd	r18, Y+10	; 0x0a
    558a:	3b 85       	ldd	r19, Y+11	; 0x0b
    558c:	88 0f       	add	r24, r24
    558e:	99 1f       	adc	r25, r25
    5590:	88 0f       	add	r24, r24
    5592:	99 1f       	adc	r25, r25
    5594:	82 0f       	add	r24, r18
    5596:	93 1f       	adc	r25, r19
    5598:	fc 01       	movw	r30, r24
    559a:	b1 96       	adiw	r30, 0x21	; 33
    559c:	20 81       	ld	r18, Z
    559e:	31 81       	ldd	r19, Z+1	; 0x01
    55a0:	42 81       	ldd	r20, Z+2	; 0x02
    55a2:	53 81       	ldd	r21, Z+3	; 0x03
    55a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    55a6:	98 89       	ldd	r25, Y+16	; 0x10
    55a8:	a9 89       	ldd	r26, Y+17	; 0x11
    55aa:	ba 89       	ldd	r27, Y+18	; 0x12
    55ac:	ba 01       	movw	r22, r20
    55ae:	a9 01       	movw	r20, r18
    55b0:	48 2b       	or	r20, r24
    55b2:	59 2b       	or	r21, r25
    55b4:	6a 2b       	or	r22, r26
    55b6:	7b 2b       	or	r23, r27
    55b8:	2a 85       	ldd	r18, Y+10	; 0x0a
    55ba:	3b 85       	ldd	r19, Y+11	; 0x0b
    55bc:	c8 01       	movw	r24, r16
    55be:	88 0f       	add	r24, r24
    55c0:	99 1f       	adc	r25, r25
    55c2:	88 0f       	add	r24, r24
    55c4:	99 1f       	adc	r25, r25
    55c6:	82 0f       	add	r24, r18
    55c8:	93 1f       	adc	r25, r19
    55ca:	fc 01       	movw	r30, r24
    55cc:	b1 96       	adiw	r30, 0x21	; 33
    55ce:	40 83       	st	Z, r20
    55d0:	51 83       	std	Z+1, r21	; 0x01
    55d2:	62 83       	std	Z+2, r22	; 0x02
    55d4:	73 83       	std	Z+3, r23	; 0x03
    55d6:	58 c0       	rjmp	.+176    	; 0x5688 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    55d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    55da:	08 2f       	mov	r16, r24
    55dc:	10 e0       	ldi	r17, 0x00	; 0
    55de:	2a 85       	ldd	r18, Y+10	; 0x0a
    55e0:	3b 85       	ldd	r19, Y+11	; 0x0b
    55e2:	c8 01       	movw	r24, r16
    55e4:	88 0f       	add	r24, r24
    55e6:	99 1f       	adc	r25, r25
    55e8:	88 0f       	add	r24, r24
    55ea:	99 1f       	adc	r25, r25
    55ec:	82 0f       	add	r24, r18
    55ee:	93 1f       	adc	r25, r19
    55f0:	fc 01       	movw	r30, r24
    55f2:	b1 96       	adiw	r30, 0x21	; 33
    55f4:	80 81       	ld	r24, Z
    55f6:	91 81       	ldd	r25, Z+1	; 0x01
    55f8:	a2 81       	ldd	r26, Z+2	; 0x02
    55fa:	b3 81       	ldd	r27, Z+3	; 0x03
    55fc:	ac 01       	movw	r20, r24
    55fe:	bd 01       	movw	r22, r26
    5600:	4f 5f       	subi	r20, 0xFF	; 255
    5602:	5f 4f       	sbci	r21, 0xFF	; 255
    5604:	6f 4f       	sbci	r22, 0xFF	; 255
    5606:	7f 4f       	sbci	r23, 0xFF	; 255
    5608:	2a 85       	ldd	r18, Y+10	; 0x0a
    560a:	3b 85       	ldd	r19, Y+11	; 0x0b
    560c:	c8 01       	movw	r24, r16
    560e:	88 0f       	add	r24, r24
    5610:	99 1f       	adc	r25, r25
    5612:	88 0f       	add	r24, r24
    5614:	99 1f       	adc	r25, r25
    5616:	82 0f       	add	r24, r18
    5618:	93 1f       	adc	r25, r19
    561a:	fc 01       	movw	r30, r24
    561c:	b1 96       	adiw	r30, 0x21	; 33
    561e:	40 83       	st	Z, r20
    5620:	51 83       	std	Z+1, r21	; 0x01
    5622:	62 83       	std	Z+2, r22	; 0x02
    5624:	73 83       	std	Z+3, r23	; 0x03
    5626:	30 c0       	rjmp	.+96     	; 0x5688 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5628:	8e 85       	ldd	r24, Y+14	; 0x0e
    562a:	88 2f       	mov	r24, r24
    562c:	90 e0       	ldi	r25, 0x00	; 0
    562e:	2a 85       	ldd	r18, Y+10	; 0x0a
    5630:	3b 85       	ldd	r19, Y+11	; 0x0b
    5632:	88 0f       	add	r24, r24
    5634:	99 1f       	adc	r25, r25
    5636:	88 0f       	add	r24, r24
    5638:	99 1f       	adc	r25, r25
    563a:	82 0f       	add	r24, r18
    563c:	93 1f       	adc	r25, r19
    563e:	fc 01       	movw	r30, r24
    5640:	b1 96       	adiw	r30, 0x21	; 33
    5642:	8f 85       	ldd	r24, Y+15	; 0x0f
    5644:	98 89       	ldd	r25, Y+16	; 0x10
    5646:	a9 89       	ldd	r26, Y+17	; 0x11
    5648:	ba 89       	ldd	r27, Y+18	; 0x12
    564a:	80 83       	st	Z, r24
    564c:	91 83       	std	Z+1, r25	; 0x01
    564e:	a2 83       	std	Z+2, r26	; 0x02
    5650:	b3 83       	std	Z+3, r27	; 0x03
    5652:	1a c0       	rjmp	.+52     	; 0x5688 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5654:	89 85       	ldd	r24, Y+9	; 0x09
    5656:	82 30       	cpi	r24, 0x02	; 2
    5658:	b1 f0       	breq	.+44     	; 0x5686 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    565a:	8e 85       	ldd	r24, Y+14	; 0x0e
    565c:	88 2f       	mov	r24, r24
    565e:	90 e0       	ldi	r25, 0x00	; 0
    5660:	2a 85       	ldd	r18, Y+10	; 0x0a
    5662:	3b 85       	ldd	r19, Y+11	; 0x0b
    5664:	88 0f       	add	r24, r24
    5666:	99 1f       	adc	r25, r25
    5668:	88 0f       	add	r24, r24
    566a:	99 1f       	adc	r25, r25
    566c:	82 0f       	add	r24, r18
    566e:	93 1f       	adc	r25, r19
    5670:	fc 01       	movw	r30, r24
    5672:	b1 96       	adiw	r30, 0x21	; 33
    5674:	8f 85       	ldd	r24, Y+15	; 0x0f
    5676:	98 89       	ldd	r25, Y+16	; 0x10
    5678:	a9 89       	ldd	r26, Y+17	; 0x11
    567a:	ba 89       	ldd	r27, Y+18	; 0x12
    567c:	80 83       	st	Z, r24
    567e:	91 83       	std	Z+1, r25	; 0x01
    5680:	a2 83       	std	Z+2, r26	; 0x02
    5682:	b3 83       	std	Z+3, r27	; 0x03
    5684:	01 c0       	rjmp	.+2      	; 0x5688 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    5686:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5688:	89 85       	ldd	r24, Y+9	; 0x09
    568a:	81 30       	cpi	r24, 0x01	; 1
    568c:	09 f0       	breq	.+2      	; 0x5690 <xTaskGenericNotifyFromISR+0x202>
    568e:	ee c0       	rjmp	.+476    	; 0x586c <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5690:	80 91 71 08 	lds	r24, 0x0871
    5694:	88 23       	and	r24, r24
    5696:	09 f0       	breq	.+2      	; 0x569a <xTaskGenericNotifyFromISR+0x20c>
    5698:	a4 c0       	rjmp	.+328    	; 0x57e2 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    569a:	ea 85       	ldd	r30, Y+10	; 0x0a
    569c:	fb 85       	ldd	r31, Y+11	; 0x0b
    569e:	82 85       	ldd	r24, Z+10	; 0x0a
    56a0:	93 85       	ldd	r25, Z+11	; 0x0b
    56a2:	9e 83       	std	Y+6, r25	; 0x06
    56a4:	8d 83       	std	Y+5, r24	; 0x05
    56a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    56a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    56aa:	a4 81       	ldd	r26, Z+4	; 0x04
    56ac:	b5 81       	ldd	r27, Z+5	; 0x05
    56ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    56b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    56b2:	86 81       	ldd	r24, Z+6	; 0x06
    56b4:	97 81       	ldd	r25, Z+7	; 0x07
    56b6:	15 96       	adiw	r26, 0x05	; 5
    56b8:	9c 93       	st	X, r25
    56ba:	8e 93       	st	-X, r24
    56bc:	14 97       	sbiw	r26, 0x04	; 4
    56be:	ea 85       	ldd	r30, Y+10	; 0x0a
    56c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    56c2:	a6 81       	ldd	r26, Z+6	; 0x06
    56c4:	b7 81       	ldd	r27, Z+7	; 0x07
    56c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    56c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    56ca:	84 81       	ldd	r24, Z+4	; 0x04
    56cc:	95 81       	ldd	r25, Z+5	; 0x05
    56ce:	13 96       	adiw	r26, 0x03	; 3
    56d0:	9c 93       	st	X, r25
    56d2:	8e 93       	st	-X, r24
    56d4:	12 97       	sbiw	r26, 0x02	; 2
    56d6:	ed 81       	ldd	r30, Y+5	; 0x05
    56d8:	fe 81       	ldd	r31, Y+6	; 0x06
    56da:	21 81       	ldd	r18, Z+1	; 0x01
    56dc:	32 81       	ldd	r19, Z+2	; 0x02
    56de:	8a 85       	ldd	r24, Y+10	; 0x0a
    56e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    56e2:	02 96       	adiw	r24, 0x02	; 2
    56e4:	28 17       	cp	r18, r24
    56e6:	39 07       	cpc	r19, r25
    56e8:	41 f4       	brne	.+16     	; 0x56fa <xTaskGenericNotifyFromISR+0x26c>
    56ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    56ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    56ee:	86 81       	ldd	r24, Z+6	; 0x06
    56f0:	97 81       	ldd	r25, Z+7	; 0x07
    56f2:	ed 81       	ldd	r30, Y+5	; 0x05
    56f4:	fe 81       	ldd	r31, Y+6	; 0x06
    56f6:	92 83       	std	Z+2, r25	; 0x02
    56f8:	81 83       	std	Z+1, r24	; 0x01
    56fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    56fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    56fe:	13 86       	std	Z+11, r1	; 0x0b
    5700:	12 86       	std	Z+10, r1	; 0x0a
    5702:	ed 81       	ldd	r30, Y+5	; 0x05
    5704:	fe 81       	ldd	r31, Y+6	; 0x06
    5706:	80 81       	ld	r24, Z
    5708:	81 50       	subi	r24, 0x01	; 1
    570a:	ed 81       	ldd	r30, Y+5	; 0x05
    570c:	fe 81       	ldd	r31, Y+6	; 0x06
    570e:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5710:	ea 85       	ldd	r30, Y+10	; 0x0a
    5712:	fb 85       	ldd	r31, Y+11	; 0x0b
    5714:	96 89       	ldd	r25, Z+22	; 0x16
    5716:	80 91 66 08 	lds	r24, 0x0866
    571a:	89 17       	cp	r24, r25
    571c:	28 f4       	brcc	.+10     	; 0x5728 <xTaskGenericNotifyFromISR+0x29a>
    571e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5720:	fb 85       	ldd	r31, Y+11	; 0x0b
    5722:	86 89       	ldd	r24, Z+22	; 0x16
    5724:	80 93 66 08 	sts	0x0866, r24
    5728:	ea 85       	ldd	r30, Y+10	; 0x0a
    572a:	fb 85       	ldd	r31, Y+11	; 0x0b
    572c:	86 89       	ldd	r24, Z+22	; 0x16
    572e:	28 2f       	mov	r18, r24
    5730:	30 e0       	ldi	r19, 0x00	; 0
    5732:	c9 01       	movw	r24, r18
    5734:	88 0f       	add	r24, r24
    5736:	99 1f       	adc	r25, r25
    5738:	88 0f       	add	r24, r24
    573a:	99 1f       	adc	r25, r25
    573c:	88 0f       	add	r24, r24
    573e:	99 1f       	adc	r25, r25
    5740:	82 0f       	add	r24, r18
    5742:	93 1f       	adc	r25, r19
    5744:	fc 01       	movw	r30, r24
    5746:	ee 58       	subi	r30, 0x8E	; 142
    5748:	f7 4f       	sbci	r31, 0xF7	; 247
    574a:	81 81       	ldd	r24, Z+1	; 0x01
    574c:	92 81       	ldd	r25, Z+2	; 0x02
    574e:	9c 83       	std	Y+4, r25	; 0x04
    5750:	8b 83       	std	Y+3, r24	; 0x03
    5752:	ea 85       	ldd	r30, Y+10	; 0x0a
    5754:	fb 85       	ldd	r31, Y+11	; 0x0b
    5756:	8b 81       	ldd	r24, Y+3	; 0x03
    5758:	9c 81       	ldd	r25, Y+4	; 0x04
    575a:	95 83       	std	Z+5, r25	; 0x05
    575c:	84 83       	std	Z+4, r24	; 0x04
    575e:	eb 81       	ldd	r30, Y+3	; 0x03
    5760:	fc 81       	ldd	r31, Y+4	; 0x04
    5762:	84 81       	ldd	r24, Z+4	; 0x04
    5764:	95 81       	ldd	r25, Z+5	; 0x05
    5766:	ea 85       	ldd	r30, Y+10	; 0x0a
    5768:	fb 85       	ldd	r31, Y+11	; 0x0b
    576a:	97 83       	std	Z+7, r25	; 0x07
    576c:	86 83       	std	Z+6, r24	; 0x06
    576e:	eb 81       	ldd	r30, Y+3	; 0x03
    5770:	fc 81       	ldd	r31, Y+4	; 0x04
    5772:	04 80       	ldd	r0, Z+4	; 0x04
    5774:	f5 81       	ldd	r31, Z+5	; 0x05
    5776:	e0 2d       	mov	r30, r0
    5778:	8a 85       	ldd	r24, Y+10	; 0x0a
    577a:	9b 85       	ldd	r25, Y+11	; 0x0b
    577c:	02 96       	adiw	r24, 0x02	; 2
    577e:	93 83       	std	Z+3, r25	; 0x03
    5780:	82 83       	std	Z+2, r24	; 0x02
    5782:	8a 85       	ldd	r24, Y+10	; 0x0a
    5784:	9b 85       	ldd	r25, Y+11	; 0x0b
    5786:	02 96       	adiw	r24, 0x02	; 2
    5788:	eb 81       	ldd	r30, Y+3	; 0x03
    578a:	fc 81       	ldd	r31, Y+4	; 0x04
    578c:	95 83       	std	Z+5, r25	; 0x05
    578e:	84 83       	std	Z+4, r24	; 0x04
    5790:	ea 85       	ldd	r30, Y+10	; 0x0a
    5792:	fb 85       	ldd	r31, Y+11	; 0x0b
    5794:	86 89       	ldd	r24, Z+22	; 0x16
    5796:	28 2f       	mov	r18, r24
    5798:	30 e0       	ldi	r19, 0x00	; 0
    579a:	c9 01       	movw	r24, r18
    579c:	88 0f       	add	r24, r24
    579e:	99 1f       	adc	r25, r25
    57a0:	88 0f       	add	r24, r24
    57a2:	99 1f       	adc	r25, r25
    57a4:	88 0f       	add	r24, r24
    57a6:	99 1f       	adc	r25, r25
    57a8:	82 0f       	add	r24, r18
    57aa:	93 1f       	adc	r25, r19
    57ac:	8e 58       	subi	r24, 0x8E	; 142
    57ae:	97 4f       	sbci	r25, 0xF7	; 247
    57b0:	ea 85       	ldd	r30, Y+10	; 0x0a
    57b2:	fb 85       	ldd	r31, Y+11	; 0x0b
    57b4:	93 87       	std	Z+11, r25	; 0x0b
    57b6:	82 87       	std	Z+10, r24	; 0x0a
    57b8:	ea 85       	ldd	r30, Y+10	; 0x0a
    57ba:	fb 85       	ldd	r31, Y+11	; 0x0b
    57bc:	86 89       	ldd	r24, Z+22	; 0x16
    57be:	28 2f       	mov	r18, r24
    57c0:	30 e0       	ldi	r19, 0x00	; 0
    57c2:	c9 01       	movw	r24, r18
    57c4:	88 0f       	add	r24, r24
    57c6:	99 1f       	adc	r25, r25
    57c8:	88 0f       	add	r24, r24
    57ca:	99 1f       	adc	r25, r25
    57cc:	88 0f       	add	r24, r24
    57ce:	99 1f       	adc	r25, r25
    57d0:	82 0f       	add	r24, r18
    57d2:	93 1f       	adc	r25, r19
    57d4:	fc 01       	movw	r30, r24
    57d6:	ee 58       	subi	r30, 0x8E	; 142
    57d8:	f7 4f       	sbci	r31, 0xF7	; 247
    57da:	80 81       	ld	r24, Z
    57dc:	8f 5f       	subi	r24, 0xFF	; 255
    57de:	80 83       	st	Z, r24
    57e0:	30 c0       	rjmp	.+96     	; 0x5842 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    57e2:	80 91 ad 08 	lds	r24, 0x08AD
    57e6:	90 91 ae 08 	lds	r25, 0x08AE
    57ea:	9a 83       	std	Y+2, r25	; 0x02
    57ec:	89 83       	std	Y+1, r24	; 0x01
    57ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    57f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    57f2:	89 81       	ldd	r24, Y+1	; 0x01
    57f4:	9a 81       	ldd	r25, Y+2	; 0x02
    57f6:	97 87       	std	Z+15, r25	; 0x0f
    57f8:	86 87       	std	Z+14, r24	; 0x0e
    57fa:	e9 81       	ldd	r30, Y+1	; 0x01
    57fc:	fa 81       	ldd	r31, Y+2	; 0x02
    57fe:	84 81       	ldd	r24, Z+4	; 0x04
    5800:	95 81       	ldd	r25, Z+5	; 0x05
    5802:	ea 85       	ldd	r30, Y+10	; 0x0a
    5804:	fb 85       	ldd	r31, Y+11	; 0x0b
    5806:	91 8b       	std	Z+17, r25	; 0x11
    5808:	80 8b       	std	Z+16, r24	; 0x10
    580a:	e9 81       	ldd	r30, Y+1	; 0x01
    580c:	fa 81       	ldd	r31, Y+2	; 0x02
    580e:	04 80       	ldd	r0, Z+4	; 0x04
    5810:	f5 81       	ldd	r31, Z+5	; 0x05
    5812:	e0 2d       	mov	r30, r0
    5814:	8a 85       	ldd	r24, Y+10	; 0x0a
    5816:	9b 85       	ldd	r25, Y+11	; 0x0b
    5818:	0c 96       	adiw	r24, 0x0c	; 12
    581a:	93 83       	std	Z+3, r25	; 0x03
    581c:	82 83       	std	Z+2, r24	; 0x02
    581e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5820:	9b 85       	ldd	r25, Y+11	; 0x0b
    5822:	0c 96       	adiw	r24, 0x0c	; 12
    5824:	e9 81       	ldd	r30, Y+1	; 0x01
    5826:	fa 81       	ldd	r31, Y+2	; 0x02
    5828:	95 83       	std	Z+5, r25	; 0x05
    582a:	84 83       	std	Z+4, r24	; 0x04
    582c:	ea 85       	ldd	r30, Y+10	; 0x0a
    582e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5830:	8c ea       	ldi	r24, 0xAC	; 172
    5832:	98 e0       	ldi	r25, 0x08	; 8
    5834:	95 8b       	std	Z+21, r25	; 0x15
    5836:	84 8b       	std	Z+20, r24	; 0x14
    5838:	80 91 ac 08 	lds	r24, 0x08AC
    583c:	8f 5f       	subi	r24, 0xFF	; 255
    583e:	80 93 ac 08 	sts	0x08AC, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5842:	ea 85       	ldd	r30, Y+10	; 0x0a
    5844:	fb 85       	ldd	r31, Y+11	; 0x0b
    5846:	96 89       	ldd	r25, Z+22	; 0x16
    5848:	e0 91 60 08 	lds	r30, 0x0860
    584c:	f0 91 61 08 	lds	r31, 0x0861
    5850:	86 89       	ldd	r24, Z+22	; 0x16
    5852:	89 17       	cp	r24, r25
    5854:	58 f4       	brcc	.+22     	; 0x586c <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5856:	8e 89       	ldd	r24, Y+22	; 0x16
    5858:	9f 89       	ldd	r25, Y+23	; 0x17
    585a:	00 97       	sbiw	r24, 0x00	; 0
    585c:	21 f0       	breq	.+8      	; 0x5866 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    585e:	ee 89       	ldd	r30, Y+22	; 0x16
    5860:	ff 89       	ldd	r31, Y+23	; 0x17
    5862:	81 e0       	ldi	r24, 0x01	; 1
    5864:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5866:	81 e0       	ldi	r24, 0x01	; 1
    5868:	80 93 6a 08 	sts	0x086A, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    586c:	88 85       	ldd	r24, Y+8	; 0x08
    }
    586e:	69 96       	adiw	r28, 0x19	; 25
    5870:	0f b6       	in	r0, 0x3f	; 63
    5872:	f8 94       	cli
    5874:	de bf       	out	0x3e, r29	; 62
    5876:	0f be       	out	0x3f, r0	; 63
    5878:	cd bf       	out	0x3d, r28	; 61
    587a:	cf 91       	pop	r28
    587c:	df 91       	pop	r29
    587e:	1f 91       	pop	r17
    5880:	0f 91       	pop	r16
    5882:	ff 90       	pop	r15
    5884:	ef 90       	pop	r14
    5886:	df 90       	pop	r13
    5888:	cf 90       	pop	r12
    588a:	08 95       	ret

0000588c <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    588c:	0f 93       	push	r16
    588e:	1f 93       	push	r17
    5890:	df 93       	push	r29
    5892:	cf 93       	push	r28
    5894:	cd b7       	in	r28, 0x3d	; 61
    5896:	de b7       	in	r29, 0x3e	; 62
    5898:	2f 97       	sbiw	r28, 0x0f	; 15
    589a:	0f b6       	in	r0, 0x3f	; 63
    589c:	f8 94       	cli
    589e:	de bf       	out	0x3e, r29	; 62
    58a0:	0f be       	out	0x3f, r0	; 63
    58a2:	cd bf       	out	0x3d, r28	; 61
    58a4:	9c 87       	std	Y+12, r25	; 0x0c
    58a6:	8b 87       	std	Y+11, r24	; 0x0b
    58a8:	6d 87       	std	Y+13, r22	; 0x0d
    58aa:	5f 87       	std	Y+15, r21	; 0x0f
    58ac:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    58ae:	8b 85       	ldd	r24, Y+11	; 0x0b
    58b0:	9c 85       	ldd	r25, Y+12	; 0x0c
    58b2:	9a 87       	std	Y+10, r25	; 0x0a
    58b4:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    58b6:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    58b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    58ba:	28 2f       	mov	r18, r24
    58bc:	30 e0       	ldi	r19, 0x00	; 0
    58be:	89 85       	ldd	r24, Y+9	; 0x09
    58c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    58c2:	82 0f       	add	r24, r18
    58c4:	93 1f       	adc	r25, r19
    58c6:	fc 01       	movw	r30, r24
    58c8:	b5 96       	adiw	r30, 0x25	; 37
    58ca:	80 81       	ld	r24, Z
    58cc:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    58ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    58d0:	28 2f       	mov	r18, r24
    58d2:	30 e0       	ldi	r19, 0x00	; 0
    58d4:	89 85       	ldd	r24, Y+9	; 0x09
    58d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    58d8:	82 0f       	add	r24, r18
    58da:	93 1f       	adc	r25, r19
    58dc:	fc 01       	movw	r30, r24
    58de:	b5 96       	adiw	r30, 0x25	; 37
    58e0:	82 e0       	ldi	r24, 0x02	; 2
    58e2:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    58e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    58e6:	08 2f       	mov	r16, r24
    58e8:	10 e0       	ldi	r17, 0x00	; 0
    58ea:	29 85       	ldd	r18, Y+9	; 0x09
    58ec:	3a 85       	ldd	r19, Y+10	; 0x0a
    58ee:	c8 01       	movw	r24, r16
    58f0:	88 0f       	add	r24, r24
    58f2:	99 1f       	adc	r25, r25
    58f4:	88 0f       	add	r24, r24
    58f6:	99 1f       	adc	r25, r25
    58f8:	82 0f       	add	r24, r18
    58fa:	93 1f       	adc	r25, r19
    58fc:	fc 01       	movw	r30, r24
    58fe:	b1 96       	adiw	r30, 0x21	; 33
    5900:	80 81       	ld	r24, Z
    5902:	91 81       	ldd	r25, Z+1	; 0x01
    5904:	a2 81       	ldd	r26, Z+2	; 0x02
    5906:	b3 81       	ldd	r27, Z+3	; 0x03
    5908:	ac 01       	movw	r20, r24
    590a:	bd 01       	movw	r22, r26
    590c:	4f 5f       	subi	r20, 0xFF	; 255
    590e:	5f 4f       	sbci	r21, 0xFF	; 255
    5910:	6f 4f       	sbci	r22, 0xFF	; 255
    5912:	7f 4f       	sbci	r23, 0xFF	; 255
    5914:	29 85       	ldd	r18, Y+9	; 0x09
    5916:	3a 85       	ldd	r19, Y+10	; 0x0a
    5918:	c8 01       	movw	r24, r16
    591a:	88 0f       	add	r24, r24
    591c:	99 1f       	adc	r25, r25
    591e:	88 0f       	add	r24, r24
    5920:	99 1f       	adc	r25, r25
    5922:	82 0f       	add	r24, r18
    5924:	93 1f       	adc	r25, r19
    5926:	fc 01       	movw	r30, r24
    5928:	b1 96       	adiw	r30, 0x21	; 33
    592a:	40 83       	st	Z, r20
    592c:	51 83       	std	Z+1, r21	; 0x01
    592e:	62 83       	std	Z+2, r22	; 0x02
    5930:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5932:	88 85       	ldd	r24, Y+8	; 0x08
    5934:	81 30       	cpi	r24, 0x01	; 1
    5936:	09 f0       	breq	.+2      	; 0x593a <vTaskGenericNotifyGiveFromISR+0xae>
    5938:	ee c0       	rjmp	.+476    	; 0x5b16 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    593a:	80 91 71 08 	lds	r24, 0x0871
    593e:	88 23       	and	r24, r24
    5940:	09 f0       	breq	.+2      	; 0x5944 <vTaskGenericNotifyGiveFromISR+0xb8>
    5942:	a4 c0       	rjmp	.+328    	; 0x5a8c <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5944:	e9 85       	ldd	r30, Y+9	; 0x09
    5946:	fa 85       	ldd	r31, Y+10	; 0x0a
    5948:	82 85       	ldd	r24, Z+10	; 0x0a
    594a:	93 85       	ldd	r25, Z+11	; 0x0b
    594c:	9e 83       	std	Y+6, r25	; 0x06
    594e:	8d 83       	std	Y+5, r24	; 0x05
    5950:	e9 85       	ldd	r30, Y+9	; 0x09
    5952:	fa 85       	ldd	r31, Y+10	; 0x0a
    5954:	a4 81       	ldd	r26, Z+4	; 0x04
    5956:	b5 81       	ldd	r27, Z+5	; 0x05
    5958:	e9 85       	ldd	r30, Y+9	; 0x09
    595a:	fa 85       	ldd	r31, Y+10	; 0x0a
    595c:	86 81       	ldd	r24, Z+6	; 0x06
    595e:	97 81       	ldd	r25, Z+7	; 0x07
    5960:	15 96       	adiw	r26, 0x05	; 5
    5962:	9c 93       	st	X, r25
    5964:	8e 93       	st	-X, r24
    5966:	14 97       	sbiw	r26, 0x04	; 4
    5968:	e9 85       	ldd	r30, Y+9	; 0x09
    596a:	fa 85       	ldd	r31, Y+10	; 0x0a
    596c:	a6 81       	ldd	r26, Z+6	; 0x06
    596e:	b7 81       	ldd	r27, Z+7	; 0x07
    5970:	e9 85       	ldd	r30, Y+9	; 0x09
    5972:	fa 85       	ldd	r31, Y+10	; 0x0a
    5974:	84 81       	ldd	r24, Z+4	; 0x04
    5976:	95 81       	ldd	r25, Z+5	; 0x05
    5978:	13 96       	adiw	r26, 0x03	; 3
    597a:	9c 93       	st	X, r25
    597c:	8e 93       	st	-X, r24
    597e:	12 97       	sbiw	r26, 0x02	; 2
    5980:	ed 81       	ldd	r30, Y+5	; 0x05
    5982:	fe 81       	ldd	r31, Y+6	; 0x06
    5984:	21 81       	ldd	r18, Z+1	; 0x01
    5986:	32 81       	ldd	r19, Z+2	; 0x02
    5988:	89 85       	ldd	r24, Y+9	; 0x09
    598a:	9a 85       	ldd	r25, Y+10	; 0x0a
    598c:	02 96       	adiw	r24, 0x02	; 2
    598e:	28 17       	cp	r18, r24
    5990:	39 07       	cpc	r19, r25
    5992:	41 f4       	brne	.+16     	; 0x59a4 <vTaskGenericNotifyGiveFromISR+0x118>
    5994:	e9 85       	ldd	r30, Y+9	; 0x09
    5996:	fa 85       	ldd	r31, Y+10	; 0x0a
    5998:	86 81       	ldd	r24, Z+6	; 0x06
    599a:	97 81       	ldd	r25, Z+7	; 0x07
    599c:	ed 81       	ldd	r30, Y+5	; 0x05
    599e:	fe 81       	ldd	r31, Y+6	; 0x06
    59a0:	92 83       	std	Z+2, r25	; 0x02
    59a2:	81 83       	std	Z+1, r24	; 0x01
    59a4:	e9 85       	ldd	r30, Y+9	; 0x09
    59a6:	fa 85       	ldd	r31, Y+10	; 0x0a
    59a8:	13 86       	std	Z+11, r1	; 0x0b
    59aa:	12 86       	std	Z+10, r1	; 0x0a
    59ac:	ed 81       	ldd	r30, Y+5	; 0x05
    59ae:	fe 81       	ldd	r31, Y+6	; 0x06
    59b0:	80 81       	ld	r24, Z
    59b2:	81 50       	subi	r24, 0x01	; 1
    59b4:	ed 81       	ldd	r30, Y+5	; 0x05
    59b6:	fe 81       	ldd	r31, Y+6	; 0x06
    59b8:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    59ba:	e9 85       	ldd	r30, Y+9	; 0x09
    59bc:	fa 85       	ldd	r31, Y+10	; 0x0a
    59be:	96 89       	ldd	r25, Z+22	; 0x16
    59c0:	80 91 66 08 	lds	r24, 0x0866
    59c4:	89 17       	cp	r24, r25
    59c6:	28 f4       	brcc	.+10     	; 0x59d2 <vTaskGenericNotifyGiveFromISR+0x146>
    59c8:	e9 85       	ldd	r30, Y+9	; 0x09
    59ca:	fa 85       	ldd	r31, Y+10	; 0x0a
    59cc:	86 89       	ldd	r24, Z+22	; 0x16
    59ce:	80 93 66 08 	sts	0x0866, r24
    59d2:	e9 85       	ldd	r30, Y+9	; 0x09
    59d4:	fa 85       	ldd	r31, Y+10	; 0x0a
    59d6:	86 89       	ldd	r24, Z+22	; 0x16
    59d8:	28 2f       	mov	r18, r24
    59da:	30 e0       	ldi	r19, 0x00	; 0
    59dc:	c9 01       	movw	r24, r18
    59de:	88 0f       	add	r24, r24
    59e0:	99 1f       	adc	r25, r25
    59e2:	88 0f       	add	r24, r24
    59e4:	99 1f       	adc	r25, r25
    59e6:	88 0f       	add	r24, r24
    59e8:	99 1f       	adc	r25, r25
    59ea:	82 0f       	add	r24, r18
    59ec:	93 1f       	adc	r25, r19
    59ee:	fc 01       	movw	r30, r24
    59f0:	ee 58       	subi	r30, 0x8E	; 142
    59f2:	f7 4f       	sbci	r31, 0xF7	; 247
    59f4:	81 81       	ldd	r24, Z+1	; 0x01
    59f6:	92 81       	ldd	r25, Z+2	; 0x02
    59f8:	9c 83       	std	Y+4, r25	; 0x04
    59fa:	8b 83       	std	Y+3, r24	; 0x03
    59fc:	e9 85       	ldd	r30, Y+9	; 0x09
    59fe:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a00:	8b 81       	ldd	r24, Y+3	; 0x03
    5a02:	9c 81       	ldd	r25, Y+4	; 0x04
    5a04:	95 83       	std	Z+5, r25	; 0x05
    5a06:	84 83       	std	Z+4, r24	; 0x04
    5a08:	eb 81       	ldd	r30, Y+3	; 0x03
    5a0a:	fc 81       	ldd	r31, Y+4	; 0x04
    5a0c:	84 81       	ldd	r24, Z+4	; 0x04
    5a0e:	95 81       	ldd	r25, Z+5	; 0x05
    5a10:	e9 85       	ldd	r30, Y+9	; 0x09
    5a12:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a14:	97 83       	std	Z+7, r25	; 0x07
    5a16:	86 83       	std	Z+6, r24	; 0x06
    5a18:	eb 81       	ldd	r30, Y+3	; 0x03
    5a1a:	fc 81       	ldd	r31, Y+4	; 0x04
    5a1c:	04 80       	ldd	r0, Z+4	; 0x04
    5a1e:	f5 81       	ldd	r31, Z+5	; 0x05
    5a20:	e0 2d       	mov	r30, r0
    5a22:	89 85       	ldd	r24, Y+9	; 0x09
    5a24:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a26:	02 96       	adiw	r24, 0x02	; 2
    5a28:	93 83       	std	Z+3, r25	; 0x03
    5a2a:	82 83       	std	Z+2, r24	; 0x02
    5a2c:	89 85       	ldd	r24, Y+9	; 0x09
    5a2e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a30:	02 96       	adiw	r24, 0x02	; 2
    5a32:	eb 81       	ldd	r30, Y+3	; 0x03
    5a34:	fc 81       	ldd	r31, Y+4	; 0x04
    5a36:	95 83       	std	Z+5, r25	; 0x05
    5a38:	84 83       	std	Z+4, r24	; 0x04
    5a3a:	e9 85       	ldd	r30, Y+9	; 0x09
    5a3c:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a3e:	86 89       	ldd	r24, Z+22	; 0x16
    5a40:	28 2f       	mov	r18, r24
    5a42:	30 e0       	ldi	r19, 0x00	; 0
    5a44:	c9 01       	movw	r24, r18
    5a46:	88 0f       	add	r24, r24
    5a48:	99 1f       	adc	r25, r25
    5a4a:	88 0f       	add	r24, r24
    5a4c:	99 1f       	adc	r25, r25
    5a4e:	88 0f       	add	r24, r24
    5a50:	99 1f       	adc	r25, r25
    5a52:	82 0f       	add	r24, r18
    5a54:	93 1f       	adc	r25, r19
    5a56:	8e 58       	subi	r24, 0x8E	; 142
    5a58:	97 4f       	sbci	r25, 0xF7	; 247
    5a5a:	e9 85       	ldd	r30, Y+9	; 0x09
    5a5c:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a5e:	93 87       	std	Z+11, r25	; 0x0b
    5a60:	82 87       	std	Z+10, r24	; 0x0a
    5a62:	e9 85       	ldd	r30, Y+9	; 0x09
    5a64:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a66:	86 89       	ldd	r24, Z+22	; 0x16
    5a68:	28 2f       	mov	r18, r24
    5a6a:	30 e0       	ldi	r19, 0x00	; 0
    5a6c:	c9 01       	movw	r24, r18
    5a6e:	88 0f       	add	r24, r24
    5a70:	99 1f       	adc	r25, r25
    5a72:	88 0f       	add	r24, r24
    5a74:	99 1f       	adc	r25, r25
    5a76:	88 0f       	add	r24, r24
    5a78:	99 1f       	adc	r25, r25
    5a7a:	82 0f       	add	r24, r18
    5a7c:	93 1f       	adc	r25, r19
    5a7e:	fc 01       	movw	r30, r24
    5a80:	ee 58       	subi	r30, 0x8E	; 142
    5a82:	f7 4f       	sbci	r31, 0xF7	; 247
    5a84:	80 81       	ld	r24, Z
    5a86:	8f 5f       	subi	r24, 0xFF	; 255
    5a88:	80 83       	st	Z, r24
    5a8a:	30 c0       	rjmp	.+96     	; 0x5aec <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5a8c:	80 91 ad 08 	lds	r24, 0x08AD
    5a90:	90 91 ae 08 	lds	r25, 0x08AE
    5a94:	9a 83       	std	Y+2, r25	; 0x02
    5a96:	89 83       	std	Y+1, r24	; 0x01
    5a98:	e9 85       	ldd	r30, Y+9	; 0x09
    5a9a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a9c:	89 81       	ldd	r24, Y+1	; 0x01
    5a9e:	9a 81       	ldd	r25, Y+2	; 0x02
    5aa0:	97 87       	std	Z+15, r25	; 0x0f
    5aa2:	86 87       	std	Z+14, r24	; 0x0e
    5aa4:	e9 81       	ldd	r30, Y+1	; 0x01
    5aa6:	fa 81       	ldd	r31, Y+2	; 0x02
    5aa8:	84 81       	ldd	r24, Z+4	; 0x04
    5aaa:	95 81       	ldd	r25, Z+5	; 0x05
    5aac:	e9 85       	ldd	r30, Y+9	; 0x09
    5aae:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ab0:	91 8b       	std	Z+17, r25	; 0x11
    5ab2:	80 8b       	std	Z+16, r24	; 0x10
    5ab4:	e9 81       	ldd	r30, Y+1	; 0x01
    5ab6:	fa 81       	ldd	r31, Y+2	; 0x02
    5ab8:	04 80       	ldd	r0, Z+4	; 0x04
    5aba:	f5 81       	ldd	r31, Z+5	; 0x05
    5abc:	e0 2d       	mov	r30, r0
    5abe:	89 85       	ldd	r24, Y+9	; 0x09
    5ac0:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ac2:	0c 96       	adiw	r24, 0x0c	; 12
    5ac4:	93 83       	std	Z+3, r25	; 0x03
    5ac6:	82 83       	std	Z+2, r24	; 0x02
    5ac8:	89 85       	ldd	r24, Y+9	; 0x09
    5aca:	9a 85       	ldd	r25, Y+10	; 0x0a
    5acc:	0c 96       	adiw	r24, 0x0c	; 12
    5ace:	e9 81       	ldd	r30, Y+1	; 0x01
    5ad0:	fa 81       	ldd	r31, Y+2	; 0x02
    5ad2:	95 83       	std	Z+5, r25	; 0x05
    5ad4:	84 83       	std	Z+4, r24	; 0x04
    5ad6:	e9 85       	ldd	r30, Y+9	; 0x09
    5ad8:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ada:	8c ea       	ldi	r24, 0xAC	; 172
    5adc:	98 e0       	ldi	r25, 0x08	; 8
    5ade:	95 8b       	std	Z+21, r25	; 0x15
    5ae0:	84 8b       	std	Z+20, r24	; 0x14
    5ae2:	80 91 ac 08 	lds	r24, 0x08AC
    5ae6:	8f 5f       	subi	r24, 0xFF	; 255
    5ae8:	80 93 ac 08 	sts	0x08AC, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5aec:	e9 85       	ldd	r30, Y+9	; 0x09
    5aee:	fa 85       	ldd	r31, Y+10	; 0x0a
    5af0:	96 89       	ldd	r25, Z+22	; 0x16
    5af2:	e0 91 60 08 	lds	r30, 0x0860
    5af6:	f0 91 61 08 	lds	r31, 0x0861
    5afa:	86 89       	ldd	r24, Z+22	; 0x16
    5afc:	89 17       	cp	r24, r25
    5afe:	58 f4       	brcc	.+22     	; 0x5b16 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5b00:	8e 85       	ldd	r24, Y+14	; 0x0e
    5b02:	9f 85       	ldd	r25, Y+15	; 0x0f
    5b04:	00 97       	sbiw	r24, 0x00	; 0
    5b06:	21 f0       	breq	.+8      	; 0x5b10 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5b08:	ee 85       	ldd	r30, Y+14	; 0x0e
    5b0a:	ff 85       	ldd	r31, Y+15	; 0x0f
    5b0c:	81 e0       	ldi	r24, 0x01	; 1
    5b0e:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5b10:	81 e0       	ldi	r24, 0x01	; 1
    5b12:	80 93 6a 08 	sts	0x086A, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5b16:	2f 96       	adiw	r28, 0x0f	; 15
    5b18:	0f b6       	in	r0, 0x3f	; 63
    5b1a:	f8 94       	cli
    5b1c:	de bf       	out	0x3e, r29	; 62
    5b1e:	0f be       	out	0x3f, r0	; 63
    5b20:	cd bf       	out	0x3d, r28	; 61
    5b22:	cf 91       	pop	r28
    5b24:	df 91       	pop	r29
    5b26:	1f 91       	pop	r17
    5b28:	0f 91       	pop	r16
    5b2a:	08 95       	ret

00005b2c <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5b2c:	df 93       	push	r29
    5b2e:	cf 93       	push	r28
    5b30:	cd b7       	in	r28, 0x3d	; 61
    5b32:	de b7       	in	r29, 0x3e	; 62
    5b34:	28 97       	sbiw	r28, 0x08	; 8
    5b36:	0f b6       	in	r0, 0x3f	; 63
    5b38:	f8 94       	cli
    5b3a:	de bf       	out	0x3e, r29	; 62
    5b3c:	0f be       	out	0x3f, r0	; 63
    5b3e:	cd bf       	out	0x3d, r28	; 61
    5b40:	9d 83       	std	Y+5, r25	; 0x05
    5b42:	8c 83       	std	Y+4, r24	; 0x04
    5b44:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5b46:	8c 81       	ldd	r24, Y+4	; 0x04
    5b48:	9d 81       	ldd	r25, Y+5	; 0x05
    5b4a:	00 97       	sbiw	r24, 0x00	; 0
    5b4c:	39 f4       	brne	.+14     	; 0x5b5c <xTaskGenericNotifyStateClear+0x30>
    5b4e:	80 91 60 08 	lds	r24, 0x0860
    5b52:	90 91 61 08 	lds	r25, 0x0861
    5b56:	98 87       	std	Y+8, r25	; 0x08
    5b58:	8f 83       	std	Y+7, r24	; 0x07
    5b5a:	04 c0       	rjmp	.+8      	; 0x5b64 <xTaskGenericNotifyStateClear+0x38>
    5b5c:	8c 81       	ldd	r24, Y+4	; 0x04
    5b5e:	9d 81       	ldd	r25, Y+5	; 0x05
    5b60:	98 87       	std	Y+8, r25	; 0x08
    5b62:	8f 83       	std	Y+7, r24	; 0x07
    5b64:	8f 81       	ldd	r24, Y+7	; 0x07
    5b66:	98 85       	ldd	r25, Y+8	; 0x08
    5b68:	9b 83       	std	Y+3, r25	; 0x03
    5b6a:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5b6c:	0f b6       	in	r0, 0x3f	; 63
    5b6e:	f8 94       	cli
    5b70:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    5b72:	8e 81       	ldd	r24, Y+6	; 0x06
    5b74:	28 2f       	mov	r18, r24
    5b76:	30 e0       	ldi	r19, 0x00	; 0
    5b78:	8a 81       	ldd	r24, Y+2	; 0x02
    5b7a:	9b 81       	ldd	r25, Y+3	; 0x03
    5b7c:	82 0f       	add	r24, r18
    5b7e:	93 1f       	adc	r25, r19
    5b80:	fc 01       	movw	r30, r24
    5b82:	b5 96       	adiw	r30, 0x25	; 37
    5b84:	80 81       	ld	r24, Z
    5b86:	82 30       	cpi	r24, 0x02	; 2
    5b88:	69 f4       	brne	.+26     	; 0x5ba4 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5b8a:	8e 81       	ldd	r24, Y+6	; 0x06
    5b8c:	28 2f       	mov	r18, r24
    5b8e:	30 e0       	ldi	r19, 0x00	; 0
    5b90:	8a 81       	ldd	r24, Y+2	; 0x02
    5b92:	9b 81       	ldd	r25, Y+3	; 0x03
    5b94:	82 0f       	add	r24, r18
    5b96:	93 1f       	adc	r25, r19
    5b98:	fc 01       	movw	r30, r24
    5b9a:	b5 96       	adiw	r30, 0x25	; 37
    5b9c:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5b9e:	81 e0       	ldi	r24, 0x01	; 1
    5ba0:	89 83       	std	Y+1, r24	; 0x01
    5ba2:	01 c0       	rjmp	.+2      	; 0x5ba6 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    5ba4:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5ba6:	0f 90       	pop	r0
    5ba8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5baa:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5bac:	28 96       	adiw	r28, 0x08	; 8
    5bae:	0f b6       	in	r0, 0x3f	; 63
    5bb0:	f8 94       	cli
    5bb2:	de bf       	out	0x3e, r29	; 62
    5bb4:	0f be       	out	0x3f, r0	; 63
    5bb6:	cd bf       	out	0x3d, r28	; 61
    5bb8:	cf 91       	pop	r28
    5bba:	df 91       	pop	r29
    5bbc:	08 95       	ret

00005bbe <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5bbe:	0f 93       	push	r16
    5bc0:	1f 93       	push	r17
    5bc2:	df 93       	push	r29
    5bc4:	cf 93       	push	r28
    5bc6:	cd b7       	in	r28, 0x3d	; 61
    5bc8:	de b7       	in	r29, 0x3e	; 62
    5bca:	2f 97       	sbiw	r28, 0x0f	; 15
    5bcc:	0f b6       	in	r0, 0x3f	; 63
    5bce:	f8 94       	cli
    5bd0:	de bf       	out	0x3e, r29	; 62
    5bd2:	0f be       	out	0x3f, r0	; 63
    5bd4:	cd bf       	out	0x3d, r28	; 61
    5bd6:	98 87       	std	Y+8, r25	; 0x08
    5bd8:	8f 83       	std	Y+7, r24	; 0x07
    5bda:	69 87       	std	Y+9, r22	; 0x09
    5bdc:	2a 87       	std	Y+10, r18	; 0x0a
    5bde:	3b 87       	std	Y+11, r19	; 0x0b
    5be0:	4c 87       	std	Y+12, r20	; 0x0c
    5be2:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5be4:	8f 81       	ldd	r24, Y+7	; 0x07
    5be6:	98 85       	ldd	r25, Y+8	; 0x08
    5be8:	00 97       	sbiw	r24, 0x00	; 0
    5bea:	39 f4       	brne	.+14     	; 0x5bfa <ulTaskGenericNotifyValueClear+0x3c>
    5bec:	80 91 60 08 	lds	r24, 0x0860
    5bf0:	90 91 61 08 	lds	r25, 0x0861
    5bf4:	9f 87       	std	Y+15, r25	; 0x0f
    5bf6:	8e 87       	std	Y+14, r24	; 0x0e
    5bf8:	04 c0       	rjmp	.+8      	; 0x5c02 <ulTaskGenericNotifyValueClear+0x44>
    5bfa:	8f 81       	ldd	r24, Y+7	; 0x07
    5bfc:	98 85       	ldd	r25, Y+8	; 0x08
    5bfe:	9f 87       	std	Y+15, r25	; 0x0f
    5c00:	8e 87       	std	Y+14, r24	; 0x0e
    5c02:	8e 85       	ldd	r24, Y+14	; 0x0e
    5c04:	9f 85       	ldd	r25, Y+15	; 0x0f
    5c06:	9e 83       	std	Y+6, r25	; 0x06
    5c08:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    5c0a:	0f b6       	in	r0, 0x3f	; 63
    5c0c:	f8 94       	cli
    5c0e:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5c10:	89 85       	ldd	r24, Y+9	; 0x09
    5c12:	88 2f       	mov	r24, r24
    5c14:	90 e0       	ldi	r25, 0x00	; 0
    5c16:	2d 81       	ldd	r18, Y+5	; 0x05
    5c18:	3e 81       	ldd	r19, Y+6	; 0x06
    5c1a:	88 0f       	add	r24, r24
    5c1c:	99 1f       	adc	r25, r25
    5c1e:	88 0f       	add	r24, r24
    5c20:	99 1f       	adc	r25, r25
    5c22:	82 0f       	add	r24, r18
    5c24:	93 1f       	adc	r25, r19
    5c26:	fc 01       	movw	r30, r24
    5c28:	b1 96       	adiw	r30, 0x21	; 33
    5c2a:	80 81       	ld	r24, Z
    5c2c:	91 81       	ldd	r25, Z+1	; 0x01
    5c2e:	a2 81       	ldd	r26, Z+2	; 0x02
    5c30:	b3 81       	ldd	r27, Z+3	; 0x03
    5c32:	89 83       	std	Y+1, r24	; 0x01
    5c34:	9a 83       	std	Y+2, r25	; 0x02
    5c36:	ab 83       	std	Y+3, r26	; 0x03
    5c38:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5c3a:	89 85       	ldd	r24, Y+9	; 0x09
    5c3c:	08 2f       	mov	r16, r24
    5c3e:	10 e0       	ldi	r17, 0x00	; 0
    5c40:	89 85       	ldd	r24, Y+9	; 0x09
    5c42:	88 2f       	mov	r24, r24
    5c44:	90 e0       	ldi	r25, 0x00	; 0
    5c46:	2d 81       	ldd	r18, Y+5	; 0x05
    5c48:	3e 81       	ldd	r19, Y+6	; 0x06
    5c4a:	88 0f       	add	r24, r24
    5c4c:	99 1f       	adc	r25, r25
    5c4e:	88 0f       	add	r24, r24
    5c50:	99 1f       	adc	r25, r25
    5c52:	82 0f       	add	r24, r18
    5c54:	93 1f       	adc	r25, r19
    5c56:	fc 01       	movw	r30, r24
    5c58:	b1 96       	adiw	r30, 0x21	; 33
    5c5a:	20 81       	ld	r18, Z
    5c5c:	31 81       	ldd	r19, Z+1	; 0x01
    5c5e:	42 81       	ldd	r20, Z+2	; 0x02
    5c60:	53 81       	ldd	r21, Z+3	; 0x03
    5c62:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c64:	9b 85       	ldd	r25, Y+11	; 0x0b
    5c66:	ac 85       	ldd	r26, Y+12	; 0x0c
    5c68:	bd 85       	ldd	r27, Y+13	; 0x0d
    5c6a:	80 95       	com	r24
    5c6c:	90 95       	com	r25
    5c6e:	a0 95       	com	r26
    5c70:	b0 95       	com	r27
    5c72:	ba 01       	movw	r22, r20
    5c74:	a9 01       	movw	r20, r18
    5c76:	48 23       	and	r20, r24
    5c78:	59 23       	and	r21, r25
    5c7a:	6a 23       	and	r22, r26
    5c7c:	7b 23       	and	r23, r27
    5c7e:	2d 81       	ldd	r18, Y+5	; 0x05
    5c80:	3e 81       	ldd	r19, Y+6	; 0x06
    5c82:	c8 01       	movw	r24, r16
    5c84:	88 0f       	add	r24, r24
    5c86:	99 1f       	adc	r25, r25
    5c88:	88 0f       	add	r24, r24
    5c8a:	99 1f       	adc	r25, r25
    5c8c:	82 0f       	add	r24, r18
    5c8e:	93 1f       	adc	r25, r19
    5c90:	fc 01       	movw	r30, r24
    5c92:	b1 96       	adiw	r30, 0x21	; 33
    5c94:	40 83       	st	Z, r20
    5c96:	51 83       	std	Z+1, r21	; 0x01
    5c98:	62 83       	std	Z+2, r22	; 0x02
    5c9a:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5c9c:	0f 90       	pop	r0
    5c9e:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5ca0:	89 81       	ldd	r24, Y+1	; 0x01
    5ca2:	9a 81       	ldd	r25, Y+2	; 0x02
    5ca4:	ab 81       	ldd	r26, Y+3	; 0x03
    5ca6:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5ca8:	bc 01       	movw	r22, r24
    5caa:	cd 01       	movw	r24, r26
    5cac:	2f 96       	adiw	r28, 0x0f	; 15
    5cae:	0f b6       	in	r0, 0x3f	; 63
    5cb0:	f8 94       	cli
    5cb2:	de bf       	out	0x3e, r29	; 62
    5cb4:	0f be       	out	0x3f, r0	; 63
    5cb6:	cd bf       	out	0x3d, r28	; 61
    5cb8:	cf 91       	pop	r28
    5cba:	df 91       	pop	r29
    5cbc:	1f 91       	pop	r17
    5cbe:	0f 91       	pop	r16
    5cc0:	08 95       	ret

00005cc2 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    5cc2:	df 93       	push	r29
    5cc4:	cf 93       	push	r28
    5cc6:	cd b7       	in	r28, 0x3d	; 61
    5cc8:	de b7       	in	r29, 0x3e	; 62
    5cca:	27 97       	sbiw	r28, 0x07	; 7
    5ccc:	0f b6       	in	r0, 0x3f	; 63
    5cce:	f8 94       	cli
    5cd0:	de bf       	out	0x3e, r29	; 62
    5cd2:	0f be       	out	0x3f, r0	; 63
    5cd4:	cd bf       	out	0x3d, r28	; 61
    5cd6:	9e 83       	std	Y+6, r25	; 0x06
    5cd8:	8d 83       	std	Y+5, r24	; 0x05
    5cda:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5cdc:	80 91 64 08 	lds	r24, 0x0864
    5ce0:	90 91 65 08 	lds	r25, 0x0865
    5ce4:	9a 83       	std	Y+2, r25	; 0x02
    5ce6:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5ce8:	80 91 60 08 	lds	r24, 0x0860
    5cec:	90 91 61 08 	lds	r25, 0x0861
    5cf0:	02 96       	adiw	r24, 0x02	; 2
    5cf2:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    5cf6:	29 81       	ldd	r18, Y+1	; 0x01
    5cf8:	3a 81       	ldd	r19, Y+2	; 0x02
    5cfa:	8d 81       	ldd	r24, Y+5	; 0x05
    5cfc:	9e 81       	ldd	r25, Y+6	; 0x06
    5cfe:	82 0f       	add	r24, r18
    5d00:	93 1f       	adc	r25, r19
    5d02:	9c 83       	std	Y+4, r25	; 0x04
    5d04:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5d06:	e0 91 60 08 	lds	r30, 0x0860
    5d0a:	f0 91 61 08 	lds	r31, 0x0861
    5d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    5d10:	9c 81       	ldd	r25, Y+4	; 0x04
    5d12:	93 83       	std	Z+3, r25	; 0x03
    5d14:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    5d16:	2b 81       	ldd	r18, Y+3	; 0x03
    5d18:	3c 81       	ldd	r19, Y+4	; 0x04
    5d1a:	89 81       	ldd	r24, Y+1	; 0x01
    5d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    5d1e:	28 17       	cp	r18, r24
    5d20:	39 07       	cpc	r19, r25
    5d22:	70 f4       	brcc	.+28     	; 0x5d40 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5d24:	80 91 aa 08 	lds	r24, 0x08AA
    5d28:	90 91 ab 08 	lds	r25, 0x08AB
    5d2c:	20 91 60 08 	lds	r18, 0x0860
    5d30:	30 91 61 08 	lds	r19, 0x0861
    5d34:	2e 5f       	subi	r18, 0xFE	; 254
    5d36:	3f 4f       	sbci	r19, 0xFF	; 255
    5d38:	b9 01       	movw	r22, r18
    5d3a:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsert>
    5d3e:	1e c0       	rjmp	.+60     	; 0x5d7c <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5d40:	40 91 a8 08 	lds	r20, 0x08A8
    5d44:	50 91 a9 08 	lds	r21, 0x08A9
    5d48:	80 91 60 08 	lds	r24, 0x0860
    5d4c:	90 91 61 08 	lds	r25, 0x0861
    5d50:	9c 01       	movw	r18, r24
    5d52:	2e 5f       	subi	r18, 0xFE	; 254
    5d54:	3f 4f       	sbci	r19, 0xFF	; 255
    5d56:	ca 01       	movw	r24, r20
    5d58:	b9 01       	movw	r22, r18
    5d5a:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    5d5e:	20 91 6d 08 	lds	r18, 0x086D
    5d62:	30 91 6e 08 	lds	r19, 0x086E
    5d66:	8b 81       	ldd	r24, Y+3	; 0x03
    5d68:	9c 81       	ldd	r25, Y+4	; 0x04
    5d6a:	82 17       	cp	r24, r18
    5d6c:	93 07       	cpc	r25, r19
    5d6e:	30 f4       	brcc	.+12     	; 0x5d7c <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    5d70:	8b 81       	ldd	r24, Y+3	; 0x03
    5d72:	9c 81       	ldd	r25, Y+4	; 0x04
    5d74:	90 93 6e 08 	sts	0x086E, r25
    5d78:	80 93 6d 08 	sts	0x086D, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    5d7c:	27 96       	adiw	r28, 0x07	; 7
    5d7e:	0f b6       	in	r0, 0x3f	; 63
    5d80:	f8 94       	cli
    5d82:	de bf       	out	0x3e, r29	; 62
    5d84:	0f be       	out	0x3f, r0	; 63
    5d86:	cd bf       	out	0x3d, r28	; 61
    5d88:	cf 91       	pop	r28
    5d8a:	df 91       	pop	r29
    5d8c:	08 95       	ret

00005d8e <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    5d8e:	ef 92       	push	r14
    5d90:	ff 92       	push	r15
    5d92:	0f 93       	push	r16
    5d94:	df 93       	push	r29
    5d96:	cf 93       	push	r28
    5d98:	0f 92       	push	r0
    5d9a:	cd b7       	in	r28, 0x3d	; 61
    5d9c:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    5d9e:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    5da0:	0e 94 86 33 	call	0x670c	; 0x670c <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    5da4:	80 91 be 08 	lds	r24, 0x08BE
    5da8:	90 91 bf 08 	lds	r25, 0x08BF
    5dac:	00 97       	sbiw	r24, 0x00	; 0
    5dae:	81 f0       	breq	.+32     	; 0x5dd0 <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    5db0:	88 e1       	ldi	r24, 0x18	; 24
    5db2:	91 e3       	ldi	r25, 0x31	; 49
    5db4:	25 e0       	ldi	r18, 0x05	; 5
    5db6:	31 e0       	ldi	r19, 0x01	; 1
    5db8:	e0 ec       	ldi	r30, 0xC0	; 192
    5dba:	f8 e0       	ldi	r31, 0x08	; 8
    5dbc:	b9 01       	movw	r22, r18
    5dbe:	45 e5       	ldi	r20, 0x55	; 85
    5dc0:	50 e0       	ldi	r21, 0x00	; 0
    5dc2:	20 e0       	ldi	r18, 0x00	; 0
    5dc4:	30 e0       	ldi	r19, 0x00	; 0
    5dc6:	03 e0       	ldi	r16, 0x03	; 3
    5dc8:	7f 01       	movw	r14, r30
    5dca:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <xTaskCreate>
    5dce:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    5dd0:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5dd2:	0f 90       	pop	r0
    5dd4:	cf 91       	pop	r28
    5dd6:	df 91       	pop	r29
    5dd8:	0f 91       	pop	r16
    5dda:	ff 90       	pop	r15
    5ddc:	ef 90       	pop	r14
    5dde:	08 95       	ret

00005de0 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    5de0:	ef 92       	push	r14
    5de2:	ff 92       	push	r15
    5de4:	0f 93       	push	r16
    5de6:	1f 93       	push	r17
    5de8:	df 93       	push	r29
    5dea:	cf 93       	push	r28
    5dec:	cd b7       	in	r28, 0x3d	; 61
    5dee:	de b7       	in	r29, 0x3e	; 62
    5df0:	2b 97       	sbiw	r28, 0x0b	; 11
    5df2:	0f b6       	in	r0, 0x3f	; 63
    5df4:	f8 94       	cli
    5df6:	de bf       	out	0x3e, r29	; 62
    5df8:	0f be       	out	0x3f, r0	; 63
    5dfa:	cd bf       	out	0x3d, r28	; 61
    5dfc:	9c 83       	std	Y+4, r25	; 0x04
    5dfe:	8b 83       	std	Y+3, r24	; 0x03
    5e00:	7e 83       	std	Y+6, r23	; 0x06
    5e02:	6d 83       	std	Y+5, r22	; 0x05
    5e04:	4f 83       	std	Y+7, r20	; 0x07
    5e06:	39 87       	std	Y+9, r19	; 0x09
    5e08:	28 87       	std	Y+8, r18	; 0x08
    5e0a:	1b 87       	std	Y+11, r17	; 0x0b
    5e0c:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    5e0e:	83 e1       	ldi	r24, 0x13	; 19
    5e10:	90 e0       	ldi	r25, 0x00	; 0
    5e12:	0e 94 d3 06 	call	0xda6	; 0xda6 <pvPortMalloc>
    5e16:	9a 83       	std	Y+2, r25	; 0x02
    5e18:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    5e1a:	89 81       	ldd	r24, Y+1	; 0x01
    5e1c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e1e:	00 97       	sbiw	r24, 0x00	; 0
    5e20:	99 f0       	breq	.+38     	; 0x5e48 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    5e22:	e9 81       	ldd	r30, Y+1	; 0x01
    5e24:	fa 81       	ldd	r31, Y+2	; 0x02
    5e26:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    5e28:	8b 81       	ldd	r24, Y+3	; 0x03
    5e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    5e2c:	2d 81       	ldd	r18, Y+5	; 0x05
    5e2e:	3e 81       	ldd	r19, Y+6	; 0x06
    5e30:	e8 85       	ldd	r30, Y+8	; 0x08
    5e32:	f9 85       	ldd	r31, Y+9	; 0x09
    5e34:	aa 85       	ldd	r26, Y+10	; 0x0a
    5e36:	bb 85       	ldd	r27, Y+11	; 0x0b
    5e38:	e9 80       	ldd	r14, Y+1	; 0x01
    5e3a:	fa 80       	ldd	r15, Y+2	; 0x02
    5e3c:	b9 01       	movw	r22, r18
    5e3e:	4f 81       	ldd	r20, Y+7	; 0x07
    5e40:	9f 01       	movw	r18, r30
    5e42:	8d 01       	movw	r16, r26
    5e44:	0e 94 33 2f 	call	0x5e66	; 0x5e66 <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    5e48:	89 81       	ldd	r24, Y+1	; 0x01
    5e4a:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    5e4c:	2b 96       	adiw	r28, 0x0b	; 11
    5e4e:	0f b6       	in	r0, 0x3f	; 63
    5e50:	f8 94       	cli
    5e52:	de bf       	out	0x3e, r29	; 62
    5e54:	0f be       	out	0x3f, r0	; 63
    5e56:	cd bf       	out	0x3d, r28	; 61
    5e58:	cf 91       	pop	r28
    5e5a:	df 91       	pop	r29
    5e5c:	1f 91       	pop	r17
    5e5e:	0f 91       	pop	r16
    5e60:	ff 90       	pop	r15
    5e62:	ef 90       	pop	r14
    5e64:	08 95       	ret

00005e66 <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    5e66:	ef 92       	push	r14
    5e68:	ff 92       	push	r15
    5e6a:	0f 93       	push	r16
    5e6c:	1f 93       	push	r17
    5e6e:	df 93       	push	r29
    5e70:	cf 93       	push	r28
    5e72:	cd b7       	in	r28, 0x3d	; 61
    5e74:	de b7       	in	r29, 0x3e	; 62
    5e76:	2b 97       	sbiw	r28, 0x0b	; 11
    5e78:	0f b6       	in	r0, 0x3f	; 63
    5e7a:	f8 94       	cli
    5e7c:	de bf       	out	0x3e, r29	; 62
    5e7e:	0f be       	out	0x3f, r0	; 63
    5e80:	cd bf       	out	0x3d, r28	; 61
    5e82:	9a 83       	std	Y+2, r25	; 0x02
    5e84:	89 83       	std	Y+1, r24	; 0x01
    5e86:	7c 83       	std	Y+4, r23	; 0x04
    5e88:	6b 83       	std	Y+3, r22	; 0x03
    5e8a:	4d 83       	std	Y+5, r20	; 0x05
    5e8c:	3f 83       	std	Y+7, r19	; 0x07
    5e8e:	2e 83       	std	Y+6, r18	; 0x06
    5e90:	19 87       	std	Y+9, r17	; 0x09
    5e92:	08 87       	std	Y+8, r16	; 0x08
    5e94:	fb 86       	std	Y+11, r15	; 0x0b
    5e96:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    5e98:	0e 94 86 33 	call	0x670c	; 0x670c <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    5e9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5e9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5ea0:	89 81       	ldd	r24, Y+1	; 0x01
    5ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    5ea4:	91 83       	std	Z+1, r25	; 0x01
    5ea6:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    5ea8:	ea 85       	ldd	r30, Y+10	; 0x0a
    5eaa:	fb 85       	ldd	r31, Y+11	; 0x0b
    5eac:	8b 81       	ldd	r24, Y+3	; 0x03
    5eae:	9c 81       	ldd	r25, Y+4	; 0x04
    5eb0:	95 87       	std	Z+13, r25	; 0x0d
    5eb2:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    5eb4:	ea 85       	ldd	r30, Y+10	; 0x0a
    5eb6:	fb 85       	ldd	r31, Y+11	; 0x0b
    5eb8:	8e 81       	ldd	r24, Y+6	; 0x06
    5eba:	9f 81       	ldd	r25, Y+7	; 0x07
    5ebc:	97 87       	std	Z+15, r25	; 0x0f
    5ebe:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    5ec0:	ea 85       	ldd	r30, Y+10	; 0x0a
    5ec2:	fb 85       	ldd	r31, Y+11	; 0x0b
    5ec4:	88 85       	ldd	r24, Y+8	; 0x08
    5ec6:	99 85       	ldd	r25, Y+9	; 0x09
    5ec8:	91 8b       	std	Z+17, r25	; 0x11
    5eca:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    5ecc:	8a 85       	ldd	r24, Y+10	; 0x0a
    5ece:	9b 85       	ldd	r25, Y+11	; 0x0b
    5ed0:	02 96       	adiw	r24, 0x02	; 2
    5ed2:	0e 94 75 10 	call	0x20ea	; 0x20ea <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    5ed6:	8d 81       	ldd	r24, Y+5	; 0x05
    5ed8:	88 23       	and	r24, r24
    5eda:	39 f0       	breq	.+14     	; 0x5eea <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5edc:	ea 85       	ldd	r30, Y+10	; 0x0a
    5ede:	fb 85       	ldd	r31, Y+11	; 0x0b
    5ee0:	82 89       	ldd	r24, Z+18	; 0x12
    5ee2:	84 60       	ori	r24, 0x04	; 4
    5ee4:	ea 85       	ldd	r30, Y+10	; 0x0a
    5ee6:	fb 85       	ldd	r31, Y+11	; 0x0b
    5ee8:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    5eea:	2b 96       	adiw	r28, 0x0b	; 11
    5eec:	0f b6       	in	r0, 0x3f	; 63
    5eee:	f8 94       	cli
    5ef0:	de bf       	out	0x3e, r29	; 62
    5ef2:	0f be       	out	0x3f, r0	; 63
    5ef4:	cd bf       	out	0x3d, r28	; 61
    5ef6:	cf 91       	pop	r28
    5ef8:	df 91       	pop	r29
    5efa:	1f 91       	pop	r17
    5efc:	0f 91       	pop	r16
    5efe:	ff 90       	pop	r15
    5f00:	ef 90       	pop	r14
    5f02:	08 95       	ret

00005f04 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    5f04:	0f 93       	push	r16
    5f06:	1f 93       	push	r17
    5f08:	df 93       	push	r29
    5f0a:	cf 93       	push	r28
    5f0c:	cd b7       	in	r28, 0x3d	; 61
    5f0e:	de b7       	in	r29, 0x3e	; 62
    5f10:	2f 97       	sbiw	r28, 0x0f	; 15
    5f12:	0f b6       	in	r0, 0x3f	; 63
    5f14:	f8 94       	cli
    5f16:	de bf       	out	0x3e, r29	; 62
    5f18:	0f be       	out	0x3f, r0	; 63
    5f1a:	cd bf       	out	0x3d, r28	; 61
    5f1c:	98 87       	std	Y+8, r25	; 0x08
    5f1e:	8f 83       	std	Y+7, r24	; 0x07
    5f20:	69 87       	std	Y+9, r22	; 0x09
    5f22:	5b 87       	std	Y+11, r21	; 0x0b
    5f24:	4a 87       	std	Y+10, r20	; 0x0a
    5f26:	3d 87       	std	Y+13, r19	; 0x0d
    5f28:	2c 87       	std	Y+12, r18	; 0x0c
    5f2a:	1f 87       	std	Y+15, r17	; 0x0f
    5f2c:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    5f2e:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    5f30:	80 91 be 08 	lds	r24, 0x08BE
    5f34:	90 91 bf 08 	lds	r25, 0x08BF
    5f38:	00 97       	sbiw	r24, 0x00	; 0
    5f3a:	e9 f1       	breq	.+122    	; 0x5fb6 <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    5f3c:	89 85       	ldd	r24, Y+9	; 0x09
    5f3e:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    5f40:	8a 85       	ldd	r24, Y+10	; 0x0a
    5f42:	9b 85       	ldd	r25, Y+11	; 0x0b
    5f44:	9c 83       	std	Y+4, r25	; 0x04
    5f46:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    5f48:	8f 81       	ldd	r24, Y+7	; 0x07
    5f4a:	98 85       	ldd	r25, Y+8	; 0x08
    5f4c:	9e 83       	std	Y+6, r25	; 0x06
    5f4e:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    5f50:	89 85       	ldd	r24, Y+9	; 0x09
    5f52:	86 30       	cpi	r24, 0x06	; 6
    5f54:	14 f5       	brge	.+68     	; 0x5f9a <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    5f56:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <xTaskGetSchedulerState>
    5f5a:	82 30       	cpi	r24, 0x02	; 2
    5f5c:	79 f4       	brne	.+30     	; 0x5f7c <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    5f5e:	80 91 be 08 	lds	r24, 0x08BE
    5f62:	90 91 bf 08 	lds	r25, 0x08BF
    5f66:	9e 01       	movw	r18, r28
    5f68:	2e 5f       	subi	r18, 0xFE	; 254
    5f6a:	3f 4f       	sbci	r19, 0xFF	; 255
    5f6c:	4e 85       	ldd	r20, Y+14	; 0x0e
    5f6e:	5f 85       	ldd	r21, Y+15	; 0x0f
    5f70:	b9 01       	movw	r22, r18
    5f72:	20 e0       	ldi	r18, 0x00	; 0
    5f74:	0e 94 db 12 	call	0x25b6	; 0x25b6 <xQueueGenericSend>
    5f78:	89 83       	std	Y+1, r24	; 0x01
    5f7a:	1d c0       	rjmp	.+58     	; 0x5fb6 <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    5f7c:	80 91 be 08 	lds	r24, 0x08BE
    5f80:	90 91 bf 08 	lds	r25, 0x08BF
    5f84:	9e 01       	movw	r18, r28
    5f86:	2e 5f       	subi	r18, 0xFE	; 254
    5f88:	3f 4f       	sbci	r19, 0xFF	; 255
    5f8a:	b9 01       	movw	r22, r18
    5f8c:	40 e0       	ldi	r20, 0x00	; 0
    5f8e:	50 e0       	ldi	r21, 0x00	; 0
    5f90:	20 e0       	ldi	r18, 0x00	; 0
    5f92:	0e 94 db 12 	call	0x25b6	; 0x25b6 <xQueueGenericSend>
    5f96:	89 83       	std	Y+1, r24	; 0x01
    5f98:	0e c0       	rjmp	.+28     	; 0x5fb6 <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    5f9a:	80 91 be 08 	lds	r24, 0x08BE
    5f9e:	90 91 bf 08 	lds	r25, 0x08BF
    5fa2:	9e 01       	movw	r18, r28
    5fa4:	2e 5f       	subi	r18, 0xFE	; 254
    5fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    5fa8:	4c 85       	ldd	r20, Y+12	; 0x0c
    5faa:	5d 85       	ldd	r21, Y+13	; 0x0d
    5fac:	b9 01       	movw	r22, r18
    5fae:	20 e0       	ldi	r18, 0x00	; 0
    5fb0:	0e 94 87 13 	call	0x270e	; 0x270e <xQueueGenericSendFromISR>
    5fb4:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    5fb6:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5fb8:	2f 96       	adiw	r28, 0x0f	; 15
    5fba:	0f b6       	in	r0, 0x3f	; 63
    5fbc:	f8 94       	cli
    5fbe:	de bf       	out	0x3e, r29	; 62
    5fc0:	0f be       	out	0x3f, r0	; 63
    5fc2:	cd bf       	out	0x3d, r28	; 61
    5fc4:	cf 91       	pop	r28
    5fc6:	df 91       	pop	r29
    5fc8:	1f 91       	pop	r17
    5fca:	0f 91       	pop	r16
    5fcc:	08 95       	ret

00005fce <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    5fce:	df 93       	push	r29
    5fd0:	cf 93       	push	r28
    5fd2:	cd b7       	in	r28, 0x3d	; 61
    5fd4:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    5fd6:	80 91 c0 08 	lds	r24, 0x08C0
    5fda:	90 91 c1 08 	lds	r25, 0x08C1
    }
    5fde:	cf 91       	pop	r28
    5fe0:	df 91       	pop	r29
    5fe2:	08 95       	ret

00005fe4 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    5fe4:	df 93       	push	r29
    5fe6:	cf 93       	push	r28
    5fe8:	00 d0       	rcall	.+0      	; 0x5fea <xTimerGetPeriod+0x6>
    5fea:	00 d0       	rcall	.+0      	; 0x5fec <xTimerGetPeriod+0x8>
    5fec:	cd b7       	in	r28, 0x3d	; 61
    5fee:	de b7       	in	r29, 0x3e	; 62
    5ff0:	9c 83       	std	Y+4, r25	; 0x04
    5ff2:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    5ff6:	9c 81       	ldd	r25, Y+4	; 0x04
    5ff8:	9a 83       	std	Y+2, r25	; 0x02
    5ffa:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    5ffc:	e9 81       	ldd	r30, Y+1	; 0x01
    5ffe:	fa 81       	ldd	r31, Y+2	; 0x02
    6000:	84 85       	ldd	r24, Z+12	; 0x0c
    6002:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    6004:	0f 90       	pop	r0
    6006:	0f 90       	pop	r0
    6008:	0f 90       	pop	r0
    600a:	0f 90       	pop	r0
    600c:	cf 91       	pop	r28
    600e:	df 91       	pop	r29
    6010:	08 95       	ret

00006012 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    6012:	df 93       	push	r29
    6014:	cf 93       	push	r28
    6016:	00 d0       	rcall	.+0      	; 0x6018 <vTimerSetReloadMode+0x6>
    6018:	00 d0       	rcall	.+0      	; 0x601a <vTimerSetReloadMode+0x8>
    601a:	0f 92       	push	r0
    601c:	cd b7       	in	r28, 0x3d	; 61
    601e:	de b7       	in	r29, 0x3e	; 62
    6020:	9c 83       	std	Y+4, r25	; 0x04
    6022:	8b 83       	std	Y+3, r24	; 0x03
    6024:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    6026:	8b 81       	ldd	r24, Y+3	; 0x03
    6028:	9c 81       	ldd	r25, Y+4	; 0x04
    602a:	9a 83       	std	Y+2, r25	; 0x02
    602c:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    602e:	0f b6       	in	r0, 0x3f	; 63
    6030:	f8 94       	cli
    6032:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    6034:	8d 81       	ldd	r24, Y+5	; 0x05
    6036:	88 23       	and	r24, r24
    6038:	41 f0       	breq	.+16     	; 0x604a <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    603a:	e9 81       	ldd	r30, Y+1	; 0x01
    603c:	fa 81       	ldd	r31, Y+2	; 0x02
    603e:	82 89       	ldd	r24, Z+18	; 0x12
    6040:	84 60       	ori	r24, 0x04	; 4
    6042:	e9 81       	ldd	r30, Y+1	; 0x01
    6044:	fa 81       	ldd	r31, Y+2	; 0x02
    6046:	82 8b       	std	Z+18, r24	; 0x12
    6048:	07 c0       	rjmp	.+14     	; 0x6058 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    604a:	e9 81       	ldd	r30, Y+1	; 0x01
    604c:	fa 81       	ldd	r31, Y+2	; 0x02
    604e:	82 89       	ldd	r24, Z+18	; 0x12
    6050:	8b 7f       	andi	r24, 0xFB	; 251
    6052:	e9 81       	ldd	r30, Y+1	; 0x01
    6054:	fa 81       	ldd	r31, Y+2	; 0x02
    6056:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    6058:	0f 90       	pop	r0
    605a:	0f be       	out	0x3f, r0	; 63
    }
    605c:	0f 90       	pop	r0
    605e:	0f 90       	pop	r0
    6060:	0f 90       	pop	r0
    6062:	0f 90       	pop	r0
    6064:	0f 90       	pop	r0
    6066:	cf 91       	pop	r28
    6068:	df 91       	pop	r29
    606a:	08 95       	ret

0000606c <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    606c:	df 93       	push	r29
    606e:	cf 93       	push	r28
    6070:	00 d0       	rcall	.+0      	; 0x6072 <uxTimerGetReloadMode+0x6>
    6072:	00 d0       	rcall	.+0      	; 0x6074 <uxTimerGetReloadMode+0x8>
    6074:	0f 92       	push	r0
    6076:	cd b7       	in	r28, 0x3d	; 61
    6078:	de b7       	in	r29, 0x3e	; 62
    607a:	9d 83       	std	Y+5, r25	; 0x05
    607c:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    607e:	8c 81       	ldd	r24, Y+4	; 0x04
    6080:	9d 81       	ldd	r25, Y+5	; 0x05
    6082:	9b 83       	std	Y+3, r25	; 0x03
    6084:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    6086:	0f b6       	in	r0, 0x3f	; 63
    6088:	f8 94       	cli
    608a:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    608c:	ea 81       	ldd	r30, Y+2	; 0x02
    608e:	fb 81       	ldd	r31, Y+3	; 0x03
    6090:	82 89       	ldd	r24, Z+18	; 0x12
    6092:	88 2f       	mov	r24, r24
    6094:	90 e0       	ldi	r25, 0x00	; 0
    6096:	84 70       	andi	r24, 0x04	; 4
    6098:	90 70       	andi	r25, 0x00	; 0
    609a:	00 97       	sbiw	r24, 0x00	; 0
    609c:	11 f4       	brne	.+4      	; 0x60a2 <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    609e:	19 82       	std	Y+1, r1	; 0x01
    60a0:	02 c0       	rjmp	.+4      	; 0x60a6 <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    60a2:	81 e0       	ldi	r24, 0x01	; 1
    60a4:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    60a6:	0f 90       	pop	r0
    60a8:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    60aa:	89 81       	ldd	r24, Y+1	; 0x01
    }
    60ac:	0f 90       	pop	r0
    60ae:	0f 90       	pop	r0
    60b0:	0f 90       	pop	r0
    60b2:	0f 90       	pop	r0
    60b4:	0f 90       	pop	r0
    60b6:	cf 91       	pop	r28
    60b8:	df 91       	pop	r29
    60ba:	08 95       	ret

000060bc <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    60bc:	df 93       	push	r29
    60be:	cf 93       	push	r28
    60c0:	00 d0       	rcall	.+0      	; 0x60c2 <xTimerGetExpiryTime+0x6>
    60c2:	00 d0       	rcall	.+0      	; 0x60c4 <xTimerGetExpiryTime+0x8>
    60c4:	00 d0       	rcall	.+0      	; 0x60c6 <xTimerGetExpiryTime+0xa>
    60c6:	cd b7       	in	r28, 0x3d	; 61
    60c8:	de b7       	in	r29, 0x3e	; 62
    60ca:	9e 83       	std	Y+6, r25	; 0x06
    60cc:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    60ce:	8d 81       	ldd	r24, Y+5	; 0x05
    60d0:	9e 81       	ldd	r25, Y+6	; 0x06
    60d2:	9c 83       	std	Y+4, r25	; 0x04
    60d4:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    60d6:	eb 81       	ldd	r30, Y+3	; 0x03
    60d8:	fc 81       	ldd	r31, Y+4	; 0x04
    60da:	82 81       	ldd	r24, Z+2	; 0x02
    60dc:	93 81       	ldd	r25, Z+3	; 0x03
    60de:	9a 83       	std	Y+2, r25	; 0x02
    60e0:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    60e2:	89 81       	ldd	r24, Y+1	; 0x01
    60e4:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    60e6:	26 96       	adiw	r28, 0x06	; 6
    60e8:	0f b6       	in	r0, 0x3f	; 63
    60ea:	f8 94       	cli
    60ec:	de bf       	out	0x3e, r29	; 62
    60ee:	0f be       	out	0x3f, r0	; 63
    60f0:	cd bf       	out	0x3d, r28	; 61
    60f2:	cf 91       	pop	r28
    60f4:	df 91       	pop	r29
    60f6:	08 95       	ret

000060f8 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    60f8:	df 93       	push	r29
    60fa:	cf 93       	push	r28
    60fc:	00 d0       	rcall	.+0      	; 0x60fe <pcTimerGetName+0x6>
    60fe:	00 d0       	rcall	.+0      	; 0x6100 <pcTimerGetName+0x8>
    6100:	cd b7       	in	r28, 0x3d	; 61
    6102:	de b7       	in	r29, 0x3e	; 62
    6104:	9c 83       	std	Y+4, r25	; 0x04
    6106:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    6108:	8b 81       	ldd	r24, Y+3	; 0x03
    610a:	9c 81       	ldd	r25, Y+4	; 0x04
    610c:	9a 83       	std	Y+2, r25	; 0x02
    610e:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    6110:	e9 81       	ldd	r30, Y+1	; 0x01
    6112:	fa 81       	ldd	r31, Y+2	; 0x02
    6114:	80 81       	ld	r24, Z
    6116:	91 81       	ldd	r25, Z+1	; 0x01
    }
    6118:	0f 90       	pop	r0
    611a:	0f 90       	pop	r0
    611c:	0f 90       	pop	r0
    611e:	0f 90       	pop	r0
    6120:	cf 91       	pop	r28
    6122:	df 91       	pop	r29
    6124:	08 95       	ret

00006126 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    6126:	df 93       	push	r29
    6128:	cf 93       	push	r28
    612a:	00 d0       	rcall	.+0      	; 0x612c <prvReloadTimer+0x6>
    612c:	00 d0       	rcall	.+0      	; 0x612e <prvReloadTimer+0x8>
    612e:	00 d0       	rcall	.+0      	; 0x6130 <prvReloadTimer+0xa>
    6130:	cd b7       	in	r28, 0x3d	; 61
    6132:	de b7       	in	r29, 0x3e	; 62
    6134:	9a 83       	std	Y+2, r25	; 0x02
    6136:	89 83       	std	Y+1, r24	; 0x01
    6138:	7c 83       	std	Y+4, r23	; 0x04
    613a:	6b 83       	std	Y+3, r22	; 0x03
    613c:	5e 83       	std	Y+6, r21	; 0x06
    613e:	4d 83       	std	Y+5, r20	; 0x05
    6140:	12 c0       	rjmp	.+36     	; 0x6166 <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    6142:	e9 81       	ldd	r30, Y+1	; 0x01
    6144:	fa 81       	ldd	r31, Y+2	; 0x02
    6146:	24 85       	ldd	r18, Z+12	; 0x0c
    6148:	35 85       	ldd	r19, Z+13	; 0x0d
    614a:	8b 81       	ldd	r24, Y+3	; 0x03
    614c:	9c 81       	ldd	r25, Y+4	; 0x04
    614e:	82 0f       	add	r24, r18
    6150:	93 1f       	adc	r25, r19
    6152:	9c 83       	std	Y+4, r25	; 0x04
    6154:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6156:	e9 81       	ldd	r30, Y+1	; 0x01
    6158:	fa 81       	ldd	r31, Y+2	; 0x02
    615a:	00 88       	ldd	r0, Z+16	; 0x10
    615c:	f1 89       	ldd	r31, Z+17	; 0x11
    615e:	e0 2d       	mov	r30, r0
    6160:	89 81       	ldd	r24, Y+1	; 0x01
    6162:	9a 81       	ldd	r25, Y+2	; 0x02
    6164:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    6166:	e9 81       	ldd	r30, Y+1	; 0x01
    6168:	fa 81       	ldd	r31, Y+2	; 0x02
    616a:	24 85       	ldd	r18, Z+12	; 0x0c
    616c:	35 85       	ldd	r19, Z+13	; 0x0d
    616e:	8b 81       	ldd	r24, Y+3	; 0x03
    6170:	9c 81       	ldd	r25, Y+4	; 0x04
    6172:	a9 01       	movw	r20, r18
    6174:	48 0f       	add	r20, r24
    6176:	59 1f       	adc	r21, r25
    6178:	89 81       	ldd	r24, Y+1	; 0x01
    617a:	9a 81       	ldd	r25, Y+2	; 0x02
    617c:	2d 81       	ldd	r18, Y+5	; 0x05
    617e:	3e 81       	ldd	r19, Y+6	; 0x06
    6180:	eb 81       	ldd	r30, Y+3	; 0x03
    6182:	fc 81       	ldd	r31, Y+4	; 0x04
    6184:	ba 01       	movw	r22, r20
    6186:	a9 01       	movw	r20, r18
    6188:	9f 01       	movw	r18, r30
    618a:	0e 94 e9 31 	call	0x63d2	; 0x63d2 <prvInsertTimerInActiveList>
    618e:	88 23       	and	r24, r24
    6190:	c1 f6       	brne	.-80     	; 0x6142 <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    6192:	26 96       	adiw	r28, 0x06	; 6
    6194:	0f b6       	in	r0, 0x3f	; 63
    6196:	f8 94       	cli
    6198:	de bf       	out	0x3e, r29	; 62
    619a:	0f be       	out	0x3f, r0	; 63
    619c:	cd bf       	out	0x3d, r28	; 61
    619e:	cf 91       	pop	r28
    61a0:	df 91       	pop	r29
    61a2:	08 95       	ret

000061a4 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    61a4:	df 93       	push	r29
    61a6:	cf 93       	push	r28
    61a8:	00 d0       	rcall	.+0      	; 0x61aa <prvProcessExpiredTimer+0x6>
    61aa:	00 d0       	rcall	.+0      	; 0x61ac <prvProcessExpiredTimer+0x8>
    61ac:	00 d0       	rcall	.+0      	; 0x61ae <prvProcessExpiredTimer+0xa>
    61ae:	cd b7       	in	r28, 0x3d	; 61
    61b0:	de b7       	in	r29, 0x3e	; 62
    61b2:	9c 83       	std	Y+4, r25	; 0x04
    61b4:	8b 83       	std	Y+3, r24	; 0x03
    61b6:	7e 83       	std	Y+6, r23	; 0x06
    61b8:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    61ba:	e0 91 d6 08 	lds	r30, 0x08D6
    61be:	f0 91 d7 08 	lds	r31, 0x08D7
    61c2:	05 80       	ldd	r0, Z+5	; 0x05
    61c4:	f6 81       	ldd	r31, Z+6	; 0x06
    61c6:	e0 2d       	mov	r30, r0
    61c8:	86 81       	ldd	r24, Z+6	; 0x06
    61ca:	97 81       	ldd	r25, Z+7	; 0x07
    61cc:	9a 83       	std	Y+2, r25	; 0x02
    61ce:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    61d0:	89 81       	ldd	r24, Y+1	; 0x01
    61d2:	9a 81       	ldd	r25, Y+2	; 0x02
    61d4:	02 96       	adiw	r24, 0x02	; 2
    61d6:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    61da:	e9 81       	ldd	r30, Y+1	; 0x01
    61dc:	fa 81       	ldd	r31, Y+2	; 0x02
    61de:	82 89       	ldd	r24, Z+18	; 0x12
    61e0:	88 2f       	mov	r24, r24
    61e2:	90 e0       	ldi	r25, 0x00	; 0
    61e4:	84 70       	andi	r24, 0x04	; 4
    61e6:	90 70       	andi	r25, 0x00	; 0
    61e8:	00 97       	sbiw	r24, 0x00	; 0
    61ea:	51 f0       	breq	.+20     	; 0x6200 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    61ec:	89 81       	ldd	r24, Y+1	; 0x01
    61ee:	9a 81       	ldd	r25, Y+2	; 0x02
    61f0:	2b 81       	ldd	r18, Y+3	; 0x03
    61f2:	3c 81       	ldd	r19, Y+4	; 0x04
    61f4:	4d 81       	ldd	r20, Y+5	; 0x05
    61f6:	5e 81       	ldd	r21, Y+6	; 0x06
    61f8:	b9 01       	movw	r22, r18
    61fa:	0e 94 93 30 	call	0x6126	; 0x6126 <prvReloadTimer>
    61fe:	07 c0       	rjmp	.+14     	; 0x620e <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6200:	e9 81       	ldd	r30, Y+1	; 0x01
    6202:	fa 81       	ldd	r31, Y+2	; 0x02
    6204:	82 89       	ldd	r24, Z+18	; 0x12
    6206:	8e 7f       	andi	r24, 0xFE	; 254
    6208:	e9 81       	ldd	r30, Y+1	; 0x01
    620a:	fa 81       	ldd	r31, Y+2	; 0x02
    620c:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    620e:	e9 81       	ldd	r30, Y+1	; 0x01
    6210:	fa 81       	ldd	r31, Y+2	; 0x02
    6212:	00 88       	ldd	r0, Z+16	; 0x10
    6214:	f1 89       	ldd	r31, Z+17	; 0x11
    6216:	e0 2d       	mov	r30, r0
    6218:	89 81       	ldd	r24, Y+1	; 0x01
    621a:	9a 81       	ldd	r25, Y+2	; 0x02
    621c:	09 95       	icall
    }
    621e:	26 96       	adiw	r28, 0x06	; 6
    6220:	0f b6       	in	r0, 0x3f	; 63
    6222:	f8 94       	cli
    6224:	de bf       	out	0x3e, r29	; 62
    6226:	0f be       	out	0x3f, r0	; 63
    6228:	cd bf       	out	0x3d, r28	; 61
    622a:	cf 91       	pop	r28
    622c:	df 91       	pop	r29
    622e:	08 95       	ret

00006230 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    6230:	df 93       	push	r29
    6232:	cf 93       	push	r28
    6234:	00 d0       	rcall	.+0      	; 0x6236 <prvTimerTask+0x6>
    6236:	00 d0       	rcall	.+0      	; 0x6238 <prvTimerTask+0x8>
    6238:	0f 92       	push	r0
    623a:	cd b7       	in	r28, 0x3d	; 61
    623c:	de b7       	in	r29, 0x3e	; 62
    623e:	9d 83       	std	Y+5, r25	; 0x05
    6240:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    6242:	ce 01       	movw	r24, r28
    6244:	03 96       	adiw	r24, 0x03	; 3
    6246:	0e 94 87 31 	call	0x630e	; 0x630e <prvGetNextExpireTime>
    624a:	9a 83       	std	Y+2, r25	; 0x02
    624c:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    624e:	2b 81       	ldd	r18, Y+3	; 0x03
    6250:	89 81       	ldd	r24, Y+1	; 0x01
    6252:	9a 81       	ldd	r25, Y+2	; 0x02
    6254:	62 2f       	mov	r22, r18
    6256:	0e 94 30 31 	call	0x6260	; 0x6260 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    625a:	0e 94 51 32 	call	0x64a2	; 0x64a2 <prvProcessReceivedCommands>
    625e:	f1 cf       	rjmp	.-30     	; 0x6242 <prvTimerTask+0x12>

00006260 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    6260:	df 93       	push	r29
    6262:	cf 93       	push	r28
    6264:	00 d0       	rcall	.+0      	; 0x6266 <prvProcessTimerOrBlockTask+0x6>
    6266:	00 d0       	rcall	.+0      	; 0x6268 <prvProcessTimerOrBlockTask+0x8>
    6268:	00 d0       	rcall	.+0      	; 0x626a <prvProcessTimerOrBlockTask+0xa>
    626a:	cd b7       	in	r28, 0x3d	; 61
    626c:	de b7       	in	r29, 0x3e	; 62
    626e:	9d 83       	std	Y+5, r25	; 0x05
    6270:	8c 83       	std	Y+4, r24	; 0x04
    6272:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    6274:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    6278:	ce 01       	movw	r24, r28
    627a:	03 96       	adiw	r24, 0x03	; 3
    627c:	0e 94 bb 31 	call	0x6376	; 0x6376 <prvSampleTimeNow>
    6280:	9a 83       	std	Y+2, r25	; 0x02
    6282:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    6284:	8b 81       	ldd	r24, Y+3	; 0x03
    6286:	88 23       	and	r24, r24
    6288:	b9 f5       	brne	.+110    	; 0x62f8 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    628a:	8e 81       	ldd	r24, Y+6	; 0x06
    628c:	88 23       	and	r24, r24
    628e:	89 f4       	brne	.+34     	; 0x62b2 <prvProcessTimerOrBlockTask+0x52>
    6290:	2c 81       	ldd	r18, Y+4	; 0x04
    6292:	3d 81       	ldd	r19, Y+5	; 0x05
    6294:	89 81       	ldd	r24, Y+1	; 0x01
    6296:	9a 81       	ldd	r25, Y+2	; 0x02
    6298:	82 17       	cp	r24, r18
    629a:	93 07       	cpc	r25, r19
    629c:	50 f0       	brcs	.+20     	; 0x62b2 <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    629e:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    62a2:	8c 81       	ldd	r24, Y+4	; 0x04
    62a4:	9d 81       	ldd	r25, Y+5	; 0x05
    62a6:	29 81       	ldd	r18, Y+1	; 0x01
    62a8:	3a 81       	ldd	r19, Y+2	; 0x02
    62aa:	b9 01       	movw	r22, r18
    62ac:	0e 94 d2 30 	call	0x61a4	; 0x61a4 <prvProcessExpiredTimer>
    62b0:	25 c0       	rjmp	.+74     	; 0x62fc <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    62b2:	8e 81       	ldd	r24, Y+6	; 0x06
    62b4:	88 23       	and	r24, r24
    62b6:	51 f0       	breq	.+20     	; 0x62cc <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    62b8:	e0 91 d8 08 	lds	r30, 0x08D8
    62bc:	f0 91 d9 08 	lds	r31, 0x08D9
    62c0:	80 81       	ld	r24, Z
    62c2:	1e 82       	std	Y+6, r1	; 0x06
    62c4:	88 23       	and	r24, r24
    62c6:	11 f4       	brne	.+4      	; 0x62cc <prvProcessTimerOrBlockTask+0x6c>
    62c8:	81 e0       	ldi	r24, 0x01	; 1
    62ca:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    62cc:	40 91 be 08 	lds	r20, 0x08BE
    62d0:	50 91 bf 08 	lds	r21, 0x08BF
    62d4:	2c 81       	ldd	r18, Y+4	; 0x04
    62d6:	3d 81       	ldd	r19, Y+5	; 0x05
    62d8:	89 81       	ldd	r24, Y+1	; 0x01
    62da:	9a 81       	ldd	r25, Y+2	; 0x02
    62dc:	28 1b       	sub	r18, r24
    62de:	39 0b       	sbc	r19, r25
    62e0:	ca 01       	movw	r24, r20
    62e2:	b9 01       	movw	r22, r18
    62e4:	4e 81       	ldd	r20, Y+6	; 0x06
    62e6:	0e 94 94 1a 	call	0x3528	; 0x3528 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    62ea:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
    62ee:	88 23       	and	r24, r24
    62f0:	29 f4       	brne	.+10     	; 0x62fc <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    62f2:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    62f6:	02 c0       	rjmp	.+4      	; 0x62fc <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    62f8:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskResumeAll>
            }
        }
    }
    62fc:	26 96       	adiw	r28, 0x06	; 6
    62fe:	0f b6       	in	r0, 0x3f	; 63
    6300:	f8 94       	cli
    6302:	de bf       	out	0x3e, r29	; 62
    6304:	0f be       	out	0x3f, r0	; 63
    6306:	cd bf       	out	0x3d, r28	; 61
    6308:	cf 91       	pop	r28
    630a:	df 91       	pop	r29
    630c:	08 95       	ret

0000630e <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    630e:	df 93       	push	r29
    6310:	cf 93       	push	r28
    6312:	00 d0       	rcall	.+0      	; 0x6314 <prvGetNextExpireTime+0x6>
    6314:	00 d0       	rcall	.+0      	; 0x6316 <prvGetNextExpireTime+0x8>
    6316:	0f 92       	push	r0
    6318:	cd b7       	in	r28, 0x3d	; 61
    631a:	de b7       	in	r29, 0x3e	; 62
    631c:	9c 83       	std	Y+4, r25	; 0x04
    631e:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    6320:	e0 91 d6 08 	lds	r30, 0x08D6
    6324:	f0 91 d7 08 	lds	r31, 0x08D7
    6328:	80 81       	ld	r24, Z
    632a:	1d 82       	std	Y+5, r1	; 0x05
    632c:	88 23       	and	r24, r24
    632e:	11 f4       	brne	.+4      	; 0x6334 <prvGetNextExpireTime+0x26>
    6330:	81 e0       	ldi	r24, 0x01	; 1
    6332:	8d 83       	std	Y+5, r24	; 0x05
    6334:	eb 81       	ldd	r30, Y+3	; 0x03
    6336:	fc 81       	ldd	r31, Y+4	; 0x04
    6338:	8d 81       	ldd	r24, Y+5	; 0x05
    633a:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    633c:	eb 81       	ldd	r30, Y+3	; 0x03
    633e:	fc 81       	ldd	r31, Y+4	; 0x04
    6340:	80 81       	ld	r24, Z
    6342:	88 23       	and	r24, r24
    6344:	61 f4       	brne	.+24     	; 0x635e <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    6346:	e0 91 d6 08 	lds	r30, 0x08D6
    634a:	f0 91 d7 08 	lds	r31, 0x08D7
    634e:	05 80       	ldd	r0, Z+5	; 0x05
    6350:	f6 81       	ldd	r31, Z+6	; 0x06
    6352:	e0 2d       	mov	r30, r0
    6354:	80 81       	ld	r24, Z
    6356:	91 81       	ldd	r25, Z+1	; 0x01
    6358:	9a 83       	std	Y+2, r25	; 0x02
    635a:	89 83       	std	Y+1, r24	; 0x01
    635c:	02 c0       	rjmp	.+4      	; 0x6362 <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    635e:	1a 82       	std	Y+2, r1	; 0x02
    6360:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    6362:	89 81       	ldd	r24, Y+1	; 0x01
    6364:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6366:	0f 90       	pop	r0
    6368:	0f 90       	pop	r0
    636a:	0f 90       	pop	r0
    636c:	0f 90       	pop	r0
    636e:	0f 90       	pop	r0
    6370:	cf 91       	pop	r28
    6372:	df 91       	pop	r29
    6374:	08 95       	ret

00006376 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    6376:	df 93       	push	r29
    6378:	cf 93       	push	r28
    637a:	00 d0       	rcall	.+0      	; 0x637c <prvSampleTimeNow+0x6>
    637c:	00 d0       	rcall	.+0      	; 0x637e <prvSampleTimeNow+0x8>
    637e:	cd b7       	in	r28, 0x3d	; 61
    6380:	de b7       	in	r29, 0x3e	; 62
    6382:	9c 83       	std	Y+4, r25	; 0x04
    6384:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    6386:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <xTaskGetTickCount>
    638a:	9a 83       	std	Y+2, r25	; 0x02
    638c:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    638e:	20 91 c2 08 	lds	r18, 0x08C2
    6392:	30 91 c3 08 	lds	r19, 0x08C3
    6396:	89 81       	ldd	r24, Y+1	; 0x01
    6398:	9a 81       	ldd	r25, Y+2	; 0x02
    639a:	82 17       	cp	r24, r18
    639c:	93 07       	cpc	r25, r19
    639e:	38 f4       	brcc	.+14     	; 0x63ae <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    63a0:	0e 94 4c 33 	call	0x6698	; 0x6698 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    63a4:	eb 81       	ldd	r30, Y+3	; 0x03
    63a6:	fc 81       	ldd	r31, Y+4	; 0x04
    63a8:	81 e0       	ldi	r24, 0x01	; 1
    63aa:	80 83       	st	Z, r24
    63ac:	03 c0       	rjmp	.+6      	; 0x63b4 <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    63ae:	eb 81       	ldd	r30, Y+3	; 0x03
    63b0:	fc 81       	ldd	r31, Y+4	; 0x04
    63b2:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    63b4:	89 81       	ldd	r24, Y+1	; 0x01
    63b6:	9a 81       	ldd	r25, Y+2	; 0x02
    63b8:	90 93 c3 08 	sts	0x08C3, r25
    63bc:	80 93 c2 08 	sts	0x08C2, r24

        return xTimeNow;
    63c0:	89 81       	ldd	r24, Y+1	; 0x01
    63c2:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    63c4:	0f 90       	pop	r0
    63c6:	0f 90       	pop	r0
    63c8:	0f 90       	pop	r0
    63ca:	0f 90       	pop	r0
    63cc:	cf 91       	pop	r28
    63ce:	df 91       	pop	r29
    63d0:	08 95       	ret

000063d2 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    63d2:	df 93       	push	r29
    63d4:	cf 93       	push	r28
    63d6:	cd b7       	in	r28, 0x3d	; 61
    63d8:	de b7       	in	r29, 0x3e	; 62
    63da:	29 97       	sbiw	r28, 0x09	; 9
    63dc:	0f b6       	in	r0, 0x3f	; 63
    63de:	f8 94       	cli
    63e0:	de bf       	out	0x3e, r29	; 62
    63e2:	0f be       	out	0x3f, r0	; 63
    63e4:	cd bf       	out	0x3d, r28	; 61
    63e6:	9b 83       	std	Y+3, r25	; 0x03
    63e8:	8a 83       	std	Y+2, r24	; 0x02
    63ea:	7d 83       	std	Y+5, r23	; 0x05
    63ec:	6c 83       	std	Y+4, r22	; 0x04
    63ee:	5f 83       	std	Y+7, r21	; 0x07
    63f0:	4e 83       	std	Y+6, r20	; 0x06
    63f2:	39 87       	std	Y+9, r19	; 0x09
    63f4:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    63f6:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    63f8:	ea 81       	ldd	r30, Y+2	; 0x02
    63fa:	fb 81       	ldd	r31, Y+3	; 0x03
    63fc:	8c 81       	ldd	r24, Y+4	; 0x04
    63fe:	9d 81       	ldd	r25, Y+5	; 0x05
    6400:	93 83       	std	Z+3, r25	; 0x03
    6402:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    6404:	ea 81       	ldd	r30, Y+2	; 0x02
    6406:	fb 81       	ldd	r31, Y+3	; 0x03
    6408:	8a 81       	ldd	r24, Y+2	; 0x02
    640a:	9b 81       	ldd	r25, Y+3	; 0x03
    640c:	91 87       	std	Z+9, r25	; 0x09
    640e:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    6410:	2c 81       	ldd	r18, Y+4	; 0x04
    6412:	3d 81       	ldd	r19, Y+5	; 0x05
    6414:	8e 81       	ldd	r24, Y+6	; 0x06
    6416:	9f 81       	ldd	r25, Y+7	; 0x07
    6418:	82 17       	cp	r24, r18
    641a:	93 07       	cpc	r25, r19
    641c:	e0 f0       	brcs	.+56     	; 0x6456 <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    641e:	2e 81       	ldd	r18, Y+6	; 0x06
    6420:	3f 81       	ldd	r19, Y+7	; 0x07
    6422:	88 85       	ldd	r24, Y+8	; 0x08
    6424:	99 85       	ldd	r25, Y+9	; 0x09
    6426:	28 1b       	sub	r18, r24
    6428:	39 0b       	sbc	r19, r25
    642a:	ea 81       	ldd	r30, Y+2	; 0x02
    642c:	fb 81       	ldd	r31, Y+3	; 0x03
    642e:	84 85       	ldd	r24, Z+12	; 0x0c
    6430:	95 85       	ldd	r25, Z+13	; 0x0d
    6432:	28 17       	cp	r18, r24
    6434:	39 07       	cpc	r19, r25
    6436:	18 f0       	brcs	.+6      	; 0x643e <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    6438:	81 e0       	ldi	r24, 0x01	; 1
    643a:	89 83       	std	Y+1, r24	; 0x01
    643c:	28 c0       	rjmp	.+80     	; 0x648e <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    643e:	80 91 d8 08 	lds	r24, 0x08D8
    6442:	90 91 d9 08 	lds	r25, 0x08D9
    6446:	2a 81       	ldd	r18, Y+2	; 0x02
    6448:	3b 81       	ldd	r19, Y+3	; 0x03
    644a:	2e 5f       	subi	r18, 0xFE	; 254
    644c:	3f 4f       	sbci	r19, 0xFF	; 255
    644e:	b9 01       	movw	r22, r18
    6450:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsert>
    6454:	1c c0       	rjmp	.+56     	; 0x648e <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    6456:	2e 81       	ldd	r18, Y+6	; 0x06
    6458:	3f 81       	ldd	r19, Y+7	; 0x07
    645a:	88 85       	ldd	r24, Y+8	; 0x08
    645c:	99 85       	ldd	r25, Y+9	; 0x09
    645e:	28 17       	cp	r18, r24
    6460:	39 07       	cpc	r19, r25
    6462:	50 f4       	brcc	.+20     	; 0x6478 <prvInsertTimerInActiveList+0xa6>
    6464:	2c 81       	ldd	r18, Y+4	; 0x04
    6466:	3d 81       	ldd	r19, Y+5	; 0x05
    6468:	88 85       	ldd	r24, Y+8	; 0x08
    646a:	99 85       	ldd	r25, Y+9	; 0x09
    646c:	28 17       	cp	r18, r24
    646e:	39 07       	cpc	r19, r25
    6470:	18 f0       	brcs	.+6      	; 0x6478 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    6472:	81 e0       	ldi	r24, 0x01	; 1
    6474:	89 83       	std	Y+1, r24	; 0x01
    6476:	0b c0       	rjmp	.+22     	; 0x648e <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    6478:	80 91 d6 08 	lds	r24, 0x08D6
    647c:	90 91 d7 08 	lds	r25, 0x08D7
    6480:	2a 81       	ldd	r18, Y+2	; 0x02
    6482:	3b 81       	ldd	r19, Y+3	; 0x03
    6484:	2e 5f       	subi	r18, 0xFE	; 254
    6486:	3f 4f       	sbci	r19, 0xFF	; 255
    6488:	b9 01       	movw	r22, r18
    648a:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsert>
            }
        }

        return xProcessTimerNow;
    648e:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6490:	29 96       	adiw	r28, 0x09	; 9
    6492:	0f b6       	in	r0, 0x3f	; 63
    6494:	f8 94       	cli
    6496:	de bf       	out	0x3e, r29	; 62
    6498:	0f be       	out	0x3f, r0	; 63
    649a:	cd bf       	out	0x3d, r28	; 61
    649c:	cf 91       	pop	r28
    649e:	df 91       	pop	r29
    64a0:	08 95       	ret

000064a2 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    64a2:	df 93       	push	r29
    64a4:	cf 93       	push	r28
    64a6:	cd b7       	in	r28, 0x3d	; 61
    64a8:	de b7       	in	r29, 0x3e	; 62
    64aa:	2c 97       	sbiw	r28, 0x0c	; 12
    64ac:	0f b6       	in	r0, 0x3f	; 63
    64ae:	f8 94       	cli
    64b0:	de bf       	out	0x3e, r29	; 62
    64b2:	0f be       	out	0x3f, r0	; 63
    64b4:	cd bf       	out	0x3d, r28	; 61
    64b6:	d8 c0       	rjmp	.+432    	; 0x6668 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    64b8:	8d 81       	ldd	r24, Y+5	; 0x05
    64ba:	88 23       	and	r24, r24
    64bc:	0c f4       	brge	.+2      	; 0x64c0 <prvProcessReceivedCommands+0x1e>
    64be:	d4 c0       	rjmp	.+424    	; 0x6668 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    64c0:	88 85       	ldd	r24, Y+8	; 0x08
    64c2:	99 85       	ldd	r25, Y+9	; 0x09
    64c4:	9c 83       	std	Y+4, r25	; 0x04
    64c6:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    64c8:	eb 81       	ldd	r30, Y+3	; 0x03
    64ca:	fc 81       	ldd	r31, Y+4	; 0x04
    64cc:	82 85       	ldd	r24, Z+10	; 0x0a
    64ce:	93 85       	ldd	r25, Z+11	; 0x0b
    64d0:	00 97       	sbiw	r24, 0x00	; 0
    64d2:	29 f0       	breq	.+10     	; 0x64de <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    64d4:	8b 81       	ldd	r24, Y+3	; 0x03
    64d6:	9c 81       	ldd	r25, Y+4	; 0x04
    64d8:	02 96       	adiw	r24, 0x02	; 2
    64da:	0e 94 35 11 	call	0x226a	; 0x226a <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    64de:	ce 01       	movw	r24, r28
    64e0:	0a 96       	adiw	r24, 0x0a	; 10
    64e2:	0e 94 bb 31 	call	0x6376	; 0x6376 <prvSampleTimeNow>
    64e6:	9a 83       	std	Y+2, r25	; 0x02
    64e8:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    64ea:	8d 81       	ldd	r24, Y+5	; 0x05
    64ec:	28 2f       	mov	r18, r24
    64ee:	33 27       	eor	r19, r19
    64f0:	27 fd       	sbrc	r18, 7
    64f2:	30 95       	com	r19
    64f4:	3c 87       	std	Y+12, r19	; 0x0c
    64f6:	2b 87       	std	Y+11, r18	; 0x0b
    64f8:	8b 85       	ldd	r24, Y+11	; 0x0b
    64fa:	9c 85       	ldd	r25, Y+12	; 0x0c
    64fc:	85 30       	cpi	r24, 0x05	; 5
    64fe:	91 05       	cpc	r25, r1
    6500:	09 f4       	brne	.+2      	; 0x6504 <prvProcessReceivedCommands+0x62>
    6502:	9d c0       	rjmp	.+314    	; 0x663e <prvProcessReceivedCommands+0x19c>
    6504:	2b 85       	ldd	r18, Y+11	; 0x0b
    6506:	3c 85       	ldd	r19, Y+12	; 0x0c
    6508:	26 30       	cpi	r18, 0x06	; 6
    650a:	31 05       	cpc	r19, r1
    650c:	9c f4       	brge	.+38     	; 0x6534 <prvProcessReceivedCommands+0x92>
    650e:	8b 85       	ldd	r24, Y+11	; 0x0b
    6510:	9c 85       	ldd	r25, Y+12	; 0x0c
    6512:	83 30       	cpi	r24, 0x03	; 3
    6514:	91 05       	cpc	r25, r1
    6516:	09 f4       	brne	.+2      	; 0x651a <prvProcessReceivedCommands+0x78>
    6518:	68 c0       	rjmp	.+208    	; 0x65ea <prvProcessReceivedCommands+0x148>
    651a:	2b 85       	ldd	r18, Y+11	; 0x0b
    651c:	3c 85       	ldd	r19, Y+12	; 0x0c
    651e:	24 30       	cpi	r18, 0x04	; 4
    6520:	31 05       	cpc	r19, r1
    6522:	0c f0       	brlt	.+2      	; 0x6526 <prvProcessReceivedCommands+0x84>
    6524:	6a c0       	rjmp	.+212    	; 0x65fa <prvProcessReceivedCommands+0x158>
    6526:	8b 85       	ldd	r24, Y+11	; 0x0b
    6528:	9c 85       	ldd	r25, Y+12	; 0x0c
    652a:	81 30       	cpi	r24, 0x01	; 1
    652c:	91 05       	cpc	r25, r1
    652e:	0c f4       	brge	.+2      	; 0x6532 <prvProcessReceivedCommands+0x90>
    6530:	9b c0       	rjmp	.+310    	; 0x6668 <prvProcessReceivedCommands+0x1c6>
    6532:	12 c0       	rjmp	.+36     	; 0x6558 <prvProcessReceivedCommands+0xb6>
    6534:	2b 85       	ldd	r18, Y+11	; 0x0b
    6536:	3c 85       	ldd	r19, Y+12	; 0x0c
    6538:	28 30       	cpi	r18, 0x08	; 8
    653a:	31 05       	cpc	r19, r1
    653c:	09 f4       	brne	.+2      	; 0x6540 <prvProcessReceivedCommands+0x9e>
    653e:	55 c0       	rjmp	.+170    	; 0x65ea <prvProcessReceivedCommands+0x148>
    6540:	8b 85       	ldd	r24, Y+11	; 0x0b
    6542:	9c 85       	ldd	r25, Y+12	; 0x0c
    6544:	88 30       	cpi	r24, 0x08	; 8
    6546:	91 05       	cpc	r25, r1
    6548:	3c f0       	brlt	.+14     	; 0x6558 <prvProcessReceivedCommands+0xb6>
    654a:	2b 85       	ldd	r18, Y+11	; 0x0b
    654c:	3c 85       	ldd	r19, Y+12	; 0x0c
    654e:	29 30       	cpi	r18, 0x09	; 9
    6550:	31 05       	cpc	r19, r1
    6552:	09 f4       	brne	.+2      	; 0x6556 <prvProcessReceivedCommands+0xb4>
    6554:	52 c0       	rjmp	.+164    	; 0x65fa <prvProcessReceivedCommands+0x158>
    6556:	88 c0       	rjmp	.+272    	; 0x6668 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    6558:	eb 81       	ldd	r30, Y+3	; 0x03
    655a:	fc 81       	ldd	r31, Y+4	; 0x04
    655c:	82 89       	ldd	r24, Z+18	; 0x12
    655e:	81 60       	ori	r24, 0x01	; 1
    6560:	eb 81       	ldd	r30, Y+3	; 0x03
    6562:	fc 81       	ldd	r31, Y+4	; 0x04
    6564:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    6566:	2e 81       	ldd	r18, Y+6	; 0x06
    6568:	3f 81       	ldd	r19, Y+7	; 0x07
    656a:	eb 81       	ldd	r30, Y+3	; 0x03
    656c:	fc 81       	ldd	r31, Y+4	; 0x04
    656e:	84 85       	ldd	r24, Z+12	; 0x0c
    6570:	95 85       	ldd	r25, Z+13	; 0x0d
    6572:	a9 01       	movw	r20, r18
    6574:	48 0f       	add	r20, r24
    6576:	59 1f       	adc	r21, r25
    6578:	ee 81       	ldd	r30, Y+6	; 0x06
    657a:	ff 81       	ldd	r31, Y+7	; 0x07
    657c:	8b 81       	ldd	r24, Y+3	; 0x03
    657e:	9c 81       	ldd	r25, Y+4	; 0x04
    6580:	29 81       	ldd	r18, Y+1	; 0x01
    6582:	3a 81       	ldd	r19, Y+2	; 0x02
    6584:	ba 01       	movw	r22, r20
    6586:	a9 01       	movw	r20, r18
    6588:	9f 01       	movw	r18, r30
    658a:	0e 94 e9 31 	call	0x63d2	; 0x63d2 <prvInsertTimerInActiveList>
    658e:	88 23       	and	r24, r24
    6590:	09 f4       	brne	.+2      	; 0x6594 <prvProcessReceivedCommands+0xf2>
    6592:	6a c0       	rjmp	.+212    	; 0x6668 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    6594:	eb 81       	ldd	r30, Y+3	; 0x03
    6596:	fc 81       	ldd	r31, Y+4	; 0x04
    6598:	82 89       	ldd	r24, Z+18	; 0x12
    659a:	88 2f       	mov	r24, r24
    659c:	90 e0       	ldi	r25, 0x00	; 0
    659e:	84 70       	andi	r24, 0x04	; 4
    65a0:	90 70       	andi	r25, 0x00	; 0
    65a2:	00 97       	sbiw	r24, 0x00	; 0
    65a4:	91 f0       	breq	.+36     	; 0x65ca <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    65a6:	2e 81       	ldd	r18, Y+6	; 0x06
    65a8:	3f 81       	ldd	r19, Y+7	; 0x07
    65aa:	eb 81       	ldd	r30, Y+3	; 0x03
    65ac:	fc 81       	ldd	r31, Y+4	; 0x04
    65ae:	84 85       	ldd	r24, Z+12	; 0x0c
    65b0:	95 85       	ldd	r25, Z+13	; 0x0d
    65b2:	a9 01       	movw	r20, r18
    65b4:	48 0f       	add	r20, r24
    65b6:	59 1f       	adc	r21, r25
    65b8:	8b 81       	ldd	r24, Y+3	; 0x03
    65ba:	9c 81       	ldd	r25, Y+4	; 0x04
    65bc:	29 81       	ldd	r18, Y+1	; 0x01
    65be:	3a 81       	ldd	r19, Y+2	; 0x02
    65c0:	ba 01       	movw	r22, r20
    65c2:	a9 01       	movw	r20, r18
    65c4:	0e 94 93 30 	call	0x6126	; 0x6126 <prvReloadTimer>
    65c8:	07 c0       	rjmp	.+14     	; 0x65d8 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    65ca:	eb 81       	ldd	r30, Y+3	; 0x03
    65cc:	fc 81       	ldd	r31, Y+4	; 0x04
    65ce:	82 89       	ldd	r24, Z+18	; 0x12
    65d0:	8e 7f       	andi	r24, 0xFE	; 254
    65d2:	eb 81       	ldd	r30, Y+3	; 0x03
    65d4:	fc 81       	ldd	r31, Y+4	; 0x04
    65d6:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    65d8:	eb 81       	ldd	r30, Y+3	; 0x03
    65da:	fc 81       	ldd	r31, Y+4	; 0x04
    65dc:	00 88       	ldd	r0, Z+16	; 0x10
    65de:	f1 89       	ldd	r31, Z+17	; 0x11
    65e0:	e0 2d       	mov	r30, r0
    65e2:	8b 81       	ldd	r24, Y+3	; 0x03
    65e4:	9c 81       	ldd	r25, Y+4	; 0x04
    65e6:	09 95       	icall
    65e8:	3f c0       	rjmp	.+126    	; 0x6668 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    65ea:	eb 81       	ldd	r30, Y+3	; 0x03
    65ec:	fc 81       	ldd	r31, Y+4	; 0x04
    65ee:	82 89       	ldd	r24, Z+18	; 0x12
    65f0:	8e 7f       	andi	r24, 0xFE	; 254
    65f2:	eb 81       	ldd	r30, Y+3	; 0x03
    65f4:	fc 81       	ldd	r31, Y+4	; 0x04
    65f6:	82 8b       	std	Z+18, r24	; 0x12
    65f8:	37 c0       	rjmp	.+110    	; 0x6668 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    65fa:	eb 81       	ldd	r30, Y+3	; 0x03
    65fc:	fc 81       	ldd	r31, Y+4	; 0x04
    65fe:	82 89       	ldd	r24, Z+18	; 0x12
    6600:	81 60       	ori	r24, 0x01	; 1
    6602:	eb 81       	ldd	r30, Y+3	; 0x03
    6604:	fc 81       	ldd	r31, Y+4	; 0x04
    6606:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    6608:	8e 81       	ldd	r24, Y+6	; 0x06
    660a:	9f 81       	ldd	r25, Y+7	; 0x07
    660c:	eb 81       	ldd	r30, Y+3	; 0x03
    660e:	fc 81       	ldd	r31, Y+4	; 0x04
    6610:	95 87       	std	Z+13, r25	; 0x0d
    6612:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    6614:	eb 81       	ldd	r30, Y+3	; 0x03
    6616:	fc 81       	ldd	r31, Y+4	; 0x04
    6618:	24 85       	ldd	r18, Z+12	; 0x0c
    661a:	35 85       	ldd	r19, Z+13	; 0x0d
    661c:	89 81       	ldd	r24, Y+1	; 0x01
    661e:	9a 81       	ldd	r25, Y+2	; 0x02
    6620:	a9 01       	movw	r20, r18
    6622:	48 0f       	add	r20, r24
    6624:	59 1f       	adc	r21, r25
    6626:	8b 81       	ldd	r24, Y+3	; 0x03
    6628:	9c 81       	ldd	r25, Y+4	; 0x04
    662a:	29 81       	ldd	r18, Y+1	; 0x01
    662c:	3a 81       	ldd	r19, Y+2	; 0x02
    662e:	e9 81       	ldd	r30, Y+1	; 0x01
    6630:	fa 81       	ldd	r31, Y+2	; 0x02
    6632:	ba 01       	movw	r22, r20
    6634:	a9 01       	movw	r20, r18
    6636:	9f 01       	movw	r18, r30
    6638:	0e 94 e9 31 	call	0x63d2	; 0x63d2 <prvInsertTimerInActiveList>
    663c:	15 c0       	rjmp	.+42     	; 0x6668 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    663e:	eb 81       	ldd	r30, Y+3	; 0x03
    6640:	fc 81       	ldd	r31, Y+4	; 0x04
    6642:	82 89       	ldd	r24, Z+18	; 0x12
    6644:	88 2f       	mov	r24, r24
    6646:	90 e0       	ldi	r25, 0x00	; 0
    6648:	82 70       	andi	r24, 0x02	; 2
    664a:	90 70       	andi	r25, 0x00	; 0
    664c:	00 97       	sbiw	r24, 0x00	; 0
    664e:	29 f4       	brne	.+10     	; 0x665a <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    6650:	8b 81       	ldd	r24, Y+3	; 0x03
    6652:	9c 81       	ldd	r25, Y+4	; 0x04
    6654:	0e 94 2d 07 	call	0xe5a	; 0xe5a <vPortFree>
    6658:	07 c0       	rjmp	.+14     	; 0x6668 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    665a:	eb 81       	ldd	r30, Y+3	; 0x03
    665c:	fc 81       	ldd	r31, Y+4	; 0x04
    665e:	82 89       	ldd	r24, Z+18	; 0x12
    6660:	8e 7f       	andi	r24, 0xFE	; 254
    6662:	eb 81       	ldd	r30, Y+3	; 0x03
    6664:	fc 81       	ldd	r31, Y+4	; 0x04
    6666:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    6668:	80 91 be 08 	lds	r24, 0x08BE
    666c:	90 91 bf 08 	lds	r25, 0x08BF
    6670:	9e 01       	movw	r18, r28
    6672:	2b 5f       	subi	r18, 0xFB	; 251
    6674:	3f 4f       	sbci	r19, 0xFF	; 255
    6676:	b9 01       	movw	r22, r18
    6678:	40 e0       	ldi	r20, 0x00	; 0
    667a:	50 e0       	ldi	r21, 0x00	; 0
    667c:	0e 94 34 14 	call	0x2868	; 0x2868 <xQueueReceive>
    6680:	88 23       	and	r24, r24
    6682:	09 f0       	breq	.+2      	; 0x6686 <prvProcessReceivedCommands+0x1e4>
    6684:	19 cf       	rjmp	.-462    	; 0x64b8 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    6686:	2c 96       	adiw	r28, 0x0c	; 12
    6688:	0f b6       	in	r0, 0x3f	; 63
    668a:	f8 94       	cli
    668c:	de bf       	out	0x3e, r29	; 62
    668e:	0f be       	out	0x3f, r0	; 63
    6690:	cd bf       	out	0x3d, r28	; 61
    6692:	cf 91       	pop	r28
    6694:	df 91       	pop	r29
    6696:	08 95       	ret

00006698 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    6698:	df 93       	push	r29
    669a:	cf 93       	push	r28
    669c:	00 d0       	rcall	.+0      	; 0x669e <prvSwitchTimerLists+0x6>
    669e:	00 d0       	rcall	.+0      	; 0x66a0 <prvSwitchTimerLists+0x8>
    66a0:	cd b7       	in	r28, 0x3d	; 61
    66a2:	de b7       	in	r29, 0x3e	; 62
    66a4:	11 c0       	rjmp	.+34     	; 0x66c8 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    66a6:	e0 91 d6 08 	lds	r30, 0x08D6
    66aa:	f0 91 d7 08 	lds	r31, 0x08D7
    66ae:	05 80       	ldd	r0, Z+5	; 0x05
    66b0:	f6 81       	ldd	r31, Z+6	; 0x06
    66b2:	e0 2d       	mov	r30, r0
    66b4:	80 81       	ld	r24, Z
    66b6:	91 81       	ldd	r25, Z+1	; 0x01
    66b8:	9c 83       	std	Y+4, r25	; 0x04
    66ba:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    66bc:	8b 81       	ldd	r24, Y+3	; 0x03
    66be:	9c 81       	ldd	r25, Y+4	; 0x04
    66c0:	6f ef       	ldi	r22, 0xFF	; 255
    66c2:	7f ef       	ldi	r23, 0xFF	; 255
    66c4:	0e 94 d2 30 	call	0x61a4	; 0x61a4 <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    66c8:	e0 91 d6 08 	lds	r30, 0x08D6
    66cc:	f0 91 d7 08 	lds	r31, 0x08D7
    66d0:	80 81       	ld	r24, Z
    66d2:	88 23       	and	r24, r24
    66d4:	41 f7       	brne	.-48     	; 0x66a6 <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    66d6:	80 91 d6 08 	lds	r24, 0x08D6
    66da:	90 91 d7 08 	lds	r25, 0x08D7
    66de:	9a 83       	std	Y+2, r25	; 0x02
    66e0:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    66e2:	80 91 d8 08 	lds	r24, 0x08D8
    66e6:	90 91 d9 08 	lds	r25, 0x08D9
    66ea:	90 93 d7 08 	sts	0x08D7, r25
    66ee:	80 93 d6 08 	sts	0x08D6, r24
        pxOverflowTimerList = pxTemp;
    66f2:	89 81       	ldd	r24, Y+1	; 0x01
    66f4:	9a 81       	ldd	r25, Y+2	; 0x02
    66f6:	90 93 d9 08 	sts	0x08D9, r25
    66fa:	80 93 d8 08 	sts	0x08D8, r24
    }
    66fe:	0f 90       	pop	r0
    6700:	0f 90       	pop	r0
    6702:	0f 90       	pop	r0
    6704:	0f 90       	pop	r0
    6706:	cf 91       	pop	r28
    6708:	df 91       	pop	r29
    670a:	08 95       	ret

0000670c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    670c:	df 93       	push	r29
    670e:	cf 93       	push	r28
    6710:	cd b7       	in	r28, 0x3d	; 61
    6712:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    6714:	0f b6       	in	r0, 0x3f	; 63
    6716:	f8 94       	cli
    6718:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    671a:	80 91 be 08 	lds	r24, 0x08BE
    671e:	90 91 bf 08 	lds	r25, 0x08BF
    6722:	00 97       	sbiw	r24, 0x00	; 0
    6724:	e9 f4       	brne	.+58     	; 0x6760 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    6726:	84 ec       	ldi	r24, 0xC4	; 196
    6728:	98 e0       	ldi	r25, 0x08	; 8
    672a:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    672e:	8d ec       	ldi	r24, 0xCD	; 205
    6730:	98 e0       	ldi	r25, 0x08	; 8
    6732:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    6736:	84 ec       	ldi	r24, 0xC4	; 196
    6738:	98 e0       	ldi	r25, 0x08	; 8
    673a:	90 93 d7 08 	sts	0x08D7, r25
    673e:	80 93 d6 08 	sts	0x08D6, r24
                pxOverflowTimerList = &xActiveTimerList2;
    6742:	8d ec       	ldi	r24, 0xCD	; 205
    6744:	98 e0       	ldi	r25, 0x08	; 8
    6746:	90 93 d9 08 	sts	0x08D9, r25
    674a:	80 93 d8 08 	sts	0x08D8, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    674e:	8a e0       	ldi	r24, 0x0A	; 10
    6750:	65 e0       	ldi	r22, 0x05	; 5
    6752:	40 e0       	ldi	r20, 0x00	; 0
    6754:	0e 94 2c 12 	call	0x2458	; 0x2458 <xQueueGenericCreate>
    6758:	90 93 bf 08 	sts	0x08BF, r25
    675c:	80 93 be 08 	sts	0x08BE, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6760:	0f 90       	pop	r0
    6762:	0f be       	out	0x3f, r0	; 63
    }
    6764:	cf 91       	pop	r28
    6766:	df 91       	pop	r29
    6768:	08 95       	ret

0000676a <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    676a:	df 93       	push	r29
    676c:	cf 93       	push	r28
    676e:	00 d0       	rcall	.+0      	; 0x6770 <xTimerIsTimerActive+0x6>
    6770:	00 d0       	rcall	.+0      	; 0x6772 <xTimerIsTimerActive+0x8>
    6772:	0f 92       	push	r0
    6774:	cd b7       	in	r28, 0x3d	; 61
    6776:	de b7       	in	r29, 0x3e	; 62
    6778:	9d 83       	std	Y+5, r25	; 0x05
    677a:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    677c:	8c 81       	ldd	r24, Y+4	; 0x04
    677e:	9d 81       	ldd	r25, Y+5	; 0x05
    6780:	9a 83       	std	Y+2, r25	; 0x02
    6782:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    6784:	0f b6       	in	r0, 0x3f	; 63
    6786:	f8 94       	cli
    6788:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    678a:	e9 81       	ldd	r30, Y+1	; 0x01
    678c:	fa 81       	ldd	r31, Y+2	; 0x02
    678e:	82 89       	ldd	r24, Z+18	; 0x12
    6790:	88 2f       	mov	r24, r24
    6792:	90 e0       	ldi	r25, 0x00	; 0
    6794:	81 70       	andi	r24, 0x01	; 1
    6796:	90 70       	andi	r25, 0x00	; 0
    6798:	00 97       	sbiw	r24, 0x00	; 0
    679a:	11 f4       	brne	.+4      	; 0x67a0 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    679c:	1b 82       	std	Y+3, r1	; 0x03
    679e:	02 c0       	rjmp	.+4      	; 0x67a4 <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    67a0:	81 e0       	ldi	r24, 0x01	; 1
    67a2:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    67a4:	0f 90       	pop	r0
    67a6:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    67a8:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    67aa:	0f 90       	pop	r0
    67ac:	0f 90       	pop	r0
    67ae:	0f 90       	pop	r0
    67b0:	0f 90       	pop	r0
    67b2:	0f 90       	pop	r0
    67b4:	cf 91       	pop	r28
    67b6:	df 91       	pop	r29
    67b8:	08 95       	ret

000067ba <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    67ba:	df 93       	push	r29
    67bc:	cf 93       	push	r28
    67be:	00 d0       	rcall	.+0      	; 0x67c0 <pvTimerGetTimerID+0x6>
    67c0:	00 d0       	rcall	.+0      	; 0x67c2 <pvTimerGetTimerID+0x8>
    67c2:	00 d0       	rcall	.+0      	; 0x67c4 <pvTimerGetTimerID+0xa>
    67c4:	cd b7       	in	r28, 0x3d	; 61
    67c6:	de b7       	in	r29, 0x3e	; 62
    67c8:	9e 83       	std	Y+6, r25	; 0x06
    67ca:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    67cc:	8d 81       	ldd	r24, Y+5	; 0x05
    67ce:	9e 81       	ldd	r25, Y+6	; 0x06
    67d0:	9c 83       	std	Y+4, r25	; 0x04
    67d2:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    67d4:	0f b6       	in	r0, 0x3f	; 63
    67d6:	f8 94       	cli
    67d8:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    67da:	eb 81       	ldd	r30, Y+3	; 0x03
    67dc:	fc 81       	ldd	r31, Y+4	; 0x04
    67de:	86 85       	ldd	r24, Z+14	; 0x0e
    67e0:	97 85       	ldd	r25, Z+15	; 0x0f
    67e2:	9a 83       	std	Y+2, r25	; 0x02
    67e4:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    67e6:	0f 90       	pop	r0
    67e8:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    67ea:	89 81       	ldd	r24, Y+1	; 0x01
    67ec:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    67ee:	26 96       	adiw	r28, 0x06	; 6
    67f0:	0f b6       	in	r0, 0x3f	; 63
    67f2:	f8 94       	cli
    67f4:	de bf       	out	0x3e, r29	; 62
    67f6:	0f be       	out	0x3f, r0	; 63
    67f8:	cd bf       	out	0x3d, r28	; 61
    67fa:	cf 91       	pop	r28
    67fc:	df 91       	pop	r29
    67fe:	08 95       	ret

00006800 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    6800:	df 93       	push	r29
    6802:	cf 93       	push	r28
    6804:	00 d0       	rcall	.+0      	; 0x6806 <vTimerSetTimerID+0x6>
    6806:	00 d0       	rcall	.+0      	; 0x6808 <vTimerSetTimerID+0x8>
    6808:	00 d0       	rcall	.+0      	; 0x680a <vTimerSetTimerID+0xa>
    680a:	cd b7       	in	r28, 0x3d	; 61
    680c:	de b7       	in	r29, 0x3e	; 62
    680e:	9c 83       	std	Y+4, r25	; 0x04
    6810:	8b 83       	std	Y+3, r24	; 0x03
    6812:	7e 83       	std	Y+6, r23	; 0x06
    6814:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    6816:	8b 81       	ldd	r24, Y+3	; 0x03
    6818:	9c 81       	ldd	r25, Y+4	; 0x04
    681a:	9a 83       	std	Y+2, r25	; 0x02
    681c:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    681e:	0f b6       	in	r0, 0x3f	; 63
    6820:	f8 94       	cli
    6822:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    6824:	e9 81       	ldd	r30, Y+1	; 0x01
    6826:	fa 81       	ldd	r31, Y+2	; 0x02
    6828:	8d 81       	ldd	r24, Y+5	; 0x05
    682a:	9e 81       	ldd	r25, Y+6	; 0x06
    682c:	97 87       	std	Z+15, r25	; 0x0f
    682e:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    6830:	0f 90       	pop	r0
    6832:	0f be       	out	0x3f, r0	; 63
    }
    6834:	26 96       	adiw	r28, 0x06	; 6
    6836:	0f b6       	in	r0, 0x3f	; 63
    6838:	f8 94       	cli
    683a:	de bf       	out	0x3e, r29	; 62
    683c:	0f be       	out	0x3f, r0	; 63
    683e:	cd bf       	out	0x3d, r28	; 61
    6840:	cf 91       	pop	r28
    6842:	df 91       	pop	r29
    6844:	08 95       	ret

00006846 <Handle_data>:




void Handle_data(States_GroupType *Sates_Ptr)
{
    6846:	df 93       	push	r29
    6848:	cf 93       	push	r28
    684a:	00 d0       	rcall	.+0      	; 0x684c <Handle_data+0x6>
    684c:	cd b7       	in	r28, 0x3d	; 61
    684e:	de b7       	in	r29, 0x3e	; 62
    6850:	9a 83       	std	Y+2, r25	; 0x02
    6852:	89 83       	std	Y+1, r24	; 0x01

	if(Sates_Ptr->ignition_key==TRUE)
    6854:	e9 81       	ldd	r30, Y+1	; 0x01
    6856:	fa 81       	ldd	r31, Y+2	; 0x02
    6858:	80 81       	ld	r24, Z
    685a:	81 30       	cpi	r24, 0x01	; 1
    685c:	b1 f4       	brne	.+44     	; 0x688a <Handle_data+0x44>
	{
		if(Sates_Ptr->rightIndicator==TRUE)
    685e:	e9 81       	ldd	r30, Y+1	; 0x01
    6860:	fa 81       	ldd	r31, Y+2	; 0x02
    6862:	81 81       	ldd	r24, Z+1	; 0x01
    6864:	81 30       	cpi	r24, 0x01	; 1
    6866:	21 f4       	brne	.+8      	; 0x6870 <Handle_data+0x2a>
		{
			state = (unsigned char)RIGHT_INDICATOR;
    6868:	81 e0       	ldi	r24, 0x01	; 1
    686a:	80 93 e8 08 	sts	0x08E8, r24
    686e:	10 c0       	rjmp	.+32     	; 0x6890 <Handle_data+0x4a>
		}
		else if(Sates_Ptr->leftIndicator==TRUE)
    6870:	e9 81       	ldd	r30, Y+1	; 0x01
    6872:	fa 81       	ldd	r31, Y+2	; 0x02
    6874:	82 81       	ldd	r24, Z+2	; 0x02
    6876:	81 30       	cpi	r24, 0x01	; 1
    6878:	21 f4       	brne	.+8      	; 0x6882 <Handle_data+0x3c>
		{
			state = LEFT_INDICATOR;
    687a:	82 e0       	ldi	r24, 0x02	; 2
    687c:	80 93 e8 08 	sts	0x08E8, r24
    6880:	07 c0       	rjmp	.+14     	; 0x6890 <Handle_data+0x4a>
		}
		else{
			state = NO_INDICATOR;
    6882:	83 e0       	ldi	r24, 0x03	; 3
    6884:	80 93 e8 08 	sts	0x08E8, r24
    6888:	03 c0       	rjmp	.+6      	; 0x6890 <Handle_data+0x4a>
		}
	}
	else{
		state = NO_INDICATOR;
    688a:	83 e0       	ldi	r24, 0x03	; 3
    688c:	80 93 e8 08 	sts	0x08E8, r24
	}

	if(Sates_Ptr->hazard_Btn==TRUE)
    6890:	e9 81       	ldd	r30, Y+1	; 0x01
    6892:	fa 81       	ldd	r31, Y+2	; 0x02
    6894:	83 81       	ldd	r24, Z+3	; 0x03
    6896:	81 30       	cpi	r24, 0x01	; 1
    6898:	19 f4       	brne	.+6      	; 0x68a0 <Handle_data+0x5a>
	{
		state = HAZARD_BUTTON;
    689a:	84 e0       	ldi	r24, 0x04	; 4
    689c:	80 93 e8 08 	sts	0x08E8, r24
	}



	State_Handler();
    68a0:	0e 94 57 34 	call	0x68ae	; 0x68ae <State_Handler>
}
    68a4:	0f 90       	pop	r0
    68a6:	0f 90       	pop	r0
    68a8:	cf 91       	pop	r28
    68aa:	df 91       	pop	r29
    68ac:	08 95       	ret

000068ae <State_Handler>:

void State_Handler(void)
{
    68ae:	df 93       	push	r29
    68b0:	cf 93       	push	r28
    68b2:	00 d0       	rcall	.+0      	; 0x68b4 <State_Handler+0x6>
    68b4:	cd b7       	in	r28, 0x3d	; 61
    68b6:	de b7       	in	r29, 0x3e	; 62


	switch(state)
    68b8:	80 91 e8 08 	lds	r24, 0x08E8
    68bc:	28 2f       	mov	r18, r24
    68be:	30 e0       	ldi	r19, 0x00	; 0
    68c0:	3a 83       	std	Y+2, r19	; 0x02
    68c2:	29 83       	std	Y+1, r18	; 0x01
    68c4:	89 81       	ldd	r24, Y+1	; 0x01
    68c6:	9a 81       	ldd	r25, Y+2	; 0x02
    68c8:	82 30       	cpi	r24, 0x02	; 2
    68ca:	91 05       	cpc	r25, r1
    68cc:	e1 f0       	breq	.+56     	; 0x6906 <State_Handler+0x58>
    68ce:	29 81       	ldd	r18, Y+1	; 0x01
    68d0:	3a 81       	ldd	r19, Y+2	; 0x02
    68d2:	23 30       	cpi	r18, 0x03	; 3
    68d4:	31 05       	cpc	r19, r1
    68d6:	34 f4       	brge	.+12     	; 0x68e4 <State_Handler+0x36>
    68d8:	89 81       	ldd	r24, Y+1	; 0x01
    68da:	9a 81       	ldd	r25, Y+2	; 0x02
    68dc:	81 30       	cpi	r24, 0x01	; 1
    68de:	91 05       	cpc	r25, r1
    68e0:	79 f0       	breq	.+30     	; 0x6900 <State_Handler+0x52>
    68e2:	17 c0       	rjmp	.+46     	; 0x6912 <State_Handler+0x64>
    68e4:	29 81       	ldd	r18, Y+1	; 0x01
    68e6:	3a 81       	ldd	r19, Y+2	; 0x02
    68e8:	23 30       	cpi	r18, 0x03	; 3
    68ea:	31 05       	cpc	r19, r1
    68ec:	31 f0       	breq	.+12     	; 0x68fa <State_Handler+0x4c>
    68ee:	89 81       	ldd	r24, Y+1	; 0x01
    68f0:	9a 81       	ldd	r25, Y+2	; 0x02
    68f2:	84 30       	cpi	r24, 0x04	; 4
    68f4:	91 05       	cpc	r25, r1
    68f6:	51 f0       	breq	.+20     	; 0x690c <State_Handler+0x5e>
    68f8:	0c c0       	rjmp	.+24     	; 0x6912 <State_Handler+0x64>
	{
	case NO_INDICATOR:
		NoLED_Blink();
    68fa:	0e 94 bb 34 	call	0x6976	; 0x6976 <NoLED_Blink>
    68fe:	0b c0       	rjmp	.+22     	; 0x6916 <State_Handler+0x68>
		break;
	case RIGHT_INDICATOR:
		RightLED_Blink();
    6900:	0e 94 90 34 	call	0x6920	; 0x6920 <RightLED_Blink>
    6904:	08 c0       	rjmp	.+16     	; 0x6916 <State_Handler+0x68>
		break;
	case LEFT_INDICATOR:
		LeftLED_Blink();
    6906:	0e 94 9e 34 	call	0x693c	; 0x693c <LeftLED_Blink>
    690a:	05 c0       	rjmp	.+10     	; 0x6916 <State_Handler+0x68>
		break;
	case HAZARD_BUTTON:
		BothLEDS_Blink();
    690c:	0e 94 ac 34 	call	0x6958	; 0x6958 <BothLEDS_Blink>
    6910:	02 c0       	rjmp	.+4      	; 0x6916 <State_Handler+0x68>
		break;
	default:
	    NoLED_Blink();
    6912:	0e 94 bb 34 	call	0x6976	; 0x6976 <NoLED_Blink>
	    break;
	}

}
    6916:	0f 90       	pop	r0
    6918:	0f 90       	pop	r0
    691a:	cf 91       	pop	r28
    691c:	df 91       	pop	r29
    691e:	08 95       	ret

00006920 <RightLED_Blink>:




void RightLED_Blink(void)
{
    6920:	df 93       	push	r29
    6922:	cf 93       	push	r28
    6924:	cd b7       	in	r28, 0x3d	; 61
    6926:	de b7       	in	r29, 0x3e	; 62
	PWM_Timer0_Start(0u);
    6928:	80 e0       	ldi	r24, 0x00	; 0
    692a:	0e 94 7f 3d 	call	0x7afe	; 0x7afe <PWM_Timer0_Start>
	PWM_Timer2_Start(LEDIntensity);
    692e:	80 91 31 02 	lds	r24, 0x0231
    6932:	0e 94 b1 3d 	call	0x7b62	; 0x7b62 <PWM_Timer2_Start>
}
    6936:	cf 91       	pop	r28
    6938:	df 91       	pop	r29
    693a:	08 95       	ret

0000693c <LeftLED_Blink>:


void LeftLED_Blink(void)
{
    693c:	df 93       	push	r29
    693e:	cf 93       	push	r28
    6940:	cd b7       	in	r28, 0x3d	; 61
    6942:	de b7       	in	r29, 0x3e	; 62
	PWM_Timer2_Start(0u);
    6944:	80 e0       	ldi	r24, 0x00	; 0
    6946:	0e 94 b1 3d 	call	0x7b62	; 0x7b62 <PWM_Timer2_Start>
	PWM_Timer0_Start(LEDIntensity);
    694a:	80 91 31 02 	lds	r24, 0x0231
    694e:	0e 94 7f 3d 	call	0x7afe	; 0x7afe <PWM_Timer0_Start>
}
    6952:	cf 91       	pop	r28
    6954:	df 91       	pop	r29
    6956:	08 95       	ret

00006958 <BothLEDS_Blink>:
void BothLEDS_Blink(void)
{
    6958:	df 93       	push	r29
    695a:	cf 93       	push	r28
    695c:	cd b7       	in	r28, 0x3d	; 61
    695e:	de b7       	in	r29, 0x3e	; 62
	PWM_Timer0_Start(LEDIntensity);
    6960:	80 91 31 02 	lds	r24, 0x0231
    6964:	0e 94 7f 3d 	call	0x7afe	; 0x7afe <PWM_Timer0_Start>
	PWM_Timer2_Start(LEDIntensity);
    6968:	80 91 31 02 	lds	r24, 0x0231
    696c:	0e 94 b1 3d 	call	0x7b62	; 0x7b62 <PWM_Timer2_Start>
}
    6970:	cf 91       	pop	r28
    6972:	df 91       	pop	r29
    6974:	08 95       	ret

00006976 <NoLED_Blink>:

void NoLED_Blink(void){
    6976:	df 93       	push	r29
    6978:	cf 93       	push	r28
    697a:	cd b7       	in	r28, 0x3d	; 61
    697c:	de b7       	in	r29, 0x3e	; 62
	PWM_Timer0_Start(0u);
    697e:	80 e0       	ldi	r24, 0x00	; 0
    6980:	0e 94 7f 3d 	call	0x7afe	; 0x7afe <PWM_Timer0_Start>
	PWM_Timer2_Start(0u);
    6984:	80 e0       	ldi	r24, 0x00	; 0
    6986:	0e 94 b1 3d 	call	0x7b62	; 0x7b62 <PWM_Timer2_Start>
}
    698a:	cf 91       	pop	r28
    698c:	df 91       	pop	r29
    698e:	08 95       	ret

00006990 <timer1_PWM_Init>:
#include "avr/iom64.h"
#include "Timer1_PWM.h"

unsigned long TopValue = 0;

void timer1_PWM_Init(void){
    6990:	df 93       	push	r29
    6992:	cf 93       	push	r28
    6994:	cd b7       	in	r28, 0x3d	; 61
    6996:	de b7       	in	r29, 0x3e	; 62
	TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1<< WGM11);
    6998:	ef e4       	ldi	r30, 0x4F	; 79
    699a:	f0 e0       	ldi	r31, 0x00	; 0
    699c:	82 ea       	ldi	r24, 0xA2	; 162
    699e:	80 83       	st	Z, r24
	TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS10);
    69a0:	ee e4       	ldi	r30, 0x4E	; 78
    69a2:	f0 e0       	ldi	r31, 0x00	; 0
    69a4:	89 e1       	ldi	r24, 0x19	; 25
    69a6:	80 83       	st	Z, r24
	TopValue = ((float)100/PWM_FREQUENCY_IN_KHZ)*160;
    69a8:	80 ea       	ldi	r24, 0xA0	; 160
    69aa:	90 e0       	ldi	r25, 0x00	; 0
    69ac:	a0 e0       	ldi	r26, 0x00	; 0
    69ae:	b0 e0       	ldi	r27, 0x00	; 0
    69b0:	80 93 db 08 	sts	0x08DB, r24
    69b4:	90 93 dc 08 	sts	0x08DC, r25
    69b8:	a0 93 dd 08 	sts	0x08DD, r26
    69bc:	b0 93 de 08 	sts	0x08DE, r27
	ICR1 = TopValue;
    69c0:	e6 e4       	ldi	r30, 0x46	; 70
    69c2:	f0 e0       	ldi	r31, 0x00	; 0
    69c4:	80 91 db 08 	lds	r24, 0x08DB
    69c8:	90 91 dc 08 	lds	r25, 0x08DC
    69cc:	a0 91 dd 08 	lds	r26, 0x08DD
    69d0:	b0 91 de 08 	lds	r27, 0x08DE
    69d4:	91 83       	std	Z+1, r25	; 0x01
    69d6:	80 83       	st	Z, r24
//	OCR1A = 20000;
//	OCR1B = 45500;
	DDRB |= (1<<PB5) | (1<<PB6);
    69d8:	a7 e3       	ldi	r26, 0x37	; 55
    69da:	b0 e0       	ldi	r27, 0x00	; 0
    69dc:	e7 e3       	ldi	r30, 0x37	; 55
    69de:	f0 e0       	ldi	r31, 0x00	; 0
    69e0:	80 81       	ld	r24, Z
    69e2:	80 66       	ori	r24, 0x60	; 96
    69e4:	8c 93       	st	X, r24


}
    69e6:	cf 91       	pop	r28
    69e8:	df 91       	pop	r29
    69ea:	08 95       	ret

000069ec <timer1_SetPWM_B>:

void timer1_SetPWM_B(unsigned char dutyB){
    69ec:	ef 92       	push	r14
    69ee:	ff 92       	push	r15
    69f0:	0f 93       	push	r16
    69f2:	1f 93       	push	r17
    69f4:	df 93       	push	r29
    69f6:	cf 93       	push	r28
    69f8:	00 d0       	rcall	.+0      	; 0x69fa <timer1_SetPWM_B+0xe>
    69fa:	00 d0       	rcall	.+0      	; 0x69fc <timer1_SetPWM_B+0x10>
    69fc:	0f 92       	push	r0
    69fe:	cd b7       	in	r28, 0x3d	; 61
    6a00:	de b7       	in	r29, 0x3e	; 62
    6a02:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyB/100)*(TopValue));
    6a04:	8d 81       	ldd	r24, Y+5	; 0x05
    6a06:	88 2f       	mov	r24, r24
    6a08:	90 e0       	ldi	r25, 0x00	; 0
    6a0a:	a0 e0       	ldi	r26, 0x00	; 0
    6a0c:	b0 e0       	ldi	r27, 0x00	; 0
    6a0e:	bc 01       	movw	r22, r24
    6a10:	cd 01       	movw	r24, r26
    6a12:	0e 94 65 04 	call	0x8ca	; 0x8ca <__floatunsisf>
    6a16:	dc 01       	movw	r26, r24
    6a18:	cb 01       	movw	r24, r22
    6a1a:	bc 01       	movw	r22, r24
    6a1c:	cd 01       	movw	r24, r26
    6a1e:	20 e0       	ldi	r18, 0x00	; 0
    6a20:	30 e0       	ldi	r19, 0x00	; 0
    6a22:	48 ec       	ldi	r20, 0xC8	; 200
    6a24:	52 e4       	ldi	r21, 0x42	; 66
    6a26:	0e 94 35 03 	call	0x66a	; 0x66a <__divsf3>
    6a2a:	dc 01       	movw	r26, r24
    6a2c:	cb 01       	movw	r24, r22
    6a2e:	7c 01       	movw	r14, r24
    6a30:	8d 01       	movw	r16, r26
    6a32:	80 91 db 08 	lds	r24, 0x08DB
    6a36:	90 91 dc 08 	lds	r25, 0x08DC
    6a3a:	a0 91 dd 08 	lds	r26, 0x08DD
    6a3e:	b0 91 de 08 	lds	r27, 0x08DE
    6a42:	bc 01       	movw	r22, r24
    6a44:	cd 01       	movw	r24, r26
    6a46:	0e 94 65 04 	call	0x8ca	; 0x8ca <__floatunsisf>
    6a4a:	9b 01       	movw	r18, r22
    6a4c:	ac 01       	movw	r20, r24
    6a4e:	c8 01       	movw	r24, r16
    6a50:	b7 01       	movw	r22, r14
    6a52:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    6a56:	dc 01       	movw	r26, r24
    6a58:	cb 01       	movw	r24, r22
    6a5a:	bc 01       	movw	r22, r24
    6a5c:	cd 01       	movw	r24, r26
    6a5e:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    6a62:	dc 01       	movw	r26, r24
    6a64:	cb 01       	movw	r24, r22
    6a66:	89 83       	std	Y+1, r24	; 0x01
    6a68:	9a 83       	std	Y+2, r25	; 0x02
    6a6a:	ab 83       	std	Y+3, r26	; 0x03
    6a6c:	bc 83       	std	Y+4, r27	; 0x04
	OCR1B = actualDuty;
    6a6e:	e8 e4       	ldi	r30, 0x48	; 72
    6a70:	f0 e0       	ldi	r31, 0x00	; 0
    6a72:	89 81       	ldd	r24, Y+1	; 0x01
    6a74:	9a 81       	ldd	r25, Y+2	; 0x02
    6a76:	91 83       	std	Z+1, r25	; 0x01
    6a78:	80 83       	st	Z, r24
}
    6a7a:	0f 90       	pop	r0
    6a7c:	0f 90       	pop	r0
    6a7e:	0f 90       	pop	r0
    6a80:	0f 90       	pop	r0
    6a82:	0f 90       	pop	r0
    6a84:	cf 91       	pop	r28
    6a86:	df 91       	pop	r29
    6a88:	1f 91       	pop	r17
    6a8a:	0f 91       	pop	r16
    6a8c:	ff 90       	pop	r15
    6a8e:	ef 90       	pop	r14
    6a90:	08 95       	ret

00006a92 <timer1_SetPWM_A>:


void timer1_SetPWM_A(unsigned char dutyA){
    6a92:	ef 92       	push	r14
    6a94:	ff 92       	push	r15
    6a96:	0f 93       	push	r16
    6a98:	1f 93       	push	r17
    6a9a:	df 93       	push	r29
    6a9c:	cf 93       	push	r28
    6a9e:	00 d0       	rcall	.+0      	; 0x6aa0 <timer1_SetPWM_A+0xe>
    6aa0:	00 d0       	rcall	.+0      	; 0x6aa2 <timer1_SetPWM_A+0x10>
    6aa2:	0f 92       	push	r0
    6aa4:	cd b7       	in	r28, 0x3d	; 61
    6aa6:	de b7       	in	r29, 0x3e	; 62
    6aa8:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyA/100)*(TopValue));
    6aaa:	8d 81       	ldd	r24, Y+5	; 0x05
    6aac:	88 2f       	mov	r24, r24
    6aae:	90 e0       	ldi	r25, 0x00	; 0
    6ab0:	a0 e0       	ldi	r26, 0x00	; 0
    6ab2:	b0 e0       	ldi	r27, 0x00	; 0
    6ab4:	bc 01       	movw	r22, r24
    6ab6:	cd 01       	movw	r24, r26
    6ab8:	0e 94 65 04 	call	0x8ca	; 0x8ca <__floatunsisf>
    6abc:	dc 01       	movw	r26, r24
    6abe:	cb 01       	movw	r24, r22
    6ac0:	bc 01       	movw	r22, r24
    6ac2:	cd 01       	movw	r24, r26
    6ac4:	20 e0       	ldi	r18, 0x00	; 0
    6ac6:	30 e0       	ldi	r19, 0x00	; 0
    6ac8:	48 ec       	ldi	r20, 0xC8	; 200
    6aca:	52 e4       	ldi	r21, 0x42	; 66
    6acc:	0e 94 35 03 	call	0x66a	; 0x66a <__divsf3>
    6ad0:	dc 01       	movw	r26, r24
    6ad2:	cb 01       	movw	r24, r22
    6ad4:	7c 01       	movw	r14, r24
    6ad6:	8d 01       	movw	r16, r26
    6ad8:	80 91 db 08 	lds	r24, 0x08DB
    6adc:	90 91 dc 08 	lds	r25, 0x08DC
    6ae0:	a0 91 dd 08 	lds	r26, 0x08DD
    6ae4:	b0 91 de 08 	lds	r27, 0x08DE
    6ae8:	bc 01       	movw	r22, r24
    6aea:	cd 01       	movw	r24, r26
    6aec:	0e 94 65 04 	call	0x8ca	; 0x8ca <__floatunsisf>
    6af0:	9b 01       	movw	r18, r22
    6af2:	ac 01       	movw	r20, r24
    6af4:	c8 01       	movw	r24, r16
    6af6:	b7 01       	movw	r22, r14
    6af8:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    6afc:	dc 01       	movw	r26, r24
    6afe:	cb 01       	movw	r24, r22
    6b00:	bc 01       	movw	r22, r24
    6b02:	cd 01       	movw	r24, r26
    6b04:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    6b08:	dc 01       	movw	r26, r24
    6b0a:	cb 01       	movw	r24, r22
    6b0c:	89 83       	std	Y+1, r24	; 0x01
    6b0e:	9a 83       	std	Y+2, r25	; 0x02
    6b10:	ab 83       	std	Y+3, r26	; 0x03
    6b12:	bc 83       	std	Y+4, r27	; 0x04
	OCR1A = actualDuty;
    6b14:	ea e4       	ldi	r30, 0x4A	; 74
    6b16:	f0 e0       	ldi	r31, 0x00	; 0
    6b18:	89 81       	ldd	r24, Y+1	; 0x01
    6b1a:	9a 81       	ldd	r25, Y+2	; 0x02
    6b1c:	91 83       	std	Z+1, r25	; 0x01
    6b1e:	80 83       	st	Z, r24
}
    6b20:	0f 90       	pop	r0
    6b22:	0f 90       	pop	r0
    6b24:	0f 90       	pop	r0
    6b26:	0f 90       	pop	r0
    6b28:	0f 90       	pop	r0
    6b2a:	cf 91       	pop	r28
    6b2c:	df 91       	pop	r29
    6b2e:	1f 91       	pop	r17
    6b30:	0f 91       	pop	r16
    6b32:	ff 90       	pop	r15
    6b34:	ef 90       	pop	r14
    6b36:	08 95       	ret

00006b38 <timer1_SetPWM_A_B>:


void timer1_SetPWM_A_B(unsigned char dutyA_B){
    6b38:	ef 92       	push	r14
    6b3a:	ff 92       	push	r15
    6b3c:	0f 93       	push	r16
    6b3e:	1f 93       	push	r17
    6b40:	df 93       	push	r29
    6b42:	cf 93       	push	r28
    6b44:	00 d0       	rcall	.+0      	; 0x6b46 <timer1_SetPWM_A_B+0xe>
    6b46:	00 d0       	rcall	.+0      	; 0x6b48 <timer1_SetPWM_A_B+0x10>
    6b48:	0f 92       	push	r0
    6b4a:	cd b7       	in	r28, 0x3d	; 61
    6b4c:	de b7       	in	r29, 0x3e	; 62
    6b4e:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyA_B/100)*(TopValue));
    6b50:	8d 81       	ldd	r24, Y+5	; 0x05
    6b52:	88 2f       	mov	r24, r24
    6b54:	90 e0       	ldi	r25, 0x00	; 0
    6b56:	a0 e0       	ldi	r26, 0x00	; 0
    6b58:	b0 e0       	ldi	r27, 0x00	; 0
    6b5a:	bc 01       	movw	r22, r24
    6b5c:	cd 01       	movw	r24, r26
    6b5e:	0e 94 65 04 	call	0x8ca	; 0x8ca <__floatunsisf>
    6b62:	dc 01       	movw	r26, r24
    6b64:	cb 01       	movw	r24, r22
    6b66:	bc 01       	movw	r22, r24
    6b68:	cd 01       	movw	r24, r26
    6b6a:	20 e0       	ldi	r18, 0x00	; 0
    6b6c:	30 e0       	ldi	r19, 0x00	; 0
    6b6e:	48 ec       	ldi	r20, 0xC8	; 200
    6b70:	52 e4       	ldi	r21, 0x42	; 66
    6b72:	0e 94 35 03 	call	0x66a	; 0x66a <__divsf3>
    6b76:	dc 01       	movw	r26, r24
    6b78:	cb 01       	movw	r24, r22
    6b7a:	7c 01       	movw	r14, r24
    6b7c:	8d 01       	movw	r16, r26
    6b7e:	80 91 db 08 	lds	r24, 0x08DB
    6b82:	90 91 dc 08 	lds	r25, 0x08DC
    6b86:	a0 91 dd 08 	lds	r26, 0x08DD
    6b8a:	b0 91 de 08 	lds	r27, 0x08DE
    6b8e:	bc 01       	movw	r22, r24
    6b90:	cd 01       	movw	r24, r26
    6b92:	0e 94 65 04 	call	0x8ca	; 0x8ca <__floatunsisf>
    6b96:	9b 01       	movw	r18, r22
    6b98:	ac 01       	movw	r20, r24
    6b9a:	c8 01       	movw	r24, r16
    6b9c:	b7 01       	movw	r22, r14
    6b9e:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    6ba2:	dc 01       	movw	r26, r24
    6ba4:	cb 01       	movw	r24, r22
    6ba6:	bc 01       	movw	r22, r24
    6ba8:	cd 01       	movw	r24, r26
    6baa:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    6bae:	dc 01       	movw	r26, r24
    6bb0:	cb 01       	movw	r24, r22
    6bb2:	89 83       	std	Y+1, r24	; 0x01
    6bb4:	9a 83       	std	Y+2, r25	; 0x02
    6bb6:	ab 83       	std	Y+3, r26	; 0x03
    6bb8:	bc 83       	std	Y+4, r27	; 0x04
	OCR1A = actualDuty;
    6bba:	ea e4       	ldi	r30, 0x4A	; 74
    6bbc:	f0 e0       	ldi	r31, 0x00	; 0
    6bbe:	89 81       	ldd	r24, Y+1	; 0x01
    6bc0:	9a 81       	ldd	r25, Y+2	; 0x02
    6bc2:	91 83       	std	Z+1, r25	; 0x01
    6bc4:	80 83       	st	Z, r24
	OCR1B = actualDuty;
    6bc6:	e8 e4       	ldi	r30, 0x48	; 72
    6bc8:	f0 e0       	ldi	r31, 0x00	; 0
    6bca:	89 81       	ldd	r24, Y+1	; 0x01
    6bcc:	9a 81       	ldd	r25, Y+2	; 0x02
    6bce:	91 83       	std	Z+1, r25	; 0x01
    6bd0:	80 83       	st	Z, r24
}
    6bd2:	0f 90       	pop	r0
    6bd4:	0f 90       	pop	r0
    6bd6:	0f 90       	pop	r0
    6bd8:	0f 90       	pop	r0
    6bda:	0f 90       	pop	r0
    6bdc:	cf 91       	pop	r28
    6bde:	df 91       	pop	r29
    6be0:	1f 91       	pop	r17
    6be2:	0f 91       	pop	r16
    6be4:	ff 90       	pop	r15
    6be6:	ef 90       	pop	r14
    6be8:	08 95       	ret

00006bea <Get_Data>:
unsigned char rightBtn_counter = 0;
unsigned char leftBtn_counter = 0;


States_GroupType Get_Data(void)
{
    6bea:	df 93       	push	r29
    6bec:	cf 93       	push	r28
    6bee:	cd b7       	in	r28, 0x3d	; 61
    6bf0:	de b7       	in	r29, 0x3e	; 62

	static unsigned char hazardBtn_releaseFlag = TRUE;
	static States_GroupType ButtonState = {0,0,0,0};

	if(GPIO_readPin(dio_config_array[HAZARD_BUTTON_ID].port_id,dio_config_array[HAZARD_BUTTON_ID].pin_num) )
    6bf2:	80 91 34 02 	lds	r24, 0x0234
    6bf6:	90 91 35 02 	lds	r25, 0x0235
    6bfa:	69 2f       	mov	r22, r25
    6bfc:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6c00:	88 23       	and	r24, r24
    6c02:	51 f0       	breq	.+20     	; 0x6c18 <Get_Data+0x2e>
	{
		if(hazardBtn_releaseFlag == TRUE)
    6c04:	80 91 32 02 	lds	r24, 0x0232
    6c08:	81 30       	cpi	r24, 0x01	; 1
    6c0a:	59 f4       	brne	.+22     	; 0x6c22 <Get_Data+0x38>
		{
			hazardBtn_releaseFlag = FALSE;
    6c0c:	10 92 32 02 	sts	0x0232, r1
			ButtonState.hazard_Btn = TRUE;
    6c10:	81 e0       	ldi	r24, 0x01	; 1
    6c12:	80 93 e5 08 	sts	0x08E5, r24
    6c16:	05 c0       	rjmp	.+10     	; 0x6c22 <Get_Data+0x38>
		}
	}
	else{
		ButtonState.hazard_Btn = FALSE;
    6c18:	10 92 e5 08 	sts	0x08E5, r1

		hazardBtn_releaseFlag = TRUE;
    6c1c:	81 e0       	ldi	r24, 0x01	; 1
    6c1e:	80 93 32 02 	sts	0x0232, r24
	}



	if(!GPIO_readPin(dio_config_array[RIGHT_INDICATOR_BUTTON_ID].port_id,dio_config_array[RIGHT_INDICATOR_BUTTON_ID].pin_num) && !GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6c22:	80 91 37 02 	lds	r24, 0x0237
    6c26:	90 91 38 02 	lds	r25, 0x0238
    6c2a:	69 2f       	mov	r22, r25
    6c2c:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6c30:	88 23       	and	r24, r24
    6c32:	d9 f5       	brne	.+118    	; 0x6caa <Get_Data+0xc0>
    6c34:	80 91 3d 02 	lds	r24, 0x023D
    6c38:	90 91 3e 02 	lds	r25, 0x023E
    6c3c:	69 2f       	mov	r22, r25
    6c3e:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6c42:	88 23       	and	r24, r24
    6c44:	91 f5       	brne	.+100    	; 0x6caa <Get_Data+0xc0>

		rightBtn_counter++;
    6c46:	80 91 e0 08 	lds	r24, 0x08E0
    6c4a:	8f 5f       	subi	r24, 0xFF	; 255
    6c4c:	80 93 e0 08 	sts	0x08E0, r24
		if(rightBtn_counter % 5 == 0)
    6c50:	80 91 e0 08 	lds	r24, 0x08E0
    6c54:	95 e0       	ldi	r25, 0x05	; 5
    6c56:	69 2f       	mov	r22, r25
    6c58:	0e 94 e3 3d 	call	0x7bc6	; 0x7bc6 <__udivmodqi4>
    6c5c:	89 2f       	mov	r24, r25
    6c5e:	88 23       	and	r24, r24
    6c60:	09 f0       	breq	.+2      	; 0x6c64 <Get_Data+0x7a>
    6c62:	9c c0       	rjmp	.+312    	; 0x6d9c <Get_Data+0x1b2>
		{
		rightBtn_counter = 0u;
    6c64:	10 92 e0 08 	sts	0x08E0, r1
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6c68:	80 91 3d 02 	lds	r24, 0x023D
    6c6c:	90 91 3e 02 	lds	r25, 0x023E
    6c70:	69 2f       	mov	r22, r25
    6c72:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6c76:	88 23       	and	r24, r24
    6c78:	99 f4       	brne	.+38     	; 0x6ca0 <Get_Data+0xb6>
			ButtonState.ignition_key = 1;
    6c7a:	81 e0       	ldi	r24, 0x01	; 1
    6c7c:	80 93 e2 08 	sts	0x08E2, r24
			if(!GPIO_readPin(dio_config_array[RIGHT_INDICATOR_BUTTON_ID].port_id,dio_config_array[RIGHT_INDICATOR_BUTTON_ID].pin_num)){
    6c80:	80 91 37 02 	lds	r24, 0x0237
    6c84:	90 91 38 02 	lds	r25, 0x0238
    6c88:	69 2f       	mov	r22, r25
    6c8a:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6c8e:	88 23       	and	r24, r24
    6c90:	21 f4       	brne	.+8      	; 0x6c9a <Get_Data+0xb0>
				ButtonState.rightIndicator = 1;
    6c92:	81 e0       	ldi	r24, 0x01	; 1
    6c94:	80 93 e3 08 	sts	0x08E3, r24
    6c98:	81 c0       	rjmp	.+258    	; 0x6d9c <Get_Data+0x1b2>
			}
			else{
				ButtonState.rightIndicator = 0;
    6c9a:	10 92 e3 08 	sts	0x08E3, r1
    6c9e:	7e c0       	rjmp	.+252    	; 0x6d9c <Get_Data+0x1b2>
			}
		}
		else{
			ButtonState.ignition_key = 0;
    6ca0:	10 92 e2 08 	sts	0x08E2, r1
			ButtonState.rightIndicator = 0;
    6ca4:	10 92 e3 08 	sts	0x08E3, r1
    6ca8:	79 c0       	rjmp	.+242    	; 0x6d9c <Get_Data+0x1b2>
		}
		}

	}
	else if(!GPIO_readPin(dio_config_array[LEFT_INDICATOR_BUTTON_ID].port_id,dio_config_array[LEFT_INDICATOR_BUTTON_ID].pin_num) && !GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6caa:	80 91 3a 02 	lds	r24, 0x023A
    6cae:	90 91 3b 02 	lds	r25, 0x023B
    6cb2:	69 2f       	mov	r22, r25
    6cb4:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6cb8:	88 23       	and	r24, r24
    6cba:	d9 f5       	brne	.+118    	; 0x6d32 <Get_Data+0x148>
    6cbc:	80 91 3d 02 	lds	r24, 0x023D
    6cc0:	90 91 3e 02 	lds	r25, 0x023E
    6cc4:	69 2f       	mov	r22, r25
    6cc6:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6cca:	88 23       	and	r24, r24
    6ccc:	91 f5       	brne	.+100    	; 0x6d32 <Get_Data+0x148>
		leftBtn_counter++;
    6cce:	80 91 e1 08 	lds	r24, 0x08E1
    6cd2:	8f 5f       	subi	r24, 0xFF	; 255
    6cd4:	80 93 e1 08 	sts	0x08E1, r24
		if(leftBtn_counter % 5 == 0)
    6cd8:	80 91 e1 08 	lds	r24, 0x08E1
    6cdc:	95 e0       	ldi	r25, 0x05	; 5
    6cde:	69 2f       	mov	r22, r25
    6ce0:	0e 94 e3 3d 	call	0x7bc6	; 0x7bc6 <__udivmodqi4>
    6ce4:	89 2f       	mov	r24, r25
    6ce6:	88 23       	and	r24, r24
    6ce8:	09 f0       	breq	.+2      	; 0x6cec <Get_Data+0x102>
    6cea:	58 c0       	rjmp	.+176    	; 0x6d9c <Get_Data+0x1b2>
		{
			leftBtn_counter = 0;
    6cec:	10 92 e1 08 	sts	0x08E1, r1
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6cf0:	80 91 3d 02 	lds	r24, 0x023D
    6cf4:	90 91 3e 02 	lds	r25, 0x023E
    6cf8:	69 2f       	mov	r22, r25
    6cfa:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6cfe:	88 23       	and	r24, r24
    6d00:	99 f4       	brne	.+38     	; 0x6d28 <Get_Data+0x13e>
			ButtonState.ignition_key = 1;
    6d02:	81 e0       	ldi	r24, 0x01	; 1
    6d04:	80 93 e2 08 	sts	0x08E2, r24
			if(!GPIO_readPin(dio_config_array[LEFT_INDICATOR_BUTTON_ID].port_id,dio_config_array[LEFT_INDICATOR_BUTTON_ID].pin_num)){
    6d08:	80 91 3a 02 	lds	r24, 0x023A
    6d0c:	90 91 3b 02 	lds	r25, 0x023B
    6d10:	69 2f       	mov	r22, r25
    6d12:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6d16:	88 23       	and	r24, r24
    6d18:	21 f4       	brne	.+8      	; 0x6d22 <Get_Data+0x138>
				ButtonState.leftIndicator = 1;
    6d1a:	81 e0       	ldi	r24, 0x01	; 1
    6d1c:	80 93 e4 08 	sts	0x08E4, r24
    6d20:	3d c0       	rjmp	.+122    	; 0x6d9c <Get_Data+0x1b2>
			}
			else{
				ButtonState.leftIndicator = 0;
    6d22:	10 92 e4 08 	sts	0x08E4, r1
    6d26:	3a c0       	rjmp	.+116    	; 0x6d9c <Get_Data+0x1b2>
			}
		}
		else{
			ButtonState.ignition_key = 0;
    6d28:	10 92 e2 08 	sts	0x08E2, r1
			ButtonState.leftIndicator = 0;
    6d2c:	10 92 e4 08 	sts	0x08E4, r1
    6d30:	35 c0       	rjmp	.+106    	; 0x6d9c <Get_Data+0x1b2>
		}
		}
	}
	else if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6d32:	80 91 3d 02 	lds	r24, 0x023D
    6d36:	90 91 3e 02 	lds	r25, 0x023E
    6d3a:	69 2f       	mov	r22, r25
    6d3c:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6d40:	88 23       	and	r24, r24
    6d42:	31 f5       	brne	.+76     	; 0x6d90 <Get_Data+0x1a6>
		ignitionBtn_counter ++;
    6d44:	80 91 df 08 	lds	r24, 0x08DF
    6d48:	8f 5f       	subi	r24, 0xFF	; 255
    6d4a:	80 93 df 08 	sts	0x08DF, r24
		if(ignitionBtn_counter % 5 == 0)
    6d4e:	80 91 df 08 	lds	r24, 0x08DF
    6d52:	95 e0       	ldi	r25, 0x05	; 5
    6d54:	69 2f       	mov	r22, r25
    6d56:	0e 94 e3 3d 	call	0x7bc6	; 0x7bc6 <__udivmodqi4>
    6d5a:	89 2f       	mov	r24, r25
    6d5c:	88 23       	and	r24, r24
    6d5e:	f1 f4       	brne	.+60     	; 0x6d9c <Get_Data+0x1b2>
		{
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6d60:	80 91 3d 02 	lds	r24, 0x023D
    6d64:	90 91 3e 02 	lds	r25, 0x023E
    6d68:	69 2f       	mov	r22, r25
    6d6a:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    6d6e:	88 23       	and	r24, r24
    6d70:	41 f4       	brne	.+16     	; 0x6d82 <Get_Data+0x198>
			ButtonState.ignition_key = 1;
    6d72:	81 e0       	ldi	r24, 0x01	; 1
    6d74:	80 93 e2 08 	sts	0x08E2, r24
			ButtonState.rightIndicator = 0;
    6d78:	10 92 e3 08 	sts	0x08E3, r1
			ButtonState.leftIndicator = 0;
    6d7c:	10 92 e4 08 	sts	0x08E4, r1
    6d80:	0d c0       	rjmp	.+26     	; 0x6d9c <Get_Data+0x1b2>
		}
		else{
			ButtonState.ignition_key = 0;
    6d82:	10 92 e2 08 	sts	0x08E2, r1
			ButtonState.rightIndicator = 0;
    6d86:	10 92 e3 08 	sts	0x08E3, r1
			ButtonState.leftIndicator = 0;
    6d8a:	10 92 e4 08 	sts	0x08E4, r1
    6d8e:	06 c0       	rjmp	.+12     	; 0x6d9c <Get_Data+0x1b2>

		}
	}
	}
	else{
		ButtonState.ignition_key = 0u;
    6d90:	10 92 e2 08 	sts	0x08E2, r1
		ButtonState.rightIndicator = 0u;
    6d94:	10 92 e3 08 	sts	0x08E3, r1
		ButtonState.leftIndicator = 0u;
    6d98:	10 92 e4 08 	sts	0x08E4, r1
	}

	return ButtonState;
    6d9c:	80 91 e2 08 	lds	r24, 0x08E2
    6da0:	90 91 e3 08 	lds	r25, 0x08E3
    6da4:	a0 91 e4 08 	lds	r26, 0x08E4
    6da8:	b0 91 e5 08 	lds	r27, 0x08E5
}
    6dac:	bc 01       	movw	r22, r24
    6dae:	cd 01       	movw	r24, r26
    6db0:	cf 91       	pop	r28
    6db2:	df 91       	pop	r29
    6db4:	08 95       	ret

00006db6 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    6db6:	df 93       	push	r29
    6db8:	cf 93       	push	r28
    6dba:	00 d0       	rcall	.+0      	; 0x6dbc <GPIO_setupPinDirection+0x6>
    6dbc:	00 d0       	rcall	.+0      	; 0x6dbe <GPIO_setupPinDirection+0x8>
    6dbe:	0f 92       	push	r0
    6dc0:	cd b7       	in	r28, 0x3d	; 61
    6dc2:	de b7       	in	r29, 0x3e	; 62
    6dc4:	89 83       	std	Y+1, r24	; 0x01
    6dc6:	6a 83       	std	Y+2, r22	; 0x02
    6dc8:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    6dca:	8a 81       	ldd	r24, Y+2	; 0x02
    6dcc:	88 30       	cpi	r24, 0x08	; 8
    6dce:	08 f0       	brcs	.+2      	; 0x6dd2 <GPIO_setupPinDirection+0x1c>
    6dd0:	39 c1       	rjmp	.+626    	; 0x7044 <GPIO_setupPinDirection+0x28e>
    6dd2:	89 81       	ldd	r24, Y+1	; 0x01
    6dd4:	86 30       	cpi	r24, 0x06	; 6
    6dd6:	08 f0       	brcs	.+2      	; 0x6dda <GPIO_setupPinDirection+0x24>
    6dd8:	35 c1       	rjmp	.+618    	; 0x7044 <GPIO_setupPinDirection+0x28e>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    6dda:	89 81       	ldd	r24, Y+1	; 0x01
    6ddc:	28 2f       	mov	r18, r24
    6dde:	30 e0       	ldi	r19, 0x00	; 0
    6de0:	3d 83       	std	Y+5, r19	; 0x05
    6de2:	2c 83       	std	Y+4, r18	; 0x04
    6de4:	8c 81       	ldd	r24, Y+4	; 0x04
    6de6:	9d 81       	ldd	r25, Y+5	; 0x05
    6de8:	82 30       	cpi	r24, 0x02	; 2
    6dea:	91 05       	cpc	r25, r1
    6dec:	09 f4       	brne	.+2      	; 0x6df0 <GPIO_setupPinDirection+0x3a>
    6dee:	7b c0       	rjmp	.+246    	; 0x6ee6 <GPIO_setupPinDirection+0x130>
    6df0:	2c 81       	ldd	r18, Y+4	; 0x04
    6df2:	3d 81       	ldd	r19, Y+5	; 0x05
    6df4:	23 30       	cpi	r18, 0x03	; 3
    6df6:	31 05       	cpc	r19, r1
    6df8:	5c f4       	brge	.+22     	; 0x6e10 <GPIO_setupPinDirection+0x5a>
    6dfa:	8c 81       	ldd	r24, Y+4	; 0x04
    6dfc:	9d 81       	ldd	r25, Y+5	; 0x05
    6dfe:	00 97       	sbiw	r24, 0x00	; 0
    6e00:	d1 f0       	breq	.+52     	; 0x6e36 <GPIO_setupPinDirection+0x80>
    6e02:	2c 81       	ldd	r18, Y+4	; 0x04
    6e04:	3d 81       	ldd	r19, Y+5	; 0x05
    6e06:	21 30       	cpi	r18, 0x01	; 1
    6e08:	31 05       	cpc	r19, r1
    6e0a:	09 f4       	brne	.+2      	; 0x6e0e <GPIO_setupPinDirection+0x58>
    6e0c:	40 c0       	rjmp	.+128    	; 0x6e8e <GPIO_setupPinDirection+0xd8>
    6e0e:	1a c1       	rjmp	.+564    	; 0x7044 <GPIO_setupPinDirection+0x28e>
    6e10:	8c 81       	ldd	r24, Y+4	; 0x04
    6e12:	9d 81       	ldd	r25, Y+5	; 0x05
    6e14:	84 30       	cpi	r24, 0x04	; 4
    6e16:	91 05       	cpc	r25, r1
    6e18:	09 f4       	brne	.+2      	; 0x6e1c <GPIO_setupPinDirection+0x66>
    6e1a:	bd c0       	rjmp	.+378    	; 0x6f96 <GPIO_setupPinDirection+0x1e0>
    6e1c:	2c 81       	ldd	r18, Y+4	; 0x04
    6e1e:	3d 81       	ldd	r19, Y+5	; 0x05
    6e20:	24 30       	cpi	r18, 0x04	; 4
    6e22:	31 05       	cpc	r19, r1
    6e24:	0c f4       	brge	.+2      	; 0x6e28 <GPIO_setupPinDirection+0x72>
    6e26:	8b c0       	rjmp	.+278    	; 0x6f3e <GPIO_setupPinDirection+0x188>
    6e28:	8c 81       	ldd	r24, Y+4	; 0x04
    6e2a:	9d 81       	ldd	r25, Y+5	; 0x05
    6e2c:	85 30       	cpi	r24, 0x05	; 5
    6e2e:	91 05       	cpc	r25, r1
    6e30:	09 f4       	brne	.+2      	; 0x6e34 <GPIO_setupPinDirection+0x7e>
    6e32:	dd c0       	rjmp	.+442    	; 0x6fee <GPIO_setupPinDirection+0x238>
    6e34:	07 c1       	rjmp	.+526    	; 0x7044 <GPIO_setupPinDirection+0x28e>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    6e36:	8b 81       	ldd	r24, Y+3	; 0x03
    6e38:	81 30       	cpi	r24, 0x01	; 1
    6e3a:	a1 f4       	brne	.+40     	; 0x6e64 <GPIO_setupPinDirection+0xae>
			{
				SET_BIT(DDRA,pin_num);
    6e3c:	aa e3       	ldi	r26, 0x3A	; 58
    6e3e:	b0 e0       	ldi	r27, 0x00	; 0
    6e40:	ea e3       	ldi	r30, 0x3A	; 58
    6e42:	f0 e0       	ldi	r31, 0x00	; 0
    6e44:	80 81       	ld	r24, Z
    6e46:	48 2f       	mov	r20, r24
    6e48:	8a 81       	ldd	r24, Y+2	; 0x02
    6e4a:	28 2f       	mov	r18, r24
    6e4c:	30 e0       	ldi	r19, 0x00	; 0
    6e4e:	81 e0       	ldi	r24, 0x01	; 1
    6e50:	90 e0       	ldi	r25, 0x00	; 0
    6e52:	02 2e       	mov	r0, r18
    6e54:	02 c0       	rjmp	.+4      	; 0x6e5a <GPIO_setupPinDirection+0xa4>
    6e56:	88 0f       	add	r24, r24
    6e58:	99 1f       	adc	r25, r25
    6e5a:	0a 94       	dec	r0
    6e5c:	e2 f7       	brpl	.-8      	; 0x6e56 <GPIO_setupPinDirection+0xa0>
    6e5e:	84 2b       	or	r24, r20
    6e60:	8c 93       	st	X, r24
    6e62:	f0 c0       	rjmp	.+480    	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    6e64:	aa e3       	ldi	r26, 0x3A	; 58
    6e66:	b0 e0       	ldi	r27, 0x00	; 0
    6e68:	ea e3       	ldi	r30, 0x3A	; 58
    6e6a:	f0 e0       	ldi	r31, 0x00	; 0
    6e6c:	80 81       	ld	r24, Z
    6e6e:	48 2f       	mov	r20, r24
    6e70:	8a 81       	ldd	r24, Y+2	; 0x02
    6e72:	28 2f       	mov	r18, r24
    6e74:	30 e0       	ldi	r19, 0x00	; 0
    6e76:	81 e0       	ldi	r24, 0x01	; 1
    6e78:	90 e0       	ldi	r25, 0x00	; 0
    6e7a:	02 2e       	mov	r0, r18
    6e7c:	02 c0       	rjmp	.+4      	; 0x6e82 <GPIO_setupPinDirection+0xcc>
    6e7e:	88 0f       	add	r24, r24
    6e80:	99 1f       	adc	r25, r25
    6e82:	0a 94       	dec	r0
    6e84:	e2 f7       	brpl	.-8      	; 0x6e7e <GPIO_setupPinDirection+0xc8>
    6e86:	80 95       	com	r24
    6e88:	84 23       	and	r24, r20
    6e8a:	8c 93       	st	X, r24
    6e8c:	db c0       	rjmp	.+438    	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    6e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    6e90:	81 30       	cpi	r24, 0x01	; 1
    6e92:	a1 f4       	brne	.+40     	; 0x6ebc <GPIO_setupPinDirection+0x106>
			{
				SET_BIT(DDRB,pin_num);
    6e94:	a7 e3       	ldi	r26, 0x37	; 55
    6e96:	b0 e0       	ldi	r27, 0x00	; 0
    6e98:	e7 e3       	ldi	r30, 0x37	; 55
    6e9a:	f0 e0       	ldi	r31, 0x00	; 0
    6e9c:	80 81       	ld	r24, Z
    6e9e:	48 2f       	mov	r20, r24
    6ea0:	8a 81       	ldd	r24, Y+2	; 0x02
    6ea2:	28 2f       	mov	r18, r24
    6ea4:	30 e0       	ldi	r19, 0x00	; 0
    6ea6:	81 e0       	ldi	r24, 0x01	; 1
    6ea8:	90 e0       	ldi	r25, 0x00	; 0
    6eaa:	02 2e       	mov	r0, r18
    6eac:	02 c0       	rjmp	.+4      	; 0x6eb2 <GPIO_setupPinDirection+0xfc>
    6eae:	88 0f       	add	r24, r24
    6eb0:	99 1f       	adc	r25, r25
    6eb2:	0a 94       	dec	r0
    6eb4:	e2 f7       	brpl	.-8      	; 0x6eae <GPIO_setupPinDirection+0xf8>
    6eb6:	84 2b       	or	r24, r20
    6eb8:	8c 93       	st	X, r24
    6eba:	c4 c0       	rjmp	.+392    	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    6ebc:	a7 e3       	ldi	r26, 0x37	; 55
    6ebe:	b0 e0       	ldi	r27, 0x00	; 0
    6ec0:	e7 e3       	ldi	r30, 0x37	; 55
    6ec2:	f0 e0       	ldi	r31, 0x00	; 0
    6ec4:	80 81       	ld	r24, Z
    6ec6:	48 2f       	mov	r20, r24
    6ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    6eca:	28 2f       	mov	r18, r24
    6ecc:	30 e0       	ldi	r19, 0x00	; 0
    6ece:	81 e0       	ldi	r24, 0x01	; 1
    6ed0:	90 e0       	ldi	r25, 0x00	; 0
    6ed2:	02 2e       	mov	r0, r18
    6ed4:	02 c0       	rjmp	.+4      	; 0x6eda <GPIO_setupPinDirection+0x124>
    6ed6:	88 0f       	add	r24, r24
    6ed8:	99 1f       	adc	r25, r25
    6eda:	0a 94       	dec	r0
    6edc:	e2 f7       	brpl	.-8      	; 0x6ed6 <GPIO_setupPinDirection+0x120>
    6ede:	80 95       	com	r24
    6ee0:	84 23       	and	r24, r20
    6ee2:	8c 93       	st	X, r24
    6ee4:	af c0       	rjmp	.+350    	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    6ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    6ee8:	81 30       	cpi	r24, 0x01	; 1
    6eea:	a1 f4       	brne	.+40     	; 0x6f14 <GPIO_setupPinDirection+0x15e>
			{
				SET_BIT(DDRC,pin_num);
    6eec:	a4 e3       	ldi	r26, 0x34	; 52
    6eee:	b0 e0       	ldi	r27, 0x00	; 0
    6ef0:	e4 e3       	ldi	r30, 0x34	; 52
    6ef2:	f0 e0       	ldi	r31, 0x00	; 0
    6ef4:	80 81       	ld	r24, Z
    6ef6:	48 2f       	mov	r20, r24
    6ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    6efa:	28 2f       	mov	r18, r24
    6efc:	30 e0       	ldi	r19, 0x00	; 0
    6efe:	81 e0       	ldi	r24, 0x01	; 1
    6f00:	90 e0       	ldi	r25, 0x00	; 0
    6f02:	02 2e       	mov	r0, r18
    6f04:	02 c0       	rjmp	.+4      	; 0x6f0a <GPIO_setupPinDirection+0x154>
    6f06:	88 0f       	add	r24, r24
    6f08:	99 1f       	adc	r25, r25
    6f0a:	0a 94       	dec	r0
    6f0c:	e2 f7       	brpl	.-8      	; 0x6f06 <GPIO_setupPinDirection+0x150>
    6f0e:	84 2b       	or	r24, r20
    6f10:	8c 93       	st	X, r24
    6f12:	98 c0       	rjmp	.+304    	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    6f14:	a4 e3       	ldi	r26, 0x34	; 52
    6f16:	b0 e0       	ldi	r27, 0x00	; 0
    6f18:	e4 e3       	ldi	r30, 0x34	; 52
    6f1a:	f0 e0       	ldi	r31, 0x00	; 0
    6f1c:	80 81       	ld	r24, Z
    6f1e:	48 2f       	mov	r20, r24
    6f20:	8a 81       	ldd	r24, Y+2	; 0x02
    6f22:	28 2f       	mov	r18, r24
    6f24:	30 e0       	ldi	r19, 0x00	; 0
    6f26:	81 e0       	ldi	r24, 0x01	; 1
    6f28:	90 e0       	ldi	r25, 0x00	; 0
    6f2a:	02 2e       	mov	r0, r18
    6f2c:	02 c0       	rjmp	.+4      	; 0x6f32 <GPIO_setupPinDirection+0x17c>
    6f2e:	88 0f       	add	r24, r24
    6f30:	99 1f       	adc	r25, r25
    6f32:	0a 94       	dec	r0
    6f34:	e2 f7       	brpl	.-8      	; 0x6f2e <GPIO_setupPinDirection+0x178>
    6f36:	80 95       	com	r24
    6f38:	84 23       	and	r24, r20
    6f3a:	8c 93       	st	X, r24
    6f3c:	83 c0       	rjmp	.+262    	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    6f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    6f40:	81 30       	cpi	r24, 0x01	; 1
    6f42:	a1 f4       	brne	.+40     	; 0x6f6c <GPIO_setupPinDirection+0x1b6>
			{
				SET_BIT(DDRD,pin_num);
    6f44:	a1 e3       	ldi	r26, 0x31	; 49
    6f46:	b0 e0       	ldi	r27, 0x00	; 0
    6f48:	e1 e3       	ldi	r30, 0x31	; 49
    6f4a:	f0 e0       	ldi	r31, 0x00	; 0
    6f4c:	80 81       	ld	r24, Z
    6f4e:	48 2f       	mov	r20, r24
    6f50:	8a 81       	ldd	r24, Y+2	; 0x02
    6f52:	28 2f       	mov	r18, r24
    6f54:	30 e0       	ldi	r19, 0x00	; 0
    6f56:	81 e0       	ldi	r24, 0x01	; 1
    6f58:	90 e0       	ldi	r25, 0x00	; 0
    6f5a:	02 2e       	mov	r0, r18
    6f5c:	02 c0       	rjmp	.+4      	; 0x6f62 <GPIO_setupPinDirection+0x1ac>
    6f5e:	88 0f       	add	r24, r24
    6f60:	99 1f       	adc	r25, r25
    6f62:	0a 94       	dec	r0
    6f64:	e2 f7       	brpl	.-8      	; 0x6f5e <GPIO_setupPinDirection+0x1a8>
    6f66:	84 2b       	or	r24, r20
    6f68:	8c 93       	st	X, r24
    6f6a:	6c c0       	rjmp	.+216    	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    6f6c:	a1 e3       	ldi	r26, 0x31	; 49
    6f6e:	b0 e0       	ldi	r27, 0x00	; 0
    6f70:	e1 e3       	ldi	r30, 0x31	; 49
    6f72:	f0 e0       	ldi	r31, 0x00	; 0
    6f74:	80 81       	ld	r24, Z
    6f76:	48 2f       	mov	r20, r24
    6f78:	8a 81       	ldd	r24, Y+2	; 0x02
    6f7a:	28 2f       	mov	r18, r24
    6f7c:	30 e0       	ldi	r19, 0x00	; 0
    6f7e:	81 e0       	ldi	r24, 0x01	; 1
    6f80:	90 e0       	ldi	r25, 0x00	; 0
    6f82:	02 2e       	mov	r0, r18
    6f84:	02 c0       	rjmp	.+4      	; 0x6f8a <GPIO_setupPinDirection+0x1d4>
    6f86:	88 0f       	add	r24, r24
    6f88:	99 1f       	adc	r25, r25
    6f8a:	0a 94       	dec	r0
    6f8c:	e2 f7       	brpl	.-8      	; 0x6f86 <GPIO_setupPinDirection+0x1d0>
    6f8e:	80 95       	com	r24
    6f90:	84 23       	and	r24, r20
    6f92:	8c 93       	st	X, r24
    6f94:	57 c0       	rjmp	.+174    	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTE_ID:
			if(direction == PIN_OUTPUT)
    6f96:	8b 81       	ldd	r24, Y+3	; 0x03
    6f98:	81 30       	cpi	r24, 0x01	; 1
    6f9a:	a1 f4       	brne	.+40     	; 0x6fc4 <GPIO_setupPinDirection+0x20e>
			{
				SET_BIT(DDRE,pin_num);
    6f9c:	a2 e2       	ldi	r26, 0x22	; 34
    6f9e:	b0 e0       	ldi	r27, 0x00	; 0
    6fa0:	e2 e2       	ldi	r30, 0x22	; 34
    6fa2:	f0 e0       	ldi	r31, 0x00	; 0
    6fa4:	80 81       	ld	r24, Z
    6fa6:	48 2f       	mov	r20, r24
    6fa8:	8a 81       	ldd	r24, Y+2	; 0x02
    6faa:	28 2f       	mov	r18, r24
    6fac:	30 e0       	ldi	r19, 0x00	; 0
    6fae:	81 e0       	ldi	r24, 0x01	; 1
    6fb0:	90 e0       	ldi	r25, 0x00	; 0
    6fb2:	02 2e       	mov	r0, r18
    6fb4:	02 c0       	rjmp	.+4      	; 0x6fba <GPIO_setupPinDirection+0x204>
    6fb6:	88 0f       	add	r24, r24
    6fb8:	99 1f       	adc	r25, r25
    6fba:	0a 94       	dec	r0
    6fbc:	e2 f7       	brpl	.-8      	; 0x6fb6 <GPIO_setupPinDirection+0x200>
    6fbe:	84 2b       	or	r24, r20
    6fc0:	8c 93       	st	X, r24
    6fc2:	40 c0       	rjmp	.+128    	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRE,pin_num);
    6fc4:	a2 e2       	ldi	r26, 0x22	; 34
    6fc6:	b0 e0       	ldi	r27, 0x00	; 0
    6fc8:	e2 e2       	ldi	r30, 0x22	; 34
    6fca:	f0 e0       	ldi	r31, 0x00	; 0
    6fcc:	80 81       	ld	r24, Z
    6fce:	48 2f       	mov	r20, r24
    6fd0:	8a 81       	ldd	r24, Y+2	; 0x02
    6fd2:	28 2f       	mov	r18, r24
    6fd4:	30 e0       	ldi	r19, 0x00	; 0
    6fd6:	81 e0       	ldi	r24, 0x01	; 1
    6fd8:	90 e0       	ldi	r25, 0x00	; 0
    6fda:	02 2e       	mov	r0, r18
    6fdc:	02 c0       	rjmp	.+4      	; 0x6fe2 <GPIO_setupPinDirection+0x22c>
    6fde:	88 0f       	add	r24, r24
    6fe0:	99 1f       	adc	r25, r25
    6fe2:	0a 94       	dec	r0
    6fe4:	e2 f7       	brpl	.-8      	; 0x6fde <GPIO_setupPinDirection+0x228>
    6fe6:	80 95       	com	r24
    6fe8:	84 23       	and	r24, r20
    6fea:	8c 93       	st	X, r24
    6fec:	2b c0       	rjmp	.+86     	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTF_ID:
			if(direction == PIN_OUTPUT)
    6fee:	8b 81       	ldd	r24, Y+3	; 0x03
    6ff0:	81 30       	cpi	r24, 0x01	; 1
    6ff2:	a1 f4       	brne	.+40     	; 0x701c <GPIO_setupPinDirection+0x266>
			{
				SET_BIT(DDRF,pin_num);
    6ff4:	a1 e6       	ldi	r26, 0x61	; 97
    6ff6:	b0 e0       	ldi	r27, 0x00	; 0
    6ff8:	e1 e6       	ldi	r30, 0x61	; 97
    6ffa:	f0 e0       	ldi	r31, 0x00	; 0
    6ffc:	80 81       	ld	r24, Z
    6ffe:	48 2f       	mov	r20, r24
    7000:	8a 81       	ldd	r24, Y+2	; 0x02
    7002:	28 2f       	mov	r18, r24
    7004:	30 e0       	ldi	r19, 0x00	; 0
    7006:	81 e0       	ldi	r24, 0x01	; 1
    7008:	90 e0       	ldi	r25, 0x00	; 0
    700a:	02 2e       	mov	r0, r18
    700c:	02 c0       	rjmp	.+4      	; 0x7012 <GPIO_setupPinDirection+0x25c>
    700e:	88 0f       	add	r24, r24
    7010:	99 1f       	adc	r25, r25
    7012:	0a 94       	dec	r0
    7014:	e2 f7       	brpl	.-8      	; 0x700e <GPIO_setupPinDirection+0x258>
    7016:	84 2b       	or	r24, r20
    7018:	8c 93       	st	X, r24
    701a:	14 c0       	rjmp	.+40     	; 0x7044 <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRF,pin_num);
    701c:	a1 e6       	ldi	r26, 0x61	; 97
    701e:	b0 e0       	ldi	r27, 0x00	; 0
    7020:	e1 e6       	ldi	r30, 0x61	; 97
    7022:	f0 e0       	ldi	r31, 0x00	; 0
    7024:	80 81       	ld	r24, Z
    7026:	48 2f       	mov	r20, r24
    7028:	8a 81       	ldd	r24, Y+2	; 0x02
    702a:	28 2f       	mov	r18, r24
    702c:	30 e0       	ldi	r19, 0x00	; 0
    702e:	81 e0       	ldi	r24, 0x01	; 1
    7030:	90 e0       	ldi	r25, 0x00	; 0
    7032:	02 2e       	mov	r0, r18
    7034:	02 c0       	rjmp	.+4      	; 0x703a <GPIO_setupPinDirection+0x284>
    7036:	88 0f       	add	r24, r24
    7038:	99 1f       	adc	r25, r25
    703a:	0a 94       	dec	r0
    703c:	e2 f7       	brpl	.-8      	; 0x7036 <GPIO_setupPinDirection+0x280>
    703e:	80 95       	com	r24
    7040:	84 23       	and	r24, r20
    7042:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    7044:	0f 90       	pop	r0
    7046:	0f 90       	pop	r0
    7048:	0f 90       	pop	r0
    704a:	0f 90       	pop	r0
    704c:	0f 90       	pop	r0
    704e:	cf 91       	pop	r28
    7050:	df 91       	pop	r29
    7052:	08 95       	ret

00007054 <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    7054:	df 93       	push	r29
    7056:	cf 93       	push	r28
    7058:	00 d0       	rcall	.+0      	; 0x705a <GPIO_writePin+0x6>
    705a:	00 d0       	rcall	.+0      	; 0x705c <GPIO_writePin+0x8>
    705c:	0f 92       	push	r0
    705e:	cd b7       	in	r28, 0x3d	; 61
    7060:	de b7       	in	r29, 0x3e	; 62
    7062:	89 83       	std	Y+1, r24	; 0x01
    7064:	6a 83       	std	Y+2, r22	; 0x02
    7066:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    7068:	8a 81       	ldd	r24, Y+2	; 0x02
    706a:	88 30       	cpi	r24, 0x08	; 8
    706c:	08 f0       	brcs	.+2      	; 0x7070 <GPIO_writePin+0x1c>
    706e:	39 c1       	rjmp	.+626    	; 0x72e2 <GPIO_writePin+0x28e>
    7070:	89 81       	ldd	r24, Y+1	; 0x01
    7072:	86 30       	cpi	r24, 0x06	; 6
    7074:	08 f0       	brcs	.+2      	; 0x7078 <GPIO_writePin+0x24>
    7076:	35 c1       	rjmp	.+618    	; 0x72e2 <GPIO_writePin+0x28e>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    7078:	89 81       	ldd	r24, Y+1	; 0x01
    707a:	28 2f       	mov	r18, r24
    707c:	30 e0       	ldi	r19, 0x00	; 0
    707e:	3d 83       	std	Y+5, r19	; 0x05
    7080:	2c 83       	std	Y+4, r18	; 0x04
    7082:	8c 81       	ldd	r24, Y+4	; 0x04
    7084:	9d 81       	ldd	r25, Y+5	; 0x05
    7086:	82 30       	cpi	r24, 0x02	; 2
    7088:	91 05       	cpc	r25, r1
    708a:	09 f4       	brne	.+2      	; 0x708e <GPIO_writePin+0x3a>
    708c:	7b c0       	rjmp	.+246    	; 0x7184 <GPIO_writePin+0x130>
    708e:	2c 81       	ldd	r18, Y+4	; 0x04
    7090:	3d 81       	ldd	r19, Y+5	; 0x05
    7092:	23 30       	cpi	r18, 0x03	; 3
    7094:	31 05       	cpc	r19, r1
    7096:	5c f4       	brge	.+22     	; 0x70ae <GPIO_writePin+0x5a>
    7098:	8c 81       	ldd	r24, Y+4	; 0x04
    709a:	9d 81       	ldd	r25, Y+5	; 0x05
    709c:	00 97       	sbiw	r24, 0x00	; 0
    709e:	d1 f0       	breq	.+52     	; 0x70d4 <GPIO_writePin+0x80>
    70a0:	2c 81       	ldd	r18, Y+4	; 0x04
    70a2:	3d 81       	ldd	r19, Y+5	; 0x05
    70a4:	21 30       	cpi	r18, 0x01	; 1
    70a6:	31 05       	cpc	r19, r1
    70a8:	09 f4       	brne	.+2      	; 0x70ac <GPIO_writePin+0x58>
    70aa:	40 c0       	rjmp	.+128    	; 0x712c <GPIO_writePin+0xd8>
    70ac:	1a c1       	rjmp	.+564    	; 0x72e2 <GPIO_writePin+0x28e>
    70ae:	8c 81       	ldd	r24, Y+4	; 0x04
    70b0:	9d 81       	ldd	r25, Y+5	; 0x05
    70b2:	84 30       	cpi	r24, 0x04	; 4
    70b4:	91 05       	cpc	r25, r1
    70b6:	09 f4       	brne	.+2      	; 0x70ba <GPIO_writePin+0x66>
    70b8:	bd c0       	rjmp	.+378    	; 0x7234 <GPIO_writePin+0x1e0>
    70ba:	2c 81       	ldd	r18, Y+4	; 0x04
    70bc:	3d 81       	ldd	r19, Y+5	; 0x05
    70be:	24 30       	cpi	r18, 0x04	; 4
    70c0:	31 05       	cpc	r19, r1
    70c2:	0c f4       	brge	.+2      	; 0x70c6 <GPIO_writePin+0x72>
    70c4:	8b c0       	rjmp	.+278    	; 0x71dc <GPIO_writePin+0x188>
    70c6:	8c 81       	ldd	r24, Y+4	; 0x04
    70c8:	9d 81       	ldd	r25, Y+5	; 0x05
    70ca:	85 30       	cpi	r24, 0x05	; 5
    70cc:	91 05       	cpc	r25, r1
    70ce:	09 f4       	brne	.+2      	; 0x70d2 <GPIO_writePin+0x7e>
    70d0:	dd c0       	rjmp	.+442    	; 0x728c <GPIO_writePin+0x238>
    70d2:	07 c1       	rjmp	.+526    	; 0x72e2 <GPIO_writePin+0x28e>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    70d4:	8b 81       	ldd	r24, Y+3	; 0x03
    70d6:	81 30       	cpi	r24, 0x01	; 1
    70d8:	a1 f4       	brne	.+40     	; 0x7102 <GPIO_writePin+0xae>
			{
				SET_BIT(PORTA,pin_num);
    70da:	ab e3       	ldi	r26, 0x3B	; 59
    70dc:	b0 e0       	ldi	r27, 0x00	; 0
    70de:	eb e3       	ldi	r30, 0x3B	; 59
    70e0:	f0 e0       	ldi	r31, 0x00	; 0
    70e2:	80 81       	ld	r24, Z
    70e4:	48 2f       	mov	r20, r24
    70e6:	8a 81       	ldd	r24, Y+2	; 0x02
    70e8:	28 2f       	mov	r18, r24
    70ea:	30 e0       	ldi	r19, 0x00	; 0
    70ec:	81 e0       	ldi	r24, 0x01	; 1
    70ee:	90 e0       	ldi	r25, 0x00	; 0
    70f0:	02 2e       	mov	r0, r18
    70f2:	02 c0       	rjmp	.+4      	; 0x70f8 <GPIO_writePin+0xa4>
    70f4:	88 0f       	add	r24, r24
    70f6:	99 1f       	adc	r25, r25
    70f8:	0a 94       	dec	r0
    70fa:	e2 f7       	brpl	.-8      	; 0x70f4 <GPIO_writePin+0xa0>
    70fc:	84 2b       	or	r24, r20
    70fe:	8c 93       	st	X, r24
    7100:	f0 c0       	rjmp	.+480    	; 0x72e2 <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    7102:	ab e3       	ldi	r26, 0x3B	; 59
    7104:	b0 e0       	ldi	r27, 0x00	; 0
    7106:	eb e3       	ldi	r30, 0x3B	; 59
    7108:	f0 e0       	ldi	r31, 0x00	; 0
    710a:	80 81       	ld	r24, Z
    710c:	48 2f       	mov	r20, r24
    710e:	8a 81       	ldd	r24, Y+2	; 0x02
    7110:	28 2f       	mov	r18, r24
    7112:	30 e0       	ldi	r19, 0x00	; 0
    7114:	81 e0       	ldi	r24, 0x01	; 1
    7116:	90 e0       	ldi	r25, 0x00	; 0
    7118:	02 2e       	mov	r0, r18
    711a:	02 c0       	rjmp	.+4      	; 0x7120 <GPIO_writePin+0xcc>
    711c:	88 0f       	add	r24, r24
    711e:	99 1f       	adc	r25, r25
    7120:	0a 94       	dec	r0
    7122:	e2 f7       	brpl	.-8      	; 0x711c <GPIO_writePin+0xc8>
    7124:	80 95       	com	r24
    7126:	84 23       	and	r24, r20
    7128:	8c 93       	st	X, r24
    712a:	db c0       	rjmp	.+438    	; 0x72e2 <GPIO_writePin+0x28e>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    712c:	8b 81       	ldd	r24, Y+3	; 0x03
    712e:	81 30       	cpi	r24, 0x01	; 1
    7130:	a1 f4       	brne	.+40     	; 0x715a <GPIO_writePin+0x106>
			{
				SET_BIT(PORTB,pin_num);
    7132:	a8 e3       	ldi	r26, 0x38	; 56
    7134:	b0 e0       	ldi	r27, 0x00	; 0
    7136:	e8 e3       	ldi	r30, 0x38	; 56
    7138:	f0 e0       	ldi	r31, 0x00	; 0
    713a:	80 81       	ld	r24, Z
    713c:	48 2f       	mov	r20, r24
    713e:	8a 81       	ldd	r24, Y+2	; 0x02
    7140:	28 2f       	mov	r18, r24
    7142:	30 e0       	ldi	r19, 0x00	; 0
    7144:	81 e0       	ldi	r24, 0x01	; 1
    7146:	90 e0       	ldi	r25, 0x00	; 0
    7148:	02 2e       	mov	r0, r18
    714a:	02 c0       	rjmp	.+4      	; 0x7150 <GPIO_writePin+0xfc>
    714c:	88 0f       	add	r24, r24
    714e:	99 1f       	adc	r25, r25
    7150:	0a 94       	dec	r0
    7152:	e2 f7       	brpl	.-8      	; 0x714c <GPIO_writePin+0xf8>
    7154:	84 2b       	or	r24, r20
    7156:	8c 93       	st	X, r24
    7158:	c4 c0       	rjmp	.+392    	; 0x72e2 <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    715a:	a8 e3       	ldi	r26, 0x38	; 56
    715c:	b0 e0       	ldi	r27, 0x00	; 0
    715e:	e8 e3       	ldi	r30, 0x38	; 56
    7160:	f0 e0       	ldi	r31, 0x00	; 0
    7162:	80 81       	ld	r24, Z
    7164:	48 2f       	mov	r20, r24
    7166:	8a 81       	ldd	r24, Y+2	; 0x02
    7168:	28 2f       	mov	r18, r24
    716a:	30 e0       	ldi	r19, 0x00	; 0
    716c:	81 e0       	ldi	r24, 0x01	; 1
    716e:	90 e0       	ldi	r25, 0x00	; 0
    7170:	02 2e       	mov	r0, r18
    7172:	02 c0       	rjmp	.+4      	; 0x7178 <GPIO_writePin+0x124>
    7174:	88 0f       	add	r24, r24
    7176:	99 1f       	adc	r25, r25
    7178:	0a 94       	dec	r0
    717a:	e2 f7       	brpl	.-8      	; 0x7174 <GPIO_writePin+0x120>
    717c:	80 95       	com	r24
    717e:	84 23       	and	r24, r20
    7180:	8c 93       	st	X, r24
    7182:	af c0       	rjmp	.+350    	; 0x72e2 <GPIO_writePin+0x28e>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    7184:	8b 81       	ldd	r24, Y+3	; 0x03
    7186:	81 30       	cpi	r24, 0x01	; 1
    7188:	a1 f4       	brne	.+40     	; 0x71b2 <GPIO_writePin+0x15e>
			{
				SET_BIT(PORTC,pin_num);
    718a:	a5 e3       	ldi	r26, 0x35	; 53
    718c:	b0 e0       	ldi	r27, 0x00	; 0
    718e:	e5 e3       	ldi	r30, 0x35	; 53
    7190:	f0 e0       	ldi	r31, 0x00	; 0
    7192:	80 81       	ld	r24, Z
    7194:	48 2f       	mov	r20, r24
    7196:	8a 81       	ldd	r24, Y+2	; 0x02
    7198:	28 2f       	mov	r18, r24
    719a:	30 e0       	ldi	r19, 0x00	; 0
    719c:	81 e0       	ldi	r24, 0x01	; 1
    719e:	90 e0       	ldi	r25, 0x00	; 0
    71a0:	02 2e       	mov	r0, r18
    71a2:	02 c0       	rjmp	.+4      	; 0x71a8 <GPIO_writePin+0x154>
    71a4:	88 0f       	add	r24, r24
    71a6:	99 1f       	adc	r25, r25
    71a8:	0a 94       	dec	r0
    71aa:	e2 f7       	brpl	.-8      	; 0x71a4 <GPIO_writePin+0x150>
    71ac:	84 2b       	or	r24, r20
    71ae:	8c 93       	st	X, r24
    71b0:	98 c0       	rjmp	.+304    	; 0x72e2 <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    71b2:	a5 e3       	ldi	r26, 0x35	; 53
    71b4:	b0 e0       	ldi	r27, 0x00	; 0
    71b6:	e5 e3       	ldi	r30, 0x35	; 53
    71b8:	f0 e0       	ldi	r31, 0x00	; 0
    71ba:	80 81       	ld	r24, Z
    71bc:	48 2f       	mov	r20, r24
    71be:	8a 81       	ldd	r24, Y+2	; 0x02
    71c0:	28 2f       	mov	r18, r24
    71c2:	30 e0       	ldi	r19, 0x00	; 0
    71c4:	81 e0       	ldi	r24, 0x01	; 1
    71c6:	90 e0       	ldi	r25, 0x00	; 0
    71c8:	02 2e       	mov	r0, r18
    71ca:	02 c0       	rjmp	.+4      	; 0x71d0 <GPIO_writePin+0x17c>
    71cc:	88 0f       	add	r24, r24
    71ce:	99 1f       	adc	r25, r25
    71d0:	0a 94       	dec	r0
    71d2:	e2 f7       	brpl	.-8      	; 0x71cc <GPIO_writePin+0x178>
    71d4:	80 95       	com	r24
    71d6:	84 23       	and	r24, r20
    71d8:	8c 93       	st	X, r24
    71da:	83 c0       	rjmp	.+262    	; 0x72e2 <GPIO_writePin+0x28e>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    71dc:	8b 81       	ldd	r24, Y+3	; 0x03
    71de:	81 30       	cpi	r24, 0x01	; 1
    71e0:	a1 f4       	brne	.+40     	; 0x720a <GPIO_writePin+0x1b6>
			{
				SET_BIT(PORTD,pin_num);
    71e2:	a2 e3       	ldi	r26, 0x32	; 50
    71e4:	b0 e0       	ldi	r27, 0x00	; 0
    71e6:	e2 e3       	ldi	r30, 0x32	; 50
    71e8:	f0 e0       	ldi	r31, 0x00	; 0
    71ea:	80 81       	ld	r24, Z
    71ec:	48 2f       	mov	r20, r24
    71ee:	8a 81       	ldd	r24, Y+2	; 0x02
    71f0:	28 2f       	mov	r18, r24
    71f2:	30 e0       	ldi	r19, 0x00	; 0
    71f4:	81 e0       	ldi	r24, 0x01	; 1
    71f6:	90 e0       	ldi	r25, 0x00	; 0
    71f8:	02 2e       	mov	r0, r18
    71fa:	02 c0       	rjmp	.+4      	; 0x7200 <GPIO_writePin+0x1ac>
    71fc:	88 0f       	add	r24, r24
    71fe:	99 1f       	adc	r25, r25
    7200:	0a 94       	dec	r0
    7202:	e2 f7       	brpl	.-8      	; 0x71fc <GPIO_writePin+0x1a8>
    7204:	84 2b       	or	r24, r20
    7206:	8c 93       	st	X, r24
    7208:	6c c0       	rjmp	.+216    	; 0x72e2 <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    720a:	a2 e3       	ldi	r26, 0x32	; 50
    720c:	b0 e0       	ldi	r27, 0x00	; 0
    720e:	e2 e3       	ldi	r30, 0x32	; 50
    7210:	f0 e0       	ldi	r31, 0x00	; 0
    7212:	80 81       	ld	r24, Z
    7214:	48 2f       	mov	r20, r24
    7216:	8a 81       	ldd	r24, Y+2	; 0x02
    7218:	28 2f       	mov	r18, r24
    721a:	30 e0       	ldi	r19, 0x00	; 0
    721c:	81 e0       	ldi	r24, 0x01	; 1
    721e:	90 e0       	ldi	r25, 0x00	; 0
    7220:	02 2e       	mov	r0, r18
    7222:	02 c0       	rjmp	.+4      	; 0x7228 <GPIO_writePin+0x1d4>
    7224:	88 0f       	add	r24, r24
    7226:	99 1f       	adc	r25, r25
    7228:	0a 94       	dec	r0
    722a:	e2 f7       	brpl	.-8      	; 0x7224 <GPIO_writePin+0x1d0>
    722c:	80 95       	com	r24
    722e:	84 23       	and	r24, r20
    7230:	8c 93       	st	X, r24
    7232:	57 c0       	rjmp	.+174    	; 0x72e2 <GPIO_writePin+0x28e>
			}
			break;
		case PORTE_ID:
			if(value == LOGIC_HIGH)
    7234:	8b 81       	ldd	r24, Y+3	; 0x03
    7236:	81 30       	cpi	r24, 0x01	; 1
    7238:	a1 f4       	brne	.+40     	; 0x7262 <GPIO_writePin+0x20e>
			{
				SET_BIT(PORTE,pin_num);
    723a:	a3 e2       	ldi	r26, 0x23	; 35
    723c:	b0 e0       	ldi	r27, 0x00	; 0
    723e:	e3 e2       	ldi	r30, 0x23	; 35
    7240:	f0 e0       	ldi	r31, 0x00	; 0
    7242:	80 81       	ld	r24, Z
    7244:	48 2f       	mov	r20, r24
    7246:	8a 81       	ldd	r24, Y+2	; 0x02
    7248:	28 2f       	mov	r18, r24
    724a:	30 e0       	ldi	r19, 0x00	; 0
    724c:	81 e0       	ldi	r24, 0x01	; 1
    724e:	90 e0       	ldi	r25, 0x00	; 0
    7250:	02 2e       	mov	r0, r18
    7252:	02 c0       	rjmp	.+4      	; 0x7258 <GPIO_writePin+0x204>
    7254:	88 0f       	add	r24, r24
    7256:	99 1f       	adc	r25, r25
    7258:	0a 94       	dec	r0
    725a:	e2 f7       	brpl	.-8      	; 0x7254 <GPIO_writePin+0x200>
    725c:	84 2b       	or	r24, r20
    725e:	8c 93       	st	X, r24
    7260:	40 c0       	rjmp	.+128    	; 0x72e2 <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTE,pin_num);
    7262:	a3 e2       	ldi	r26, 0x23	; 35
    7264:	b0 e0       	ldi	r27, 0x00	; 0
    7266:	e3 e2       	ldi	r30, 0x23	; 35
    7268:	f0 e0       	ldi	r31, 0x00	; 0
    726a:	80 81       	ld	r24, Z
    726c:	48 2f       	mov	r20, r24
    726e:	8a 81       	ldd	r24, Y+2	; 0x02
    7270:	28 2f       	mov	r18, r24
    7272:	30 e0       	ldi	r19, 0x00	; 0
    7274:	81 e0       	ldi	r24, 0x01	; 1
    7276:	90 e0       	ldi	r25, 0x00	; 0
    7278:	02 2e       	mov	r0, r18
    727a:	02 c0       	rjmp	.+4      	; 0x7280 <GPIO_writePin+0x22c>
    727c:	88 0f       	add	r24, r24
    727e:	99 1f       	adc	r25, r25
    7280:	0a 94       	dec	r0
    7282:	e2 f7       	brpl	.-8      	; 0x727c <GPIO_writePin+0x228>
    7284:	80 95       	com	r24
    7286:	84 23       	and	r24, r20
    7288:	8c 93       	st	X, r24
    728a:	2b c0       	rjmp	.+86     	; 0x72e2 <GPIO_writePin+0x28e>
			}
			break;
		case PORTF_ID:
			if(value == LOGIC_HIGH)
    728c:	8b 81       	ldd	r24, Y+3	; 0x03
    728e:	81 30       	cpi	r24, 0x01	; 1
    7290:	a1 f4       	brne	.+40     	; 0x72ba <GPIO_writePin+0x266>
			{
				SET_BIT(PORTF,pin_num);
    7292:	a2 e6       	ldi	r26, 0x62	; 98
    7294:	b0 e0       	ldi	r27, 0x00	; 0
    7296:	e2 e6       	ldi	r30, 0x62	; 98
    7298:	f0 e0       	ldi	r31, 0x00	; 0
    729a:	80 81       	ld	r24, Z
    729c:	48 2f       	mov	r20, r24
    729e:	8a 81       	ldd	r24, Y+2	; 0x02
    72a0:	28 2f       	mov	r18, r24
    72a2:	30 e0       	ldi	r19, 0x00	; 0
    72a4:	81 e0       	ldi	r24, 0x01	; 1
    72a6:	90 e0       	ldi	r25, 0x00	; 0
    72a8:	02 2e       	mov	r0, r18
    72aa:	02 c0       	rjmp	.+4      	; 0x72b0 <GPIO_writePin+0x25c>
    72ac:	88 0f       	add	r24, r24
    72ae:	99 1f       	adc	r25, r25
    72b0:	0a 94       	dec	r0
    72b2:	e2 f7       	brpl	.-8      	; 0x72ac <GPIO_writePin+0x258>
    72b4:	84 2b       	or	r24, r20
    72b6:	8c 93       	st	X, r24
    72b8:	14 c0       	rjmp	.+40     	; 0x72e2 <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTF,pin_num);
    72ba:	a2 e6       	ldi	r26, 0x62	; 98
    72bc:	b0 e0       	ldi	r27, 0x00	; 0
    72be:	e2 e6       	ldi	r30, 0x62	; 98
    72c0:	f0 e0       	ldi	r31, 0x00	; 0
    72c2:	80 81       	ld	r24, Z
    72c4:	48 2f       	mov	r20, r24
    72c6:	8a 81       	ldd	r24, Y+2	; 0x02
    72c8:	28 2f       	mov	r18, r24
    72ca:	30 e0       	ldi	r19, 0x00	; 0
    72cc:	81 e0       	ldi	r24, 0x01	; 1
    72ce:	90 e0       	ldi	r25, 0x00	; 0
    72d0:	02 2e       	mov	r0, r18
    72d2:	02 c0       	rjmp	.+4      	; 0x72d8 <GPIO_writePin+0x284>
    72d4:	88 0f       	add	r24, r24
    72d6:	99 1f       	adc	r25, r25
    72d8:	0a 94       	dec	r0
    72da:	e2 f7       	brpl	.-8      	; 0x72d4 <GPIO_writePin+0x280>
    72dc:	80 95       	com	r24
    72de:	84 23       	and	r24, r20
    72e0:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    72e2:	0f 90       	pop	r0
    72e4:	0f 90       	pop	r0
    72e6:	0f 90       	pop	r0
    72e8:	0f 90       	pop	r0
    72ea:	0f 90       	pop	r0
    72ec:	cf 91       	pop	r28
    72ee:	df 91       	pop	r29
    72f0:	08 95       	ret

000072f2 <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    72f2:	df 93       	push	r29
    72f4:	cf 93       	push	r28
    72f6:	00 d0       	rcall	.+0      	; 0x72f8 <GPIO_readPin+0x6>
    72f8:	00 d0       	rcall	.+0      	; 0x72fa <GPIO_readPin+0x8>
    72fa:	0f 92       	push	r0
    72fc:	cd b7       	in	r28, 0x3d	; 61
    72fe:	de b7       	in	r29, 0x3e	; 62
    7300:	8a 83       	std	Y+2, r24	; 0x02
    7302:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    7304:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    7306:	8b 81       	ldd	r24, Y+3	; 0x03
    7308:	88 30       	cpi	r24, 0x08	; 8
    730a:	08 f0       	brcs	.+2      	; 0x730e <GPIO_readPin+0x1c>
    730c:	c1 c0       	rjmp	.+386    	; 0x7490 <GPIO_readPin+0x19e>
    730e:	8a 81       	ldd	r24, Y+2	; 0x02
    7310:	86 30       	cpi	r24, 0x06	; 6
    7312:	08 f0       	brcs	.+2      	; 0x7316 <GPIO_readPin+0x24>
    7314:	bd c0       	rjmp	.+378    	; 0x7490 <GPIO_readPin+0x19e>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    7316:	8a 81       	ldd	r24, Y+2	; 0x02
    7318:	28 2f       	mov	r18, r24
    731a:	30 e0       	ldi	r19, 0x00	; 0
    731c:	3d 83       	std	Y+5, r19	; 0x05
    731e:	2c 83       	std	Y+4, r18	; 0x04
    7320:	4c 81       	ldd	r20, Y+4	; 0x04
    7322:	5d 81       	ldd	r21, Y+5	; 0x05
    7324:	42 30       	cpi	r20, 0x02	; 2
    7326:	51 05       	cpc	r21, r1
    7328:	09 f4       	brne	.+2      	; 0x732c <GPIO_readPin+0x3a>
    732a:	53 c0       	rjmp	.+166    	; 0x73d2 <GPIO_readPin+0xe0>
    732c:	8c 81       	ldd	r24, Y+4	; 0x04
    732e:	9d 81       	ldd	r25, Y+5	; 0x05
    7330:	83 30       	cpi	r24, 0x03	; 3
    7332:	91 05       	cpc	r25, r1
    7334:	5c f4       	brge	.+22     	; 0x734c <GPIO_readPin+0x5a>
    7336:	2c 81       	ldd	r18, Y+4	; 0x04
    7338:	3d 81       	ldd	r19, Y+5	; 0x05
    733a:	21 15       	cp	r18, r1
    733c:	31 05       	cpc	r19, r1
    733e:	c9 f0       	breq	.+50     	; 0x7372 <GPIO_readPin+0x80>
    7340:	4c 81       	ldd	r20, Y+4	; 0x04
    7342:	5d 81       	ldd	r21, Y+5	; 0x05
    7344:	41 30       	cpi	r20, 0x01	; 1
    7346:	51 05       	cpc	r21, r1
    7348:	61 f1       	breq	.+88     	; 0x73a2 <GPIO_readPin+0xb0>
    734a:	a2 c0       	rjmp	.+324    	; 0x7490 <GPIO_readPin+0x19e>
    734c:	8c 81       	ldd	r24, Y+4	; 0x04
    734e:	9d 81       	ldd	r25, Y+5	; 0x05
    7350:	84 30       	cpi	r24, 0x04	; 4
    7352:	91 05       	cpc	r25, r1
    7354:	09 f4       	brne	.+2      	; 0x7358 <GPIO_readPin+0x66>
    7356:	6d c0       	rjmp	.+218    	; 0x7432 <GPIO_readPin+0x140>
    7358:	2c 81       	ldd	r18, Y+4	; 0x04
    735a:	3d 81       	ldd	r19, Y+5	; 0x05
    735c:	24 30       	cpi	r18, 0x04	; 4
    735e:	31 05       	cpc	r19, r1
    7360:	0c f4       	brge	.+2      	; 0x7364 <GPIO_readPin+0x72>
    7362:	4f c0       	rjmp	.+158    	; 0x7402 <GPIO_readPin+0x110>
    7364:	4c 81       	ldd	r20, Y+4	; 0x04
    7366:	5d 81       	ldd	r21, Y+5	; 0x05
    7368:	45 30       	cpi	r20, 0x05	; 5
    736a:	51 05       	cpc	r21, r1
    736c:	09 f4       	brne	.+2      	; 0x7370 <GPIO_readPin+0x7e>
    736e:	79 c0       	rjmp	.+242    	; 0x7462 <GPIO_readPin+0x170>
    7370:	8f c0       	rjmp	.+286    	; 0x7490 <GPIO_readPin+0x19e>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    7372:	e9 e3       	ldi	r30, 0x39	; 57
    7374:	f0 e0       	ldi	r31, 0x00	; 0
    7376:	80 81       	ld	r24, Z
    7378:	28 2f       	mov	r18, r24
    737a:	30 e0       	ldi	r19, 0x00	; 0
    737c:	8b 81       	ldd	r24, Y+3	; 0x03
    737e:	88 2f       	mov	r24, r24
    7380:	90 e0       	ldi	r25, 0x00	; 0
    7382:	a9 01       	movw	r20, r18
    7384:	02 c0       	rjmp	.+4      	; 0x738a <GPIO_readPin+0x98>
    7386:	55 95       	asr	r21
    7388:	47 95       	ror	r20
    738a:	8a 95       	dec	r24
    738c:	e2 f7       	brpl	.-8      	; 0x7386 <GPIO_readPin+0x94>
    738e:	ca 01       	movw	r24, r20
    7390:	81 70       	andi	r24, 0x01	; 1
    7392:	90 70       	andi	r25, 0x00	; 0
    7394:	88 23       	and	r24, r24
    7396:	19 f0       	breq	.+6      	; 0x739e <GPIO_readPin+0xac>
			{
				pin_value = LOGIC_HIGH;
    7398:	81 e0       	ldi	r24, 0x01	; 1
    739a:	89 83       	std	Y+1, r24	; 0x01
    739c:	79 c0       	rjmp	.+242    	; 0x7490 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    739e:	19 82       	std	Y+1, r1	; 0x01
    73a0:	77 c0       	rjmp	.+238    	; 0x7490 <GPIO_readPin+0x19e>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    73a2:	e6 e3       	ldi	r30, 0x36	; 54
    73a4:	f0 e0       	ldi	r31, 0x00	; 0
    73a6:	80 81       	ld	r24, Z
    73a8:	28 2f       	mov	r18, r24
    73aa:	30 e0       	ldi	r19, 0x00	; 0
    73ac:	8b 81       	ldd	r24, Y+3	; 0x03
    73ae:	88 2f       	mov	r24, r24
    73b0:	90 e0       	ldi	r25, 0x00	; 0
    73b2:	a9 01       	movw	r20, r18
    73b4:	02 c0       	rjmp	.+4      	; 0x73ba <GPIO_readPin+0xc8>
    73b6:	55 95       	asr	r21
    73b8:	47 95       	ror	r20
    73ba:	8a 95       	dec	r24
    73bc:	e2 f7       	brpl	.-8      	; 0x73b6 <GPIO_readPin+0xc4>
    73be:	ca 01       	movw	r24, r20
    73c0:	81 70       	andi	r24, 0x01	; 1
    73c2:	90 70       	andi	r25, 0x00	; 0
    73c4:	88 23       	and	r24, r24
    73c6:	19 f0       	breq	.+6      	; 0x73ce <GPIO_readPin+0xdc>
			{
				pin_value = LOGIC_HIGH;
    73c8:	81 e0       	ldi	r24, 0x01	; 1
    73ca:	89 83       	std	Y+1, r24	; 0x01
    73cc:	61 c0       	rjmp	.+194    	; 0x7490 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    73ce:	19 82       	std	Y+1, r1	; 0x01
    73d0:	5f c0       	rjmp	.+190    	; 0x7490 <GPIO_readPin+0x19e>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    73d2:	e3 e3       	ldi	r30, 0x33	; 51
    73d4:	f0 e0       	ldi	r31, 0x00	; 0
    73d6:	80 81       	ld	r24, Z
    73d8:	28 2f       	mov	r18, r24
    73da:	30 e0       	ldi	r19, 0x00	; 0
    73dc:	8b 81       	ldd	r24, Y+3	; 0x03
    73de:	88 2f       	mov	r24, r24
    73e0:	90 e0       	ldi	r25, 0x00	; 0
    73e2:	a9 01       	movw	r20, r18
    73e4:	02 c0       	rjmp	.+4      	; 0x73ea <GPIO_readPin+0xf8>
    73e6:	55 95       	asr	r21
    73e8:	47 95       	ror	r20
    73ea:	8a 95       	dec	r24
    73ec:	e2 f7       	brpl	.-8      	; 0x73e6 <GPIO_readPin+0xf4>
    73ee:	ca 01       	movw	r24, r20
    73f0:	81 70       	andi	r24, 0x01	; 1
    73f2:	90 70       	andi	r25, 0x00	; 0
    73f4:	88 23       	and	r24, r24
    73f6:	19 f0       	breq	.+6      	; 0x73fe <GPIO_readPin+0x10c>
			{
				pin_value = LOGIC_HIGH;
    73f8:	81 e0       	ldi	r24, 0x01	; 1
    73fa:	89 83       	std	Y+1, r24	; 0x01
    73fc:	49 c0       	rjmp	.+146    	; 0x7490 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    73fe:	19 82       	std	Y+1, r1	; 0x01
    7400:	47 c0       	rjmp	.+142    	; 0x7490 <GPIO_readPin+0x19e>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    7402:	e0 e3       	ldi	r30, 0x30	; 48
    7404:	f0 e0       	ldi	r31, 0x00	; 0
    7406:	80 81       	ld	r24, Z
    7408:	28 2f       	mov	r18, r24
    740a:	30 e0       	ldi	r19, 0x00	; 0
    740c:	8b 81       	ldd	r24, Y+3	; 0x03
    740e:	88 2f       	mov	r24, r24
    7410:	90 e0       	ldi	r25, 0x00	; 0
    7412:	a9 01       	movw	r20, r18
    7414:	02 c0       	rjmp	.+4      	; 0x741a <GPIO_readPin+0x128>
    7416:	55 95       	asr	r21
    7418:	47 95       	ror	r20
    741a:	8a 95       	dec	r24
    741c:	e2 f7       	brpl	.-8      	; 0x7416 <GPIO_readPin+0x124>
    741e:	ca 01       	movw	r24, r20
    7420:	81 70       	andi	r24, 0x01	; 1
    7422:	90 70       	andi	r25, 0x00	; 0
    7424:	88 23       	and	r24, r24
    7426:	19 f0       	breq	.+6      	; 0x742e <GPIO_readPin+0x13c>
			{
				pin_value = LOGIC_HIGH;
    7428:	81 e0       	ldi	r24, 0x01	; 1
    742a:	89 83       	std	Y+1, r24	; 0x01
    742c:	31 c0       	rjmp	.+98     	; 0x7490 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    742e:	19 82       	std	Y+1, r1	; 0x01
    7430:	2f c0       	rjmp	.+94     	; 0x7490 <GPIO_readPin+0x19e>
			}
			break;
		case PORTE_ID:
			if(BIT_IS_SET(PINE,pin_num))
    7432:	e1 e2       	ldi	r30, 0x21	; 33
    7434:	f0 e0       	ldi	r31, 0x00	; 0
    7436:	80 81       	ld	r24, Z
    7438:	28 2f       	mov	r18, r24
    743a:	30 e0       	ldi	r19, 0x00	; 0
    743c:	8b 81       	ldd	r24, Y+3	; 0x03
    743e:	88 2f       	mov	r24, r24
    7440:	90 e0       	ldi	r25, 0x00	; 0
    7442:	a9 01       	movw	r20, r18
    7444:	02 c0       	rjmp	.+4      	; 0x744a <GPIO_readPin+0x158>
    7446:	55 95       	asr	r21
    7448:	47 95       	ror	r20
    744a:	8a 95       	dec	r24
    744c:	e2 f7       	brpl	.-8      	; 0x7446 <GPIO_readPin+0x154>
    744e:	ca 01       	movw	r24, r20
    7450:	81 70       	andi	r24, 0x01	; 1
    7452:	90 70       	andi	r25, 0x00	; 0
    7454:	88 23       	and	r24, r24
    7456:	19 f0       	breq	.+6      	; 0x745e <GPIO_readPin+0x16c>
			{
				pin_value = LOGIC_HIGH;
    7458:	81 e0       	ldi	r24, 0x01	; 1
    745a:	89 83       	std	Y+1, r24	; 0x01
    745c:	19 c0       	rjmp	.+50     	; 0x7490 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    745e:	19 82       	std	Y+1, r1	; 0x01
    7460:	17 c0       	rjmp	.+46     	; 0x7490 <GPIO_readPin+0x19e>
			}
			break;
		case PORTF_ID:
			if(BIT_IS_SET(PINF,pin_num))
    7462:	e0 e2       	ldi	r30, 0x20	; 32
    7464:	f0 e0       	ldi	r31, 0x00	; 0
    7466:	80 81       	ld	r24, Z
    7468:	28 2f       	mov	r18, r24
    746a:	30 e0       	ldi	r19, 0x00	; 0
    746c:	8b 81       	ldd	r24, Y+3	; 0x03
    746e:	88 2f       	mov	r24, r24
    7470:	90 e0       	ldi	r25, 0x00	; 0
    7472:	a9 01       	movw	r20, r18
    7474:	02 c0       	rjmp	.+4      	; 0x747a <GPIO_readPin+0x188>
    7476:	55 95       	asr	r21
    7478:	47 95       	ror	r20
    747a:	8a 95       	dec	r24
    747c:	e2 f7       	brpl	.-8      	; 0x7476 <GPIO_readPin+0x184>
    747e:	ca 01       	movw	r24, r20
    7480:	81 70       	andi	r24, 0x01	; 1
    7482:	90 70       	andi	r25, 0x00	; 0
    7484:	88 23       	and	r24, r24
    7486:	19 f0       	breq	.+6      	; 0x748e <GPIO_readPin+0x19c>
			{
				pin_value = LOGIC_HIGH;
    7488:	81 e0       	ldi	r24, 0x01	; 1
    748a:	89 83       	std	Y+1, r24	; 0x01
    748c:	01 c0       	rjmp	.+2      	; 0x7490 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    748e:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    7490:	89 81       	ldd	r24, Y+1	; 0x01
}
    7492:	0f 90       	pop	r0
    7494:	0f 90       	pop	r0
    7496:	0f 90       	pop	r0
    7498:	0f 90       	pop	r0
    749a:	0f 90       	pop	r0
    749c:	cf 91       	pop	r28
    749e:	df 91       	pop	r29
    74a0:	08 95       	ret

000074a2 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    74a2:	df 93       	push	r29
    74a4:	cf 93       	push	r28
    74a6:	00 d0       	rcall	.+0      	; 0x74a8 <GPIO_setupPortDirection+0x6>
    74a8:	00 d0       	rcall	.+0      	; 0x74aa <GPIO_setupPortDirection+0x8>
    74aa:	cd b7       	in	r28, 0x3d	; 61
    74ac:	de b7       	in	r29, 0x3e	; 62
    74ae:	89 83       	std	Y+1, r24	; 0x01
    74b0:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    74b2:	89 81       	ldd	r24, Y+1	; 0x01
    74b4:	86 30       	cpi	r24, 0x06	; 6
    74b6:	08 f0       	brcs	.+2      	; 0x74ba <GPIO_setupPortDirection+0x18>
    74b8:	46 c0       	rjmp	.+140    	; 0x7546 <GPIO_setupPortDirection+0xa4>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    74ba:	89 81       	ldd	r24, Y+1	; 0x01
    74bc:	28 2f       	mov	r18, r24
    74be:	30 e0       	ldi	r19, 0x00	; 0
    74c0:	3c 83       	std	Y+4, r19	; 0x04
    74c2:	2b 83       	std	Y+3, r18	; 0x03
    74c4:	8b 81       	ldd	r24, Y+3	; 0x03
    74c6:	9c 81       	ldd	r25, Y+4	; 0x04
    74c8:	82 30       	cpi	r24, 0x02	; 2
    74ca:	91 05       	cpc	r25, r1
    74cc:	49 f1       	breq	.+82     	; 0x7520 <GPIO_setupPortDirection+0x7e>
    74ce:	2b 81       	ldd	r18, Y+3	; 0x03
    74d0:	3c 81       	ldd	r19, Y+4	; 0x04
    74d2:	23 30       	cpi	r18, 0x03	; 3
    74d4:	31 05       	cpc	r19, r1
    74d6:	54 f4       	brge	.+20     	; 0x74ec <GPIO_setupPortDirection+0x4a>
    74d8:	8b 81       	ldd	r24, Y+3	; 0x03
    74da:	9c 81       	ldd	r25, Y+4	; 0x04
    74dc:	00 97       	sbiw	r24, 0x00	; 0
    74de:	b1 f0       	breq	.+44     	; 0x750c <GPIO_setupPortDirection+0x6a>
    74e0:	2b 81       	ldd	r18, Y+3	; 0x03
    74e2:	3c 81       	ldd	r19, Y+4	; 0x04
    74e4:	21 30       	cpi	r18, 0x01	; 1
    74e6:	31 05       	cpc	r19, r1
    74e8:	b1 f0       	breq	.+44     	; 0x7516 <GPIO_setupPortDirection+0x74>
    74ea:	2d c0       	rjmp	.+90     	; 0x7546 <GPIO_setupPortDirection+0xa4>
    74ec:	8b 81       	ldd	r24, Y+3	; 0x03
    74ee:	9c 81       	ldd	r25, Y+4	; 0x04
    74f0:	84 30       	cpi	r24, 0x04	; 4
    74f2:	91 05       	cpc	r25, r1
    74f4:	f9 f0       	breq	.+62     	; 0x7534 <GPIO_setupPortDirection+0x92>
    74f6:	2b 81       	ldd	r18, Y+3	; 0x03
    74f8:	3c 81       	ldd	r19, Y+4	; 0x04
    74fa:	24 30       	cpi	r18, 0x04	; 4
    74fc:	31 05       	cpc	r19, r1
    74fe:	ac f0       	brlt	.+42     	; 0x752a <GPIO_setupPortDirection+0x88>
    7500:	8b 81       	ldd	r24, Y+3	; 0x03
    7502:	9c 81       	ldd	r25, Y+4	; 0x04
    7504:	85 30       	cpi	r24, 0x05	; 5
    7506:	91 05       	cpc	r25, r1
    7508:	d1 f0       	breq	.+52     	; 0x753e <GPIO_setupPortDirection+0x9c>
    750a:	1d c0       	rjmp	.+58     	; 0x7546 <GPIO_setupPortDirection+0xa4>
		{
		case PORTA_ID:
			DDRA = direction;
    750c:	ea e3       	ldi	r30, 0x3A	; 58
    750e:	f0 e0       	ldi	r31, 0x00	; 0
    7510:	8a 81       	ldd	r24, Y+2	; 0x02
    7512:	80 83       	st	Z, r24
    7514:	18 c0       	rjmp	.+48     	; 0x7546 <GPIO_setupPortDirection+0xa4>
			break;
		case PORTB_ID:
			DDRB = direction;
    7516:	e7 e3       	ldi	r30, 0x37	; 55
    7518:	f0 e0       	ldi	r31, 0x00	; 0
    751a:	8a 81       	ldd	r24, Y+2	; 0x02
    751c:	80 83       	st	Z, r24
    751e:	13 c0       	rjmp	.+38     	; 0x7546 <GPIO_setupPortDirection+0xa4>
			break;
		case PORTC_ID:
			DDRC = direction;
    7520:	e4 e3       	ldi	r30, 0x34	; 52
    7522:	f0 e0       	ldi	r31, 0x00	; 0
    7524:	8a 81       	ldd	r24, Y+2	; 0x02
    7526:	80 83       	st	Z, r24
    7528:	0e c0       	rjmp	.+28     	; 0x7546 <GPIO_setupPortDirection+0xa4>
			break;
		case PORTD_ID:
			DDRD = direction;
    752a:	e1 e3       	ldi	r30, 0x31	; 49
    752c:	f0 e0       	ldi	r31, 0x00	; 0
    752e:	8a 81       	ldd	r24, Y+2	; 0x02
    7530:	80 83       	st	Z, r24
    7532:	09 c0       	rjmp	.+18     	; 0x7546 <GPIO_setupPortDirection+0xa4>
			break;
		case PORTE_ID:
			DDRE = direction;
    7534:	e2 e2       	ldi	r30, 0x22	; 34
    7536:	f0 e0       	ldi	r31, 0x00	; 0
    7538:	8a 81       	ldd	r24, Y+2	; 0x02
    753a:	80 83       	st	Z, r24
    753c:	04 c0       	rjmp	.+8      	; 0x7546 <GPIO_setupPortDirection+0xa4>
			break;
		case PORTF_ID:
			DDRF = direction;
    753e:	e1 e6       	ldi	r30, 0x61	; 97
    7540:	f0 e0       	ldi	r31, 0x00	; 0
    7542:	8a 81       	ldd	r24, Y+2	; 0x02
    7544:	80 83       	st	Z, r24
			break;
		}
	}
}
    7546:	0f 90       	pop	r0
    7548:	0f 90       	pop	r0
    754a:	0f 90       	pop	r0
    754c:	0f 90       	pop	r0
    754e:	cf 91       	pop	r28
    7550:	df 91       	pop	r29
    7552:	08 95       	ret

00007554 <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    7554:	df 93       	push	r29
    7556:	cf 93       	push	r28
    7558:	00 d0       	rcall	.+0      	; 0x755a <GPIO_writePort+0x6>
    755a:	00 d0       	rcall	.+0      	; 0x755c <GPIO_writePort+0x8>
    755c:	cd b7       	in	r28, 0x3d	; 61
    755e:	de b7       	in	r29, 0x3e	; 62
    7560:	89 83       	std	Y+1, r24	; 0x01
    7562:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    7564:	89 81       	ldd	r24, Y+1	; 0x01
    7566:	86 30       	cpi	r24, 0x06	; 6
    7568:	08 f0       	brcs	.+2      	; 0x756c <GPIO_writePort+0x18>
    756a:	46 c0       	rjmp	.+140    	; 0x75f8 <GPIO_writePort+0xa4>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    756c:	89 81       	ldd	r24, Y+1	; 0x01
    756e:	28 2f       	mov	r18, r24
    7570:	30 e0       	ldi	r19, 0x00	; 0
    7572:	3c 83       	std	Y+4, r19	; 0x04
    7574:	2b 83       	std	Y+3, r18	; 0x03
    7576:	8b 81       	ldd	r24, Y+3	; 0x03
    7578:	9c 81       	ldd	r25, Y+4	; 0x04
    757a:	82 30       	cpi	r24, 0x02	; 2
    757c:	91 05       	cpc	r25, r1
    757e:	49 f1       	breq	.+82     	; 0x75d2 <GPIO_writePort+0x7e>
    7580:	2b 81       	ldd	r18, Y+3	; 0x03
    7582:	3c 81       	ldd	r19, Y+4	; 0x04
    7584:	23 30       	cpi	r18, 0x03	; 3
    7586:	31 05       	cpc	r19, r1
    7588:	54 f4       	brge	.+20     	; 0x759e <GPIO_writePort+0x4a>
    758a:	8b 81       	ldd	r24, Y+3	; 0x03
    758c:	9c 81       	ldd	r25, Y+4	; 0x04
    758e:	00 97       	sbiw	r24, 0x00	; 0
    7590:	b1 f0       	breq	.+44     	; 0x75be <GPIO_writePort+0x6a>
    7592:	2b 81       	ldd	r18, Y+3	; 0x03
    7594:	3c 81       	ldd	r19, Y+4	; 0x04
    7596:	21 30       	cpi	r18, 0x01	; 1
    7598:	31 05       	cpc	r19, r1
    759a:	b1 f0       	breq	.+44     	; 0x75c8 <GPIO_writePort+0x74>
    759c:	2d c0       	rjmp	.+90     	; 0x75f8 <GPIO_writePort+0xa4>
    759e:	8b 81       	ldd	r24, Y+3	; 0x03
    75a0:	9c 81       	ldd	r25, Y+4	; 0x04
    75a2:	84 30       	cpi	r24, 0x04	; 4
    75a4:	91 05       	cpc	r25, r1
    75a6:	f9 f0       	breq	.+62     	; 0x75e6 <GPIO_writePort+0x92>
    75a8:	2b 81       	ldd	r18, Y+3	; 0x03
    75aa:	3c 81       	ldd	r19, Y+4	; 0x04
    75ac:	24 30       	cpi	r18, 0x04	; 4
    75ae:	31 05       	cpc	r19, r1
    75b0:	ac f0       	brlt	.+42     	; 0x75dc <GPIO_writePort+0x88>
    75b2:	8b 81       	ldd	r24, Y+3	; 0x03
    75b4:	9c 81       	ldd	r25, Y+4	; 0x04
    75b6:	85 30       	cpi	r24, 0x05	; 5
    75b8:	91 05       	cpc	r25, r1
    75ba:	d1 f0       	breq	.+52     	; 0x75f0 <GPIO_writePort+0x9c>
    75bc:	1d c0       	rjmp	.+58     	; 0x75f8 <GPIO_writePort+0xa4>
		{
		case PORTA_ID:
			PORTA = value;
    75be:	eb e3       	ldi	r30, 0x3B	; 59
    75c0:	f0 e0       	ldi	r31, 0x00	; 0
    75c2:	8a 81       	ldd	r24, Y+2	; 0x02
    75c4:	80 83       	st	Z, r24
    75c6:	18 c0       	rjmp	.+48     	; 0x75f8 <GPIO_writePort+0xa4>
			break;
		case PORTB_ID:
			PORTB = value;
    75c8:	e8 e3       	ldi	r30, 0x38	; 56
    75ca:	f0 e0       	ldi	r31, 0x00	; 0
    75cc:	8a 81       	ldd	r24, Y+2	; 0x02
    75ce:	80 83       	st	Z, r24
    75d0:	13 c0       	rjmp	.+38     	; 0x75f8 <GPIO_writePort+0xa4>
			break;
		case PORTC_ID:
			PORTC = value;
    75d2:	e5 e3       	ldi	r30, 0x35	; 53
    75d4:	f0 e0       	ldi	r31, 0x00	; 0
    75d6:	8a 81       	ldd	r24, Y+2	; 0x02
    75d8:	80 83       	st	Z, r24
    75da:	0e c0       	rjmp	.+28     	; 0x75f8 <GPIO_writePort+0xa4>
			break;
		case PORTD_ID:
			PORTD = value;
    75dc:	e2 e3       	ldi	r30, 0x32	; 50
    75de:	f0 e0       	ldi	r31, 0x00	; 0
    75e0:	8a 81       	ldd	r24, Y+2	; 0x02
    75e2:	80 83       	st	Z, r24
    75e4:	09 c0       	rjmp	.+18     	; 0x75f8 <GPIO_writePort+0xa4>
			break;
		case PORTE_ID:
			PORTE = value;
    75e6:	e3 e2       	ldi	r30, 0x23	; 35
    75e8:	f0 e0       	ldi	r31, 0x00	; 0
    75ea:	8a 81       	ldd	r24, Y+2	; 0x02
    75ec:	80 83       	st	Z, r24
    75ee:	04 c0       	rjmp	.+8      	; 0x75f8 <GPIO_writePort+0xa4>
			break;
		case PORTF_ID:
			PORTF = value;
    75f0:	e2 e6       	ldi	r30, 0x62	; 98
    75f2:	f0 e0       	ldi	r31, 0x00	; 0
    75f4:	8a 81       	ldd	r24, Y+2	; 0x02
    75f6:	80 83       	st	Z, r24
			break;
		}
	}
}
    75f8:	0f 90       	pop	r0
    75fa:	0f 90       	pop	r0
    75fc:	0f 90       	pop	r0
    75fe:	0f 90       	pop	r0
    7600:	cf 91       	pop	r28
    7602:	df 91       	pop	r29
    7604:	08 95       	ret

00007606 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    7606:	df 93       	push	r29
    7608:	cf 93       	push	r28
    760a:	00 d0       	rcall	.+0      	; 0x760c <GPIO_readPort+0x6>
    760c:	00 d0       	rcall	.+0      	; 0x760e <GPIO_readPort+0x8>
    760e:	cd b7       	in	r28, 0x3d	; 61
    7610:	de b7       	in	r29, 0x3e	; 62
    7612:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    7614:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    7616:	8a 81       	ldd	r24, Y+2	; 0x02
    7618:	86 30       	cpi	r24, 0x06	; 6
    761a:	08 f0       	brcs	.+2      	; 0x761e <GPIO_readPort+0x18>
    761c:	46 c0       	rjmp	.+140    	; 0x76aa <GPIO_readPort+0xa4>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    761e:	8a 81       	ldd	r24, Y+2	; 0x02
    7620:	28 2f       	mov	r18, r24
    7622:	30 e0       	ldi	r19, 0x00	; 0
    7624:	3c 83       	std	Y+4, r19	; 0x04
    7626:	2b 83       	std	Y+3, r18	; 0x03
    7628:	8b 81       	ldd	r24, Y+3	; 0x03
    762a:	9c 81       	ldd	r25, Y+4	; 0x04
    762c:	82 30       	cpi	r24, 0x02	; 2
    762e:	91 05       	cpc	r25, r1
    7630:	49 f1       	breq	.+82     	; 0x7684 <GPIO_readPort+0x7e>
    7632:	2b 81       	ldd	r18, Y+3	; 0x03
    7634:	3c 81       	ldd	r19, Y+4	; 0x04
    7636:	23 30       	cpi	r18, 0x03	; 3
    7638:	31 05       	cpc	r19, r1
    763a:	54 f4       	brge	.+20     	; 0x7650 <GPIO_readPort+0x4a>
    763c:	8b 81       	ldd	r24, Y+3	; 0x03
    763e:	9c 81       	ldd	r25, Y+4	; 0x04
    7640:	00 97       	sbiw	r24, 0x00	; 0
    7642:	b1 f0       	breq	.+44     	; 0x7670 <GPIO_readPort+0x6a>
    7644:	2b 81       	ldd	r18, Y+3	; 0x03
    7646:	3c 81       	ldd	r19, Y+4	; 0x04
    7648:	21 30       	cpi	r18, 0x01	; 1
    764a:	31 05       	cpc	r19, r1
    764c:	b1 f0       	breq	.+44     	; 0x767a <GPIO_readPort+0x74>
    764e:	2d c0       	rjmp	.+90     	; 0x76aa <GPIO_readPort+0xa4>
    7650:	8b 81       	ldd	r24, Y+3	; 0x03
    7652:	9c 81       	ldd	r25, Y+4	; 0x04
    7654:	84 30       	cpi	r24, 0x04	; 4
    7656:	91 05       	cpc	r25, r1
    7658:	f9 f0       	breq	.+62     	; 0x7698 <GPIO_readPort+0x92>
    765a:	2b 81       	ldd	r18, Y+3	; 0x03
    765c:	3c 81       	ldd	r19, Y+4	; 0x04
    765e:	24 30       	cpi	r18, 0x04	; 4
    7660:	31 05       	cpc	r19, r1
    7662:	ac f0       	brlt	.+42     	; 0x768e <GPIO_readPort+0x88>
    7664:	8b 81       	ldd	r24, Y+3	; 0x03
    7666:	9c 81       	ldd	r25, Y+4	; 0x04
    7668:	85 30       	cpi	r24, 0x05	; 5
    766a:	91 05       	cpc	r25, r1
    766c:	d1 f0       	breq	.+52     	; 0x76a2 <GPIO_readPort+0x9c>
    766e:	1d c0       	rjmp	.+58     	; 0x76aa <GPIO_readPort+0xa4>
		{
		case PORTA_ID:
			value = PINA;
    7670:	e9 e3       	ldi	r30, 0x39	; 57
    7672:	f0 e0       	ldi	r31, 0x00	; 0
    7674:	80 81       	ld	r24, Z
    7676:	89 83       	std	Y+1, r24	; 0x01
    7678:	18 c0       	rjmp	.+48     	; 0x76aa <GPIO_readPort+0xa4>
			break;
		case PORTB_ID:
			value = PINB;
    767a:	e6 e3       	ldi	r30, 0x36	; 54
    767c:	f0 e0       	ldi	r31, 0x00	; 0
    767e:	80 81       	ld	r24, Z
    7680:	89 83       	std	Y+1, r24	; 0x01
    7682:	13 c0       	rjmp	.+38     	; 0x76aa <GPIO_readPort+0xa4>
			break;
		case PORTC_ID:
			value = PINC;
    7684:	e3 e3       	ldi	r30, 0x33	; 51
    7686:	f0 e0       	ldi	r31, 0x00	; 0
    7688:	80 81       	ld	r24, Z
    768a:	89 83       	std	Y+1, r24	; 0x01
    768c:	0e c0       	rjmp	.+28     	; 0x76aa <GPIO_readPort+0xa4>
			break;
		case PORTD_ID:
			value = PIND;
    768e:	e0 e3       	ldi	r30, 0x30	; 48
    7690:	f0 e0       	ldi	r31, 0x00	; 0
    7692:	80 81       	ld	r24, Z
    7694:	89 83       	std	Y+1, r24	; 0x01
    7696:	09 c0       	rjmp	.+18     	; 0x76aa <GPIO_readPort+0xa4>
			break;
		case PORTE_ID:
			value = PINE;
    7698:	e1 e2       	ldi	r30, 0x21	; 33
    769a:	f0 e0       	ldi	r31, 0x00	; 0
    769c:	80 81       	ld	r24, Z
    769e:	89 83       	std	Y+1, r24	; 0x01
    76a0:	04 c0       	rjmp	.+8      	; 0x76aa <GPIO_readPort+0xa4>
			break;
		case PORTF_ID:
			value = PINF;
    76a2:	e0 e2       	ldi	r30, 0x20	; 32
    76a4:	f0 e0       	ldi	r31, 0x00	; 0
    76a6:	80 81       	ld	r24, Z
    76a8:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    76aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    76ac:	0f 90       	pop	r0
    76ae:	0f 90       	pop	r0
    76b0:	0f 90       	pop	r0
    76b2:	0f 90       	pop	r0
    76b4:	cf 91       	pop	r28
    76b6:	df 91       	pop	r29
    76b8:	08 95       	ret

000076ba <DIO_init>:


void DIO_init(void)
{
    76ba:	df 93       	push	r29
    76bc:	cf 93       	push	r28
    76be:	00 d0       	rcall	.+0      	; 0x76c0 <DIO_init+0x6>
    76c0:	00 d0       	rcall	.+0      	; 0x76c2 <DIO_init+0x8>
    76c2:	cd b7       	in	r28, 0x3d	; 61
    76c4:	de b7       	in	r29, 0x3e	; 62
	uint8_t loop;
	for(loop=0u; loop < DIO_NUM_OF_CHANNELS ; loop++ ){
    76c6:	1c 82       	std	Y+4, r1	; 0x04
    76c8:	2f c0       	rjmp	.+94     	; 0x7728 <DIO_init+0x6e>
		uint8_t portid=dio_config_array[loop].port_id;
    76ca:	8c 81       	ldd	r24, Y+4	; 0x04
    76cc:	28 2f       	mov	r18, r24
    76ce:	30 e0       	ldi	r19, 0x00	; 0
    76d0:	c9 01       	movw	r24, r18
    76d2:	88 0f       	add	r24, r24
    76d4:	99 1f       	adc	r25, r25
    76d6:	82 0f       	add	r24, r18
    76d8:	93 1f       	adc	r25, r19
    76da:	fc 01       	movw	r30, r24
    76dc:	ec 5c       	subi	r30, 0xCC	; 204
    76de:	fd 4f       	sbci	r31, 0xFD	; 253
    76e0:	80 81       	ld	r24, Z
    76e2:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[loop].pin_num;
    76e4:	8c 81       	ldd	r24, Y+4	; 0x04
    76e6:	28 2f       	mov	r18, r24
    76e8:	30 e0       	ldi	r19, 0x00	; 0
    76ea:	c9 01       	movw	r24, r18
    76ec:	88 0f       	add	r24, r24
    76ee:	99 1f       	adc	r25, r25
    76f0:	82 0f       	add	r24, r18
    76f2:	93 1f       	adc	r25, r19
    76f4:	fc 01       	movw	r30, r24
    76f6:	eb 5c       	subi	r30, 0xCB	; 203
    76f8:	fd 4f       	sbci	r31, 0xFD	; 253
    76fa:	80 81       	ld	r24, Z
    76fc:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t direction=dio_config_array[loop].direction;
    76fe:	8c 81       	ldd	r24, Y+4	; 0x04
    7700:	28 2f       	mov	r18, r24
    7702:	30 e0       	ldi	r19, 0x00	; 0
    7704:	c9 01       	movw	r24, r18
    7706:	88 0f       	add	r24, r24
    7708:	99 1f       	adc	r25, r25
    770a:	82 0f       	add	r24, r18
    770c:	93 1f       	adc	r25, r19
    770e:	fc 01       	movw	r30, r24
    7710:	ea 5c       	subi	r30, 0xCA	; 202
    7712:	fd 4f       	sbci	r31, 0xFD	; 253
    7714:	80 81       	ld	r24, Z
    7716:	89 83       	std	Y+1, r24	; 0x01
		GPIO_setupPinDirection(portid,pin_num,direction);
    7718:	8b 81       	ldd	r24, Y+3	; 0x03
    771a:	6a 81       	ldd	r22, Y+2	; 0x02
    771c:	49 81       	ldd	r20, Y+1	; 0x01
    771e:	0e 94 db 36 	call	0x6db6	; 0x6db6 <GPIO_setupPinDirection>


void DIO_init(void)
{
	uint8_t loop;
	for(loop=0u; loop < DIO_NUM_OF_CHANNELS ; loop++ ){
    7722:	8c 81       	ldd	r24, Y+4	; 0x04
    7724:	8f 5f       	subi	r24, 0xFF	; 255
    7726:	8c 83       	std	Y+4, r24	; 0x04
    7728:	8c 81       	ldd	r24, Y+4	; 0x04
    772a:	86 30       	cpi	r24, 0x06	; 6
    772c:	70 f2       	brcs	.-100    	; 0x76ca <DIO_init+0x10>
		uint8_t portid=dio_config_array[loop].port_id;
		uint8_t pin_num=dio_config_array[loop].pin_num;
		uint8_t direction=dio_config_array[loop].direction;
		GPIO_setupPinDirection(portid,pin_num,direction);
	}
}
    772e:	0f 90       	pop	r0
    7730:	0f 90       	pop	r0
    7732:	0f 90       	pop	r0
    7734:	0f 90       	pop	r0
    7736:	cf 91       	pop	r28
    7738:	df 91       	pop	r29
    773a:	08 95       	ret

0000773c <DIO_ChannelGroupWrite>:


void DIO_ChannelGroupWrite(ChannelGroupType channel_group_variabe , uint8_t data)
{
    773c:	af 92       	push	r10
    773e:	cf 92       	push	r12
    7740:	df 92       	push	r13
    7742:	ef 92       	push	r14
    7744:	ff 92       	push	r15
    7746:	0f 93       	push	r16
    7748:	1f 93       	push	r17
    774a:	df 93       	push	r29
    774c:	cf 93       	push	r28
    774e:	cd b7       	in	r28, 0x3d	; 61
    7750:	de b7       	in	r29, 0x3e	; 62
    7752:	65 97       	sbiw	r28, 0x15	; 21
    7754:	0f b6       	in	r0, 0x3f	; 63
    7756:	f8 94       	cli
    7758:	de bf       	out	0x3e, r29	; 62
    775a:	0f be       	out	0x3f, r0	; 63
    775c:	cd bf       	out	0x3d, r28	; 61
    775e:	cf 82       	std	Y+7, r12	; 0x07
    7760:	d8 86       	std	Y+8, r13	; 0x08
    7762:	e9 86       	std	Y+9, r14	; 0x09
    7764:	fa 86       	std	Y+10, r15	; 0x0a
    7766:	0b 87       	std	Y+11, r16	; 0x0b
    7768:	1c 87       	std	Y+12, r17	; 0x0c
    776a:	2d 87       	std	Y+13, r18	; 0x0d
    776c:	3e 87       	std	Y+14, r19	; 0x0e
    776e:	4f 87       	std	Y+15, r20	; 0x0f
    7770:	58 8b       	std	Y+16, r21	; 0x10
    7772:	69 8b       	std	Y+17, r22	; 0x11
    7774:	7a 8b       	std	Y+18, r23	; 0x12
    7776:	8b 8b       	std	Y+19, r24	; 0x13
    7778:	9c 8b       	std	Y+20, r25	; 0x14
    777a:	ad 8a       	std	Y+21, r10	; 0x15
	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;
    777c:	8f 81       	ldd	r24, Y+7	; 0x07
    777e:	98 85       	ldd	r25, Y+8	; 0x08
    7780:	8d 83       	std	Y+5, r24	; 0x05

	for(loop=0u; loop <to ; loop++ ){
    7782:	1e 82       	std	Y+6, r1	; 0x06
    7784:	4c c0       	rjmp	.+152    	; 0x781e <DIO_ChannelGroupWrite+0xe2>
		uint8_t channel_id=channel_group_variabe.group_ids[loop];
    7786:	8e 81       	ldd	r24, Y+6	; 0x06
    7788:	88 2f       	mov	r24, r24
    778a:	90 e0       	ldi	r25, 0x00	; 0
    778c:	01 96       	adiw	r24, 0x01	; 1
    778e:	9c 01       	movw	r18, r24
    7790:	22 0f       	add	r18, r18
    7792:	33 1f       	adc	r19, r19
    7794:	ce 01       	movw	r24, r28
    7796:	01 96       	adiw	r24, 0x01	; 1
    7798:	82 0f       	add	r24, r18
    779a:	93 1f       	adc	r25, r19
    779c:	fc 01       	movw	r30, r24
    779e:	36 96       	adiw	r30, 0x06	; 6
    77a0:	80 81       	ld	r24, Z
    77a2:	91 81       	ldd	r25, Z+1	; 0x01
    77a4:	8c 83       	std	Y+4, r24	; 0x04
		uint8_t portid=dio_config_array[channel_id].port_id;
    77a6:	8c 81       	ldd	r24, Y+4	; 0x04
    77a8:	28 2f       	mov	r18, r24
    77aa:	30 e0       	ldi	r19, 0x00	; 0
    77ac:	c9 01       	movw	r24, r18
    77ae:	88 0f       	add	r24, r24
    77b0:	99 1f       	adc	r25, r25
    77b2:	82 0f       	add	r24, r18
    77b4:	93 1f       	adc	r25, r19
    77b6:	fc 01       	movw	r30, r24
    77b8:	ec 5c       	subi	r30, 0xCC	; 204
    77ba:	fd 4f       	sbci	r31, 0xFD	; 253
    77bc:	80 81       	ld	r24, Z
    77be:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[channel_id].pin_num;
    77c0:	8c 81       	ldd	r24, Y+4	; 0x04
    77c2:	28 2f       	mov	r18, r24
    77c4:	30 e0       	ldi	r19, 0x00	; 0
    77c6:	c9 01       	movw	r24, r18
    77c8:	88 0f       	add	r24, r24
    77ca:	99 1f       	adc	r25, r25
    77cc:	82 0f       	add	r24, r18
    77ce:	93 1f       	adc	r25, r19
    77d0:	fc 01       	movw	r30, r24
    77d2:	eb 5c       	subi	r30, 0xCB	; 203
    77d4:	fd 4f       	sbci	r31, 0xFD	; 253
    77d6:	80 81       	ld	r24, Z
    77d8:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t bit_data=READ_BIT(data,loop);
    77da:	8e 81       	ldd	r24, Y+6	; 0x06
    77dc:	28 2f       	mov	r18, r24
    77de:	30 e0       	ldi	r19, 0x00	; 0
    77e0:	81 e0       	ldi	r24, 0x01	; 1
    77e2:	90 e0       	ldi	r25, 0x00	; 0
    77e4:	02 c0       	rjmp	.+4      	; 0x77ea <DIO_ChannelGroupWrite+0xae>
    77e6:	88 0f       	add	r24, r24
    77e8:	99 1f       	adc	r25, r25
    77ea:	2a 95       	dec	r18
    77ec:	e2 f7       	brpl	.-8      	; 0x77e6 <DIO_ChannelGroupWrite+0xaa>
    77ee:	98 2f       	mov	r25, r24
    77f0:	8d 89       	ldd	r24, Y+21	; 0x15
    77f2:	89 23       	and	r24, r25
    77f4:	28 2f       	mov	r18, r24
    77f6:	30 e0       	ldi	r19, 0x00	; 0
    77f8:	8e 81       	ldd	r24, Y+6	; 0x06
    77fa:	88 2f       	mov	r24, r24
    77fc:	90 e0       	ldi	r25, 0x00	; 0
    77fe:	a9 01       	movw	r20, r18
    7800:	02 c0       	rjmp	.+4      	; 0x7806 <DIO_ChannelGroupWrite+0xca>
    7802:	55 95       	asr	r21
    7804:	47 95       	ror	r20
    7806:	8a 95       	dec	r24
    7808:	e2 f7       	brpl	.-8      	; 0x7802 <DIO_ChannelGroupWrite+0xc6>
    780a:	ca 01       	movw	r24, r20
    780c:	89 83       	std	Y+1, r24	; 0x01
		GPIO_writePin(portid,pin_num,bit_data);
    780e:	8b 81       	ldd	r24, Y+3	; 0x03
    7810:	6a 81       	ldd	r22, Y+2	; 0x02
    7812:	49 81       	ldd	r20, Y+1	; 0x01
    7814:	0e 94 2a 38 	call	0x7054	; 0x7054 <GPIO_writePin>
void DIO_ChannelGroupWrite(ChannelGroupType channel_group_variabe , uint8_t data)
{
	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;

	for(loop=0u; loop <to ; loop++ ){
    7818:	8e 81       	ldd	r24, Y+6	; 0x06
    781a:	8f 5f       	subi	r24, 0xFF	; 255
    781c:	8e 83       	std	Y+6, r24	; 0x06
    781e:	9e 81       	ldd	r25, Y+6	; 0x06
    7820:	8d 81       	ldd	r24, Y+5	; 0x05
    7822:	98 17       	cp	r25, r24
    7824:	08 f4       	brcc	.+2      	; 0x7828 <DIO_ChannelGroupWrite+0xec>
    7826:	af cf       	rjmp	.-162    	; 0x7786 <DIO_ChannelGroupWrite+0x4a>
		GPIO_writePin(portid,pin_num,bit_data);

	}


}
    7828:	65 96       	adiw	r28, 0x15	; 21
    782a:	0f b6       	in	r0, 0x3f	; 63
    782c:	f8 94       	cli
    782e:	de bf       	out	0x3e, r29	; 62
    7830:	0f be       	out	0x3f, r0	; 63
    7832:	cd bf       	out	0x3d, r28	; 61
    7834:	cf 91       	pop	r28
    7836:	df 91       	pop	r29
    7838:	1f 91       	pop	r17
    783a:	0f 91       	pop	r16
    783c:	ff 90       	pop	r15
    783e:	ef 90       	pop	r14
    7840:	df 90       	pop	r13
    7842:	cf 90       	pop	r12
    7844:	af 90       	pop	r10
    7846:	08 95       	ret

00007848 <DIO_ChannelGroupRead>:


void DIO_ChannelGroupRead(ChannelGroupType channel_group_variabe ,uint8_t * data_ptr)
{
    7848:	af 92       	push	r10
    784a:	bf 92       	push	r11
    784c:	cf 92       	push	r12
    784e:	df 92       	push	r13
    7850:	ef 92       	push	r14
    7852:	ff 92       	push	r15
    7854:	0f 93       	push	r16
    7856:	1f 93       	push	r17
    7858:	df 93       	push	r29
    785a:	cf 93       	push	r28
    785c:	cd b7       	in	r28, 0x3d	; 61
    785e:	de b7       	in	r29, 0x3e	; 62
    7860:	66 97       	sbiw	r28, 0x16	; 22
    7862:	0f b6       	in	r0, 0x3f	; 63
    7864:	f8 94       	cli
    7866:	de bf       	out	0x3e, r29	; 62
    7868:	0f be       	out	0x3f, r0	; 63
    786a:	cd bf       	out	0x3d, r28	; 61
    786c:	cf 82       	std	Y+7, r12	; 0x07
    786e:	d8 86       	std	Y+8, r13	; 0x08
    7870:	e9 86       	std	Y+9, r14	; 0x09
    7872:	fa 86       	std	Y+10, r15	; 0x0a
    7874:	0b 87       	std	Y+11, r16	; 0x0b
    7876:	1c 87       	std	Y+12, r17	; 0x0c
    7878:	2d 87       	std	Y+13, r18	; 0x0d
    787a:	3e 87       	std	Y+14, r19	; 0x0e
    787c:	4f 87       	std	Y+15, r20	; 0x0f
    787e:	58 8b       	std	Y+16, r21	; 0x10
    7880:	69 8b       	std	Y+17, r22	; 0x11
    7882:	7a 8b       	std	Y+18, r23	; 0x12
    7884:	8b 8b       	std	Y+19, r24	; 0x13
    7886:	9c 8b       	std	Y+20, r25	; 0x14
    7888:	be 8a       	std	Y+22, r11	; 0x16
    788a:	ad 8a       	std	Y+21, r10	; 0x15

	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;
    788c:	8f 81       	ldd	r24, Y+7	; 0x07
    788e:	98 85       	ldd	r25, Y+8	; 0x08
    7890:	8d 83       	std	Y+5, r24	; 0x05

	for(loop=0u; loop <to ; loop++ ){
    7892:	1e 82       	std	Y+6, r1	; 0x06
    7894:	5d c0       	rjmp	.+186    	; 0x7950 <DIO_ChannelGroupRead+0x108>
		uint8_t channel_id=channel_group_variabe.group_ids[loop];
    7896:	8e 81       	ldd	r24, Y+6	; 0x06
    7898:	88 2f       	mov	r24, r24
    789a:	90 e0       	ldi	r25, 0x00	; 0
    789c:	01 96       	adiw	r24, 0x01	; 1
    789e:	9c 01       	movw	r18, r24
    78a0:	22 0f       	add	r18, r18
    78a2:	33 1f       	adc	r19, r19
    78a4:	ce 01       	movw	r24, r28
    78a6:	01 96       	adiw	r24, 0x01	; 1
    78a8:	82 0f       	add	r24, r18
    78aa:	93 1f       	adc	r25, r19
    78ac:	fc 01       	movw	r30, r24
    78ae:	36 96       	adiw	r30, 0x06	; 6
    78b0:	80 81       	ld	r24, Z
    78b2:	91 81       	ldd	r25, Z+1	; 0x01
    78b4:	8c 83       	std	Y+4, r24	; 0x04
		uint8_t portid=dio_config_array[channel_id].port_id;
    78b6:	8c 81       	ldd	r24, Y+4	; 0x04
    78b8:	28 2f       	mov	r18, r24
    78ba:	30 e0       	ldi	r19, 0x00	; 0
    78bc:	c9 01       	movw	r24, r18
    78be:	88 0f       	add	r24, r24
    78c0:	99 1f       	adc	r25, r25
    78c2:	82 0f       	add	r24, r18
    78c4:	93 1f       	adc	r25, r19
    78c6:	fc 01       	movw	r30, r24
    78c8:	ec 5c       	subi	r30, 0xCC	; 204
    78ca:	fd 4f       	sbci	r31, 0xFD	; 253
    78cc:	80 81       	ld	r24, Z
    78ce:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[channel_id].pin_num;
    78d0:	8c 81       	ldd	r24, Y+4	; 0x04
    78d2:	28 2f       	mov	r18, r24
    78d4:	30 e0       	ldi	r19, 0x00	; 0
    78d6:	c9 01       	movw	r24, r18
    78d8:	88 0f       	add	r24, r24
    78da:	99 1f       	adc	r25, r25
    78dc:	82 0f       	add	r24, r18
    78de:	93 1f       	adc	r25, r19
    78e0:	fc 01       	movw	r30, r24
    78e2:	eb 5c       	subi	r30, 0xCB	; 203
    78e4:	fd 4f       	sbci	r31, 0xFD	; 253
    78e6:	80 81       	ld	r24, Z
    78e8:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t data = GPIO_readPin(portid, pin_num);
    78ea:	8b 81       	ldd	r24, Y+3	; 0x03
    78ec:	6a 81       	ldd	r22, Y+2	; 0x02
    78ee:	0e 94 79 39 	call	0x72f2	; 0x72f2 <GPIO_readPin>
    78f2:	89 83       	std	Y+1, r24	; 0x01
		if(data == LOGIC_HIGH){
    78f4:	89 81       	ldd	r24, Y+1	; 0x01
    78f6:	81 30       	cpi	r24, 0x01	; 1
    78f8:	a1 f4       	brne	.+40     	; 0x7922 <DIO_ChannelGroupRead+0xda>
			SET_BIT(* data_ptr,loop);
    78fa:	ed 89       	ldd	r30, Y+21	; 0x15
    78fc:	fe 89       	ldd	r31, Y+22	; 0x16
    78fe:	80 81       	ld	r24, Z
    7900:	48 2f       	mov	r20, r24
    7902:	8e 81       	ldd	r24, Y+6	; 0x06
    7904:	28 2f       	mov	r18, r24
    7906:	30 e0       	ldi	r19, 0x00	; 0
    7908:	81 e0       	ldi	r24, 0x01	; 1
    790a:	90 e0       	ldi	r25, 0x00	; 0
    790c:	02 2e       	mov	r0, r18
    790e:	02 c0       	rjmp	.+4      	; 0x7914 <DIO_ChannelGroupRead+0xcc>
    7910:	88 0f       	add	r24, r24
    7912:	99 1f       	adc	r25, r25
    7914:	0a 94       	dec	r0
    7916:	e2 f7       	brpl	.-8      	; 0x7910 <DIO_ChannelGroupRead+0xc8>
    7918:	84 2b       	or	r24, r20
    791a:	ed 89       	ldd	r30, Y+21	; 0x15
    791c:	fe 89       	ldd	r31, Y+22	; 0x16
    791e:	80 83       	st	Z, r24
    7920:	14 c0       	rjmp	.+40     	; 0x794a <DIO_ChannelGroupRead+0x102>
		}else{
			CLEAR_BIT(* data_ptr,loop);
    7922:	ed 89       	ldd	r30, Y+21	; 0x15
    7924:	fe 89       	ldd	r31, Y+22	; 0x16
    7926:	80 81       	ld	r24, Z
    7928:	48 2f       	mov	r20, r24
    792a:	8e 81       	ldd	r24, Y+6	; 0x06
    792c:	28 2f       	mov	r18, r24
    792e:	30 e0       	ldi	r19, 0x00	; 0
    7930:	81 e0       	ldi	r24, 0x01	; 1
    7932:	90 e0       	ldi	r25, 0x00	; 0
    7934:	02 2e       	mov	r0, r18
    7936:	02 c0       	rjmp	.+4      	; 0x793c <DIO_ChannelGroupRead+0xf4>
    7938:	88 0f       	add	r24, r24
    793a:	99 1f       	adc	r25, r25
    793c:	0a 94       	dec	r0
    793e:	e2 f7       	brpl	.-8      	; 0x7938 <DIO_ChannelGroupRead+0xf0>
    7940:	80 95       	com	r24
    7942:	84 23       	and	r24, r20
    7944:	ed 89       	ldd	r30, Y+21	; 0x15
    7946:	fe 89       	ldd	r31, Y+22	; 0x16
    7948:	80 83       	st	Z, r24
{

	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;

	for(loop=0u; loop <to ; loop++ ){
    794a:	8e 81       	ldd	r24, Y+6	; 0x06
    794c:	8f 5f       	subi	r24, 0xFF	; 255
    794e:	8e 83       	std	Y+6, r24	; 0x06
    7950:	9e 81       	ldd	r25, Y+6	; 0x06
    7952:	8d 81       	ldd	r24, Y+5	; 0x05
    7954:	98 17       	cp	r25, r24
    7956:	08 f4       	brcc	.+2      	; 0x795a <DIO_ChannelGroupRead+0x112>
    7958:	9e cf       	rjmp	.-196    	; 0x7896 <DIO_ChannelGroupRead+0x4e>
		}else{
			CLEAR_BIT(* data_ptr,loop);
		}
	}

}
    795a:	66 96       	adiw	r28, 0x16	; 22
    795c:	0f b6       	in	r0, 0x3f	; 63
    795e:	f8 94       	cli
    7960:	de bf       	out	0x3e, r29	; 62
    7962:	0f be       	out	0x3f, r0	; 63
    7964:	cd bf       	out	0x3d, r28	; 61
    7966:	cf 91       	pop	r28
    7968:	df 91       	pop	r29
    796a:	1f 91       	pop	r17
    796c:	0f 91       	pop	r16
    796e:	ff 90       	pop	r15
    7970:	ef 90       	pop	r14
    7972:	df 90       	pop	r13
    7974:	cf 90       	pop	r12
    7976:	bf 90       	pop	r11
    7978:	af 90       	pop	r10
    797a:	08 95       	ret

0000797c <main>:


/*TimerHandle_t xTimer2;*/

int main(void)
{
    797c:	ef 92       	push	r14
    797e:	ff 92       	push	r15
    7980:	0f 93       	push	r16
    7982:	1f 93       	push	r17
    7984:	df 93       	push	r29
    7986:	cf 93       	push	r28
    7988:	00 d0       	rcall	.+0      	; 0x798a <main+0xe>
    798a:	00 d0       	rcall	.+0      	; 0x798c <main+0x10>
    798c:	00 d0       	rcall	.+0      	; 0x798e <main+0x12>
    798e:	cd b7       	in	r28, 0x3d	; 61
    7990:	de b7       	in	r29, 0x3e	; 62
	DIO_init();  /*proxy pattern*/
    7992:	0e 94 5d 3b 	call	0x76ba	; 0x76ba <DIO_init>


	xTaskCreate(Task2_HandleData,"third",configMINIMAL_STACK_SIZE,NULL,0,&task2ptr);/* polling Handle data function*/
    7996:	81 e4       	ldi	r24, 0x41	; 65
    7998:	9d e3       	ldi	r25, 0x3D	; 61
    799a:	2d e0       	ldi	r18, 0x0D	; 13
    799c:	31 e0       	ldi	r19, 0x01	; 1
    799e:	ee ee       	ldi	r30, 0xEE	; 238
    79a0:	f8 e0       	ldi	r31, 0x08	; 8
    79a2:	b9 01       	movw	r22, r18
    79a4:	45 e5       	ldi	r20, 0x55	; 85
    79a6:	50 e0       	ldi	r21, 0x00	; 0
    79a8:	20 e0       	ldi	r18, 0x00	; 0
    79aa:	30 e0       	ldi	r19, 0x00	; 0
    79ac:	00 e0       	ldi	r16, 0x00	; 0
    79ae:	7f 01       	movw	r14, r30
    79b0:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <xTaskCreate>

	TimerHandle_t xTimer1 = xTimerCreate("timer1",10/portTICK_PERIOD_MS,pdTRUE,0,Task1_GetData); /* simulate poller timer */
    79b4:	ee e2       	ldi	r30, 0x2E	; 46
    79b6:	fd e3       	ldi	r31, 0x3D	; 61
    79b8:	83 e1       	ldi	r24, 0x13	; 19
    79ba:	91 e0       	ldi	r25, 0x01	; 1
    79bc:	6a e0       	ldi	r22, 0x0A	; 10
    79be:	70 e0       	ldi	r23, 0x00	; 0
    79c0:	41 e0       	ldi	r20, 0x01	; 1
    79c2:	20 e0       	ldi	r18, 0x00	; 0
    79c4:	30 e0       	ldi	r19, 0x00	; 0
    79c6:	8f 01       	movw	r16, r30
    79c8:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <xTimerCreate>
    79cc:	9e 83       	std	Y+6, r25	; 0x06
    79ce:	8d 83       	std	Y+5, r24	; 0x05
	TimerHandle_t xTimer2 = xTimerCreate("timer2",500/portTICK_PERIOD_MS,pdTRUE,0,Task3_ToggleLED);
    79d0:	ea e4       	ldi	r30, 0x4A	; 74
    79d2:	fd e3       	ldi	r31, 0x3D	; 61
    79d4:	8a e1       	ldi	r24, 0x1A	; 26
    79d6:	91 e0       	ldi	r25, 0x01	; 1
    79d8:	64 ef       	ldi	r22, 0xF4	; 244
    79da:	71 e0       	ldi	r23, 0x01	; 1
    79dc:	41 e0       	ldi	r20, 0x01	; 1
    79de:	20 e0       	ldi	r18, 0x00	; 0
    79e0:	30 e0       	ldi	r19, 0x00	; 0
    79e2:	8f 01       	movw	r16, r30
    79e4:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <xTimerCreate>
    79e8:	9c 83       	std	Y+4, r25	; 0x04
    79ea:	8b 83       	std	Y+3, r24	; 0x03
	TimerHandle_t xTimer3 = xTimerCreate("timer3",30/portTICK_PERIOD_MS,pdTRUE,0,Task4_PWM); /*500/16(*5%)=31.26ms = 30ms*/
    79ec:	ed e5       	ldi	r30, 0x5D	; 93
    79ee:	fd e3       	ldi	r31, 0x3D	; 61
    79f0:	81 e2       	ldi	r24, 0x21	; 33
    79f2:	91 e0       	ldi	r25, 0x01	; 1
    79f4:	6e e1       	ldi	r22, 0x1E	; 30
    79f6:	70 e0       	ldi	r23, 0x00	; 0
    79f8:	41 e0       	ldi	r20, 0x01	; 1
    79fa:	20 e0       	ldi	r18, 0x00	; 0
    79fc:	30 e0       	ldi	r19, 0x00	; 0
    79fe:	8f 01       	movw	r16, r30
    7a00:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <xTimerCreate>
    7a04:	9a 83       	std	Y+2, r25	; 0x02
    7a06:	89 83       	std	Y+1, r24	; 0x01


	xTimerStart(xTimer1, 1);
    7a08:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <xTaskGetTickCount>
    7a0c:	9c 01       	movw	r18, r24
    7a0e:	8d 81       	ldd	r24, Y+5	; 0x05
    7a10:	9e 81       	ldd	r25, Y+6	; 0x06
    7a12:	61 e0       	ldi	r22, 0x01	; 1
    7a14:	a9 01       	movw	r20, r18
    7a16:	20 e0       	ldi	r18, 0x00	; 0
    7a18:	30 e0       	ldi	r19, 0x00	; 0
    7a1a:	01 e0       	ldi	r16, 0x01	; 1
    7a1c:	10 e0       	ldi	r17, 0x00	; 0
    7a1e:	0e 94 82 2f 	call	0x5f04	; 0x5f04 <xTimerGenericCommand>
	xTimerStart(xTimer2, 1);
    7a22:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <xTaskGetTickCount>
    7a26:	9c 01       	movw	r18, r24
    7a28:	8b 81       	ldd	r24, Y+3	; 0x03
    7a2a:	9c 81       	ldd	r25, Y+4	; 0x04
    7a2c:	61 e0       	ldi	r22, 0x01	; 1
    7a2e:	a9 01       	movw	r20, r18
    7a30:	20 e0       	ldi	r18, 0x00	; 0
    7a32:	30 e0       	ldi	r19, 0x00	; 0
    7a34:	01 e0       	ldi	r16, 0x01	; 1
    7a36:	10 e0       	ldi	r17, 0x00	; 0
    7a38:	0e 94 82 2f 	call	0x5f04	; 0x5f04 <xTimerGenericCommand>
	xTimerStart(xTimer3, 1);
    7a3c:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <xTaskGetTickCount>
    7a40:	9c 01       	movw	r18, r24
    7a42:	89 81       	ldd	r24, Y+1	; 0x01
    7a44:	9a 81       	ldd	r25, Y+2	; 0x02
    7a46:	61 e0       	ldi	r22, 0x01	; 1
    7a48:	a9 01       	movw	r20, r18
    7a4a:	20 e0       	ldi	r18, 0x00	; 0
    7a4c:	30 e0       	ldi	r19, 0x00	; 0
    7a4e:	01 e0       	ldi	r16, 0x01	; 1
    7a50:	10 e0       	ldi	r17, 0x00	; 0
    7a52:	0e 94 82 2f 	call	0x5f04	; 0x5f04 <xTimerGenericCommand>

	vTaskStartScheduler();
    7a56:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <vTaskStartScheduler>
    7a5a:	ff cf       	rjmp	.-2      	; 0x7a5a <main+0xde>

00007a5c <Task1_GetData>:
}



void Task1_GetData(void)
{
    7a5c:	df 93       	push	r29
    7a5e:	cf 93       	push	r28
    7a60:	cd b7       	in	r28, 0x3d	; 61
    7a62:	de b7       	in	r29, 0x3e	; 62
	ButtonStateTest = Get_Data();
    7a64:	0e 94 f5 35 	call	0x6bea	; 0x6bea <Get_Data>
    7a68:	dc 01       	movw	r26, r24
    7a6a:	cb 01       	movw	r24, r22
    7a6c:	80 93 e9 08 	sts	0x08E9, r24
    7a70:	90 93 ea 08 	sts	0x08EA, r25
    7a74:	a0 93 eb 08 	sts	0x08EB, r26
    7a78:	b0 93 ec 08 	sts	0x08EC, r27
}
    7a7c:	cf 91       	pop	r28
    7a7e:	df 91       	pop	r29
    7a80:	08 95       	ret

00007a82 <Task2_HandleData>:

void Task2_HandleData(void)
{
    7a82:	df 93       	push	r29
    7a84:	cf 93       	push	r28
    7a86:	cd b7       	in	r28, 0x3d	; 61
    7a88:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
		Handle_data(&ButtonStateTest);
    7a8a:	89 ee       	ldi	r24, 0xE9	; 233
    7a8c:	98 e0       	ldi	r25, 0x08	; 8
    7a8e:	0e 94 23 34 	call	0x6846	; 0x6846 <Handle_data>
    7a92:	fb cf       	rjmp	.-10     	; 0x7a8a <Task2_HandleData+0x8>

00007a94 <Task3_ToggleLED>:
	}
}


void Task3_ToggleLED(void)
{
    7a94:	df 93       	push	r29
    7a96:	cf 93       	push	r28
    7a98:	0f 92       	push	r0
    7a9a:	cd b7       	in	r28, 0x3d	; 61
    7a9c:	de b7       	in	r29, 0x3e	; 62
	ToggleLED = !ToggleLED;
    7a9e:	80 91 da 08 	lds	r24, 0x08DA
    7aa2:	19 82       	std	Y+1, r1	; 0x01
    7aa4:	88 23       	and	r24, r24
    7aa6:	11 f4       	brne	.+4      	; 0x7aac <Task3_ToggleLED+0x18>
    7aa8:	81 e0       	ldi	r24, 0x01	; 1
    7aaa:	89 83       	std	Y+1, r24	; 0x01
    7aac:	89 81       	ldd	r24, Y+1	; 0x01
    7aae:	80 93 da 08 	sts	0x08DA, r24
}
    7ab2:	0f 90       	pop	r0
    7ab4:	cf 91       	pop	r28
    7ab6:	df 91       	pop	r29
    7ab8:	08 95       	ret

00007aba <Task4_PWM>:

/*
 * Increment or Decrement by 13 digital value ~= 5%
 */
void Task4_PWM(void)
{
    7aba:	df 93       	push	r29
    7abc:	cf 93       	push	r28
    7abe:	cd b7       	in	r28, 0x3d	; 61
    7ac0:	de b7       	in	r29, 0x3e	; 62
	if(ToggleLED == TRUE && LEDIntensity < (unsigned char)204) /*204 = 80%*/
    7ac2:	80 91 da 08 	lds	r24, 0x08DA
    7ac6:	81 30       	cpi	r24, 0x01	; 1
    7ac8:	51 f4       	brne	.+20     	; 0x7ade <Task4_PWM+0x24>
    7aca:	80 91 31 02 	lds	r24, 0x0231
    7ace:	8c 3c       	cpi	r24, 0xCC	; 204
    7ad0:	30 f4       	brcc	.+12     	; 0x7ade <Task4_PWM+0x24>
	{
		LEDIntensity+= (unsigned char)13;
    7ad2:	80 91 31 02 	lds	r24, 0x0231
    7ad6:	83 5f       	subi	r24, 0xF3	; 243
    7ad8:	80 93 31 02 	sts	0x0231, r24
    7adc:	0d c0       	rjmp	.+26     	; 0x7af8 <Task4_PWM+0x3e>

	}
	else if (ToggleLED == FALSE && LEDIntensity > (unsigned char)25)/*25 = 10%*/
    7ade:	80 91 da 08 	lds	r24, 0x08DA
    7ae2:	88 23       	and	r24, r24
    7ae4:	49 f4       	brne	.+18     	; 0x7af8 <Task4_PWM+0x3e>
    7ae6:	80 91 31 02 	lds	r24, 0x0231
    7aea:	8a 31       	cpi	r24, 0x1A	; 26
    7aec:	28 f0       	brcs	.+10     	; 0x7af8 <Task4_PWM+0x3e>
	{
		LEDIntensity-= (unsigned char)13;
    7aee:	80 91 31 02 	lds	r24, 0x0231
    7af2:	8d 50       	subi	r24, 0x0D	; 13
    7af4:	80 93 31 02 	sts	0x0231, r24

	}
}
    7af8:	cf 91       	pop	r28
    7afa:	df 91       	pop	r29
    7afc:	08 95       	ret

00007afe <PWM_Timer0_Start>:
#include "pwm_timer0.h"



void PWM_Timer0_Start(uint8 duty_cycle)
{
    7afe:	df 93       	push	r29
    7b00:	cf 93       	push	r28
    7b02:	0f 92       	push	r0
    7b04:	cd b7       	in	r28, 0x3d	; 61
    7b06:	de b7       	in	r29, 0x3e	; 62
    7b08:	89 83       	std	Y+1, r24	; 0x01
	/*	The function responsible for trigger the Timer0 with the PWM Mode. */

	TCNT0 = 0; //Set Timer Initial value
    7b0a:	e2 e5       	ldi	r30, 0x52	; 82
    7b0c:	f0 e0       	ldi	r31, 0x00	; 0
    7b0e:	10 82       	st	Z, r1
	OCR0 = duty_cycle; // Set Compare Value
    7b10:	e1 e5       	ldi	r30, 0x51	; 81
    7b12:	f0 e0       	ldi	r31, 0x00	; 0
    7b14:	89 81       	ldd	r24, Y+1	; 0x01
    7b16:	80 83       	st	Z, r24
	GPIO_setupPinDirection(PWM_PORT_ID, PWM_PIN_ID, PIN_OUTPUT); //Setup the PWM pin as Output pin
    7b18:	81 e0       	ldi	r24, 0x01	; 1
    7b1a:	64 e0       	ldi	r22, 0x04	; 4
    7b1c:	41 e0       	ldi	r20, 0x01	; 1
    7b1e:	0e 94 db 36 	call	0x6db6	; 0x6db6 <GPIO_setupPinDirection>
	 * 1. Fast PWM mode FOC0=0
	 * 2. Fast PWM Mode WGM01=1 & WGM00=1
	 * 3. (non inverted mode) COM00=0 & COM01=1
	 * 4. clock = F_CPU/8 = (500Hz) .. CS00=0 CS01=1 CS02=0
	 */
	SET_BIT(TCCR0,WGM00);
    7b22:	a3 e5       	ldi	r26, 0x53	; 83
    7b24:	b0 e0       	ldi	r27, 0x00	; 0
    7b26:	e3 e5       	ldi	r30, 0x53	; 83
    7b28:	f0 e0       	ldi	r31, 0x00	; 0
    7b2a:	80 81       	ld	r24, Z
    7b2c:	80 64       	ori	r24, 0x40	; 64
    7b2e:	8c 93       	st	X, r24
	SET_BIT(TCCR0,WGM01);
    7b30:	a3 e5       	ldi	r26, 0x53	; 83
    7b32:	b0 e0       	ldi	r27, 0x00	; 0
    7b34:	e3 e5       	ldi	r30, 0x53	; 83
    7b36:	f0 e0       	ldi	r31, 0x00	; 0
    7b38:	80 81       	ld	r24, Z
    7b3a:	88 60       	ori	r24, 0x08	; 8
    7b3c:	8c 93       	st	X, r24
	SET_BIT(TCCR0,COM01);
    7b3e:	a3 e5       	ldi	r26, 0x53	; 83
    7b40:	b0 e0       	ldi	r27, 0x00	; 0
    7b42:	e3 e5       	ldi	r30, 0x53	; 83
    7b44:	f0 e0       	ldi	r31, 0x00	; 0
    7b46:	80 81       	ld	r24, Z
    7b48:	80 62       	ori	r24, 0x20	; 32
    7b4a:	8c 93       	st	X, r24
	SET_BIT(TCCR0,CS00);
    7b4c:	a3 e5       	ldi	r26, 0x53	; 83
    7b4e:	b0 e0       	ldi	r27, 0x00	; 0
    7b50:	e3 e5       	ldi	r30, 0x53	; 83
    7b52:	f0 e0       	ldi	r31, 0x00	; 0
    7b54:	80 81       	ld	r24, Z
    7b56:	81 60       	ori	r24, 0x01	; 1
    7b58:	8c 93       	st	X, r24
}
    7b5a:	0f 90       	pop	r0
    7b5c:	cf 91       	pop	r28
    7b5e:	df 91       	pop	r29
    7b60:	08 95       	ret

00007b62 <PWM_Timer2_Start>:
#include "gpio.h"
#include "common_macros.h"


void PWM_Timer2_Start(uint8 duty_cycle)
{
    7b62:	df 93       	push	r29
    7b64:	cf 93       	push	r28
    7b66:	0f 92       	push	r0
    7b68:	cd b7       	in	r28, 0x3d	; 61
    7b6a:	de b7       	in	r29, 0x3e	; 62
    7b6c:	89 83       	std	Y+1, r24	; 0x01
	TCNT2 = 0;    // Set Timer initial value to 0
    7b6e:	e4 e4       	ldi	r30, 0x44	; 68
    7b70:	f0 e0       	ldi	r31, 0x00	; 0
    7b72:	10 82       	st	Z, r1
	OCR2  = duty_cycle; // Set Compare Value
    7b74:	e3 e4       	ldi	r30, 0x43	; 67
    7b76:	f0 e0       	ldi	r31, 0x00	; 0
    7b78:	89 81       	ldd	r24, Y+1	; 0x01
    7b7a:	80 83       	st	Z, r24
	GPIO_setupPinDirection(PWM2_PORT_ID, PWM2_PIN_ID, PIN_OUTPUT); //Setup the PWM pin as Output pin
    7b7c:	81 e0       	ldi	r24, 0x01	; 1
    7b7e:	67 e0       	ldi	r22, 0x07	; 7
    7b80:	41 e0       	ldi	r20, 0x01	; 1
    7b82:	0e 94 db 36 	call	0x6db6	; 0x6db6 <GPIO_setupPinDirection>
	 * 1. Non PWM mode FOC0=1
	 * 2. CTC Mode WGM01=1 & WGM00=0
	 * 3. No need for OC0 in this example so COM00=0 & COM01=0
	 * 4. clock = F_CPU/8 CS22=0 CS21=1 CS20=0
	 */
	SET_BIT(TCCR2,WGM00);
    7b86:	a5 e4       	ldi	r26, 0x45	; 69
    7b88:	b0 e0       	ldi	r27, 0x00	; 0
    7b8a:	e5 e4       	ldi	r30, 0x45	; 69
    7b8c:	f0 e0       	ldi	r31, 0x00	; 0
    7b8e:	80 81       	ld	r24, Z
    7b90:	80 64       	ori	r24, 0x40	; 64
    7b92:	8c 93       	st	X, r24
	SET_BIT(TCCR2,WGM01);
    7b94:	a5 e4       	ldi	r26, 0x45	; 69
    7b96:	b0 e0       	ldi	r27, 0x00	; 0
    7b98:	e5 e4       	ldi	r30, 0x45	; 69
    7b9a:	f0 e0       	ldi	r31, 0x00	; 0
    7b9c:	80 81       	ld	r24, Z
    7b9e:	88 60       	ori	r24, 0x08	; 8
    7ba0:	8c 93       	st	X, r24
	SET_BIT(TCCR2,COM01);
    7ba2:	a5 e4       	ldi	r26, 0x45	; 69
    7ba4:	b0 e0       	ldi	r27, 0x00	; 0
    7ba6:	e5 e4       	ldi	r30, 0x45	; 69
    7ba8:	f0 e0       	ldi	r31, 0x00	; 0
    7baa:	80 81       	ld	r24, Z
    7bac:	80 62       	ori	r24, 0x20	; 32
    7bae:	8c 93       	st	X, r24
	SET_BIT(TCCR2,CS00);
    7bb0:	a5 e4       	ldi	r26, 0x45	; 69
    7bb2:	b0 e0       	ldi	r27, 0x00	; 0
    7bb4:	e5 e4       	ldi	r30, 0x45	; 69
    7bb6:	f0 e0       	ldi	r31, 0x00	; 0
    7bb8:	80 81       	ld	r24, Z
    7bba:	81 60       	ori	r24, 0x01	; 1
    7bbc:	8c 93       	st	X, r24
}
    7bbe:	0f 90       	pop	r0
    7bc0:	cf 91       	pop	r28
    7bc2:	df 91       	pop	r29
    7bc4:	08 95       	ret

00007bc6 <__udivmodqi4>:
    7bc6:	99 1b       	sub	r25, r25
    7bc8:	79 e0       	ldi	r23, 0x09	; 9
    7bca:	04 c0       	rjmp	.+8      	; 0x7bd4 <__udivmodqi4_ep>

00007bcc <__udivmodqi4_loop>:
    7bcc:	99 1f       	adc	r25, r25
    7bce:	96 17       	cp	r25, r22
    7bd0:	08 f0       	brcs	.+2      	; 0x7bd4 <__udivmodqi4_ep>
    7bd2:	96 1b       	sub	r25, r22

00007bd4 <__udivmodqi4_ep>:
    7bd4:	88 1f       	adc	r24, r24
    7bd6:	7a 95       	dec	r23
    7bd8:	c9 f7       	brne	.-14     	; 0x7bcc <__udivmodqi4_loop>
    7bda:	80 95       	com	r24
    7bdc:	08 95       	ret

00007bde <__udivmodhi4>:
    7bde:	aa 1b       	sub	r26, r26
    7be0:	bb 1b       	sub	r27, r27
    7be2:	51 e1       	ldi	r21, 0x11	; 17
    7be4:	07 c0       	rjmp	.+14     	; 0x7bf4 <__udivmodhi4_ep>

00007be6 <__udivmodhi4_loop>:
    7be6:	aa 1f       	adc	r26, r26
    7be8:	bb 1f       	adc	r27, r27
    7bea:	a6 17       	cp	r26, r22
    7bec:	b7 07       	cpc	r27, r23
    7bee:	10 f0       	brcs	.+4      	; 0x7bf4 <__udivmodhi4_ep>
    7bf0:	a6 1b       	sub	r26, r22
    7bf2:	b7 0b       	sbc	r27, r23

00007bf4 <__udivmodhi4_ep>:
    7bf4:	88 1f       	adc	r24, r24
    7bf6:	99 1f       	adc	r25, r25
    7bf8:	5a 95       	dec	r21
    7bfa:	a9 f7       	brne	.-22     	; 0x7be6 <__udivmodhi4_loop>
    7bfc:	80 95       	com	r24
    7bfe:	90 95       	com	r25
    7c00:	bc 01       	movw	r22, r24
    7c02:	cd 01       	movw	r24, r26
    7c04:	08 95       	ret

00007c06 <__prologue_saves__>:
    7c06:	2f 92       	push	r2
    7c08:	3f 92       	push	r3
    7c0a:	4f 92       	push	r4
    7c0c:	5f 92       	push	r5
    7c0e:	6f 92       	push	r6
    7c10:	7f 92       	push	r7
    7c12:	8f 92       	push	r8
    7c14:	9f 92       	push	r9
    7c16:	af 92       	push	r10
    7c18:	bf 92       	push	r11
    7c1a:	cf 92       	push	r12
    7c1c:	df 92       	push	r13
    7c1e:	ef 92       	push	r14
    7c20:	ff 92       	push	r15
    7c22:	0f 93       	push	r16
    7c24:	1f 93       	push	r17
    7c26:	cf 93       	push	r28
    7c28:	df 93       	push	r29
    7c2a:	cd b7       	in	r28, 0x3d	; 61
    7c2c:	de b7       	in	r29, 0x3e	; 62
    7c2e:	ca 1b       	sub	r28, r26
    7c30:	db 0b       	sbc	r29, r27
    7c32:	0f b6       	in	r0, 0x3f	; 63
    7c34:	f8 94       	cli
    7c36:	de bf       	out	0x3e, r29	; 62
    7c38:	0f be       	out	0x3f, r0	; 63
    7c3a:	cd bf       	out	0x3d, r28	; 61
    7c3c:	09 94       	ijmp

00007c3e <__epilogue_restores__>:
    7c3e:	2a 88       	ldd	r2, Y+18	; 0x12
    7c40:	39 88       	ldd	r3, Y+17	; 0x11
    7c42:	48 88       	ldd	r4, Y+16	; 0x10
    7c44:	5f 84       	ldd	r5, Y+15	; 0x0f
    7c46:	6e 84       	ldd	r6, Y+14	; 0x0e
    7c48:	7d 84       	ldd	r7, Y+13	; 0x0d
    7c4a:	8c 84       	ldd	r8, Y+12	; 0x0c
    7c4c:	9b 84       	ldd	r9, Y+11	; 0x0b
    7c4e:	aa 84       	ldd	r10, Y+10	; 0x0a
    7c50:	b9 84       	ldd	r11, Y+9	; 0x09
    7c52:	c8 84       	ldd	r12, Y+8	; 0x08
    7c54:	df 80       	ldd	r13, Y+7	; 0x07
    7c56:	ee 80       	ldd	r14, Y+6	; 0x06
    7c58:	fd 80       	ldd	r15, Y+5	; 0x05
    7c5a:	0c 81       	ldd	r16, Y+4	; 0x04
    7c5c:	1b 81       	ldd	r17, Y+3	; 0x03
    7c5e:	aa 81       	ldd	r26, Y+2	; 0x02
    7c60:	b9 81       	ldd	r27, Y+1	; 0x01
    7c62:	ce 0f       	add	r28, r30
    7c64:	d1 1d       	adc	r29, r1
    7c66:	0f b6       	in	r0, 0x3f	; 63
    7c68:	f8 94       	cli
    7c6a:	de bf       	out	0x3e, r29	; 62
    7c6c:	0f be       	out	0x3f, r0	; 63
    7c6e:	cd bf       	out	0x3d, r28	; 61
    7c70:	ed 01       	movw	r28, r26
    7c72:	08 95       	ret

00007c74 <memcpy>:
    7c74:	fb 01       	movw	r30, r22
    7c76:	dc 01       	movw	r26, r24
    7c78:	02 c0       	rjmp	.+4      	; 0x7c7e <memcpy+0xa>
    7c7a:	01 90       	ld	r0, Z+
    7c7c:	0d 92       	st	X+, r0
    7c7e:	41 50       	subi	r20, 0x01	; 1
    7c80:	50 40       	sbci	r21, 0x00	; 0
    7c82:	d8 f7       	brcc	.-10     	; 0x7c7a <memcpy+0x6>
    7c84:	08 95       	ret

00007c86 <memset>:
    7c86:	dc 01       	movw	r26, r24
    7c88:	01 c0       	rjmp	.+2      	; 0x7c8c <memset+0x6>
    7c8a:	6d 93       	st	X+, r22
    7c8c:	41 50       	subi	r20, 0x01	; 1
    7c8e:	50 40       	sbci	r21, 0x00	; 0
    7c90:	e0 f7       	brcc	.-8      	; 0x7c8a <memset+0x4>
    7c92:	08 95       	ret

00007c94 <_exit>:
    7c94:	f8 94       	cli

00007c96 <__stop_program>:
    7c96:	ff cf       	rjmp	.-2      	; 0x7c96 <__stop_program>
